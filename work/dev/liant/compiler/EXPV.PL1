/* C++ expv.pl1 - Expand a C++ value-node */

/***********************************************************************
 * This product is the property of Liant Software Corporation and is   *
 * licensed pursuant to a written license agreement.  No portion of    *
 * this product may be reproduced without the written permission of    *
 * Liant Software Corporation except pursuant to the license agreement.*
 ***********************************************************************/

/***********************************************************************
 *
 *  LPI EDIT HISTORY               [ Update the VERSION__ string below ]
 *
 *  05.14.93  DGM  125  Backed out 123 change for time being; blowing up
 *			on SVR4 -- no time to look into it.
 *  04.13.93  DGM  124  Set SYMBOL_NODE.ADDR_OF appropriately SPARC CG.
 *  11.11.92  DGM  123  Fixed blowup for bad call through member-pointer.
 *  09.10.92  DGM  122R Another 2nd argument case for va_start to handle.
 *  09.09.92  DGM  122  Try not to blow up for illegal va_start usage.
 *  09.01.92  DGM  121  Multiple bit-field assignment bug fixes (phew).
 *  08.24.92  DGM  121  Catch "(x = y) = z" in -ansic/-classicc mode;
 *			i.e. give not-an-lvalue diagnostic.
 *  08.15.92  DGM  120  Regression fix from 118 conditional operator fix.
 *  08.14.92  DGM  119  Another minor fix related to va_start.
 *  08.10.92  DGM  118  Fix to prevent extraneous error for:
 *			struct T {};
 *			f (struct T x, ...)
 *			{ va_list v; va_start (v, x); }
 *			Fix to not do the usual arithmetic conversions
 *			on the second/third operands of a conditional
 *			if they are of the same type.
 *  07.16.92  DGM  117  Fix in for COLON_VO (regression from 111 changes).
 *			Fix for long standing bug which prevented union
 *			objects with constructors from getting properly
 *			initialized.
 *  06.08.92  DGM  116R Fix in for INITIAL_VO (INIT_REF_CHECK
 *			was trashing current-node-id).
 *  05.29.92  DGM  116  Added CXX_USE_LONG_OPERATIONS for AND/OR/XOR
 *			from LPI-C; fix for enabling of block copies
 *			of string-literals for STRCPY_VO.
 *  05.13.92  DGM  115 	Updated for Sequoia long double support.
 *  05.06.92  PKT  114R	Fixed EXPAND (DOT_VO) for conversion functions,
 *			was regression in 111.
 *  05.01.92  PKT  114	Diagnose initialization of function
 *			and call of uninitialized functction.
 *  04.29.92  PKT  114	Fixed small bug in RECOVER_LVALUE.
 *  04.17.92  PKT  114	Changed EXIT_VO.
 *  04.17.92  PKT  114	Removed ARG_REF_VO support.
 *  04.12.92  PKT  114	Bug fix EXPAND(NEW_VO) for unions, other fixes.
 *  04.18.92  PKT  113	Merge 109->110R with 109->112.
 *  03.27.92  PKT  112  Merge, fix a typo in value-node scheme.
 *  03.26.92  DGM  111  New value-node scheme.
 *  04.02.92  DGM  110R	Support for long double constants (sort of).
 *  03.30.92  DGM  110	Support for the "MARK" macro from <prof.h>.
 *  03.27.92  PKT  109	Support user conversions in switch expression.
 *  03.16.92  DGM  108	Fix for sizeof (reference_type) bug.
 *  03.06.92  PKT  107	Fix for bug discovered by WDB (conditional
 *			expression with enums).
 *  02.20.92  DGM  106	Fix for XOR bug discovered by Sequoia (MicroFocus).
 *  02.10.92  DGM  105	Minor name changes for debugger.
 *  02.06.92  PKT  104	Changed EXPAND(VA_ARG_VO) to support more targets.
 *  02.05.92  DGM  103  Warn for no return value from main on switch.
 *  01.28.92  DGM  102  Reworked VA_START_VO to handle zero or one
 *			argument; this is to handle a missing second
 *			argument for the "va_start" macro (the UNIX V.4
 *			system compiler supports this).
 *  01.21.92  DGM  101  Minimal support for member-reference type,
 *			a cfront extension used by InterViews.
 *  01.10.92  PKT  100	Updated operator overloading.
 *  01.06.92  PKT  100	Modified for better destructor access checking.
 *  12.30.91  PKT  100	Fixed EXPAND(ADDR_VO) for a COUNT problem
 *			involving addr of a reference.
 *  12.14.91  PKT  099  Fixed EXPAND(FUNCTIONAL_CAST_VO) to be a 
 *			conversion rather than a constructor call when
 *			it has 1 argument.
 *  12.04.91  DGM  098R Fix in CALL_VO (don't page useless node). 
 *  11.20.91  DGM  098  Merge.
 *  11.19.91  PKT  097L Fixed VA_START_VO (for __va_start__ builtin) for
 *			parameter preceding ... to be an aggregate.  Also
 *			fixed address of a parameter that has a copy ctor.
 *			Fixed for overloaded non-static member function
 *			call with implicit 'this'.
 *  11.12.91  DGM  094  Merge.
 *  11.06.91  DGM  091  Set SYM_NODE.ALIAS to OPTIMIZER_NEEDS_ALIAS_BIT.
 *			rather than TRUE (switch set in cxxfe.bld).
 *			Warn for usage of enumerator before definition.
 *			Fix CONVERT_RELATIONAL for long double (PKT).
 *  10.03.91  DGM  090  Asm and compilation-assert support.
 *  10.31.91  PKT  093  Fix CONVERT_RELATIONAL for long double.
 *  10.24.91  PKT  092  Updated.
 *  10.09.91  PKT  091  Added VA_ARG_VO and VA_START_VO for Sparc
 *			varargs/stdarg.
 *  09.27.91  PKT  089  Diagnose class's lack of assignment at point
 *			of assignment. Recognize an array designator on
 *			the left side of assignment.
 *			Fixed EXPAND(RETURN_VO) to transmute after doing
 *			VALUE_BEFORE_EFFECT.
 *  09.06.91  PKT  088  Tweaked INDEX_PTR so that CodeWatch can evaluate
 *			a member that's an array of structures.
 *			Changed diagnostic for missing return expression.
 *			Hacked in CONVERT_FLOATING
 *			so that lpipl1.041603.nu would compile this.
 *  09.06.91  DGM  087  Minor update for -lint; also set SYM_NODE.REG-
 *			ISTER_AT to FALSE if ADDR is taken to prevent
 *			back-end blowup.
 *  08.23.91  DGM  086  Don't emit incompatible enum diagnostic in Classic
 *			C mode.  Set SYM_NODE.CONTAINS_CALL_TO_SETJMP;
 *			TODO, change this to set CURRENT_FUNCTION_CALLS_
 *			SETJMP which should be defined in CURRENT_SCOPE_
 *			DATA in CXX_GLOBAL_SEMANTIC_DATA and should be
 *			cleared in BEGIN_FUNCTION_BODY.
 *  08.21.91  DGM  085R Minor fix for in CONSTANT_VO for CodeWatch.
 *  08.19.91  DGM  085  Picked up ANSI-C FE changes (from 06.05.90)
 *			for floating point constant folding.
 *  08.03.91  PKT  084  Bug fix switch (reference).
 *  07.18.91  PKT  083  Support for -istring & -imath.
 *			Fix SYM_NODE.REFERENCED.
 *			Fix EXPAND(ADDR_VO) 080 problem, for debugger.
 *			Clean up ARRAY_DESIGNATOR & FUNCTION_DESIGNATOR.
 *			Support for debugger array slice expressions.
 *  07.18.91  DGM  082  Added call to ____lpi_cxx_exit at return of main.
 *			Added setjmp and alloca handling.
 *  07.09.91  DGM  081  Minor fix for enums in conditionals; fix for
 *			class A; f (A &a) { return (a); } in RETURN_VO;
 *			fix for reference type as switch control.
 *  06.28.91  PKT  080  Fix to delete.  Revised handling of string
 *			literals.  Made call to FIXUP_MEMBER_CALL.
 *			Optimize ADDR(REF(X,0,LOCATOR,0)).
 *  06.12.91  PKT  079  Backed out RECOVER_LVALUE in favor of -xcastl.
 *			Support for call to trivial "operator=".
 *  05.29.91  PKT  078  Support for DESTRUCTOR_VO, for int::~int; fixes.
 *  05.22.91  PKT  077  Support for implicit conversion of reference to
 *			member function to member pointer; for overloading
 *			matching based on constness of 'this'; misc fixes.
 *  05.13.91  PKT  076  Fixed fetch time of simple return value.
 *  05.02.91  DGM  075  Added VA_STACK_VO for SPARC "varargs";
 *			reapply fix from 074 (got misplaced).
 *  04.29.91  DGM  074  Fix in CONSTANT_VO for CodeWatch and another in
 *			EXPLICIT_COMMA_VO (fixed ANSI-C sampler a053).
 *  04.24.91  PKT  073  Tightened up support for overloaded functions.
 *  04.18.91  DGM  072  Added missing checks for SCHAR_BT and fix in
 *			MINUS_VO for creating new string for float.
 *  04.10.91  DGM  071  Fix in ADDR_VO for sizeof (*&array).
 *  03.27.91  TLF  070  Added code at CALL_VO to issue a diagnostic 
 *			for an unmatched reference to an overloaded
 *			function.
 *  03.27.91  PKT  070  Updated.
 *  03.26.91  PKT  069  Fixed for explicit conversion function names,
 *			for detecting member types appearing in expressions,
 *			and for complicated initializers in new operations.
 *			Added support for -ztemp with ?:, ||, and &&.
 *			Fixed value node leak in EXPAND(CONSTANT_VO).
 *  03.21.91  DGM  068  Fix in INITIAL_VO for
 *			union u {int i;}; f () { u y = {1}; }.
 *  03.20.91  TLF  067  Added call to VALUE_OF in CONDITIONAL_VO.
 *  03.12.91  DGM  066  Fix in INITIAL_VO (for 063 fix).
 *  03.05.91  PKT  065  Updated for destructor access fix, references
 *			to functions, and other fixes.
 *  02.27.91  DGM  064  Fixes for sizeof, function/array designators,
 *			and initialization of reference to union.
 *  02.21.91  DGM  063  Miscellaneous fixes.
 *  02.21.91  PKT  062  Updated for member pointers.
 *  02.11.91  DGM  061  PKT fixes for bit-field references.
 *  02.01.91  DGM  060  Updated to new global names scheme.
 *  01.31 91  DGM  059  PKT fixes for address of overloaded function.
 *  01.27 91  PKT  058  Updated for member pointers.
 *  01.23.91  TLF  057  Added call to CHECK_USER_CONVERSION at
 *			CONDITIONAL_VO.
 *  01.18.91  DGM  056  Enumerator compatibility checks.
 *  01.11.91  PKT  055  Updated; moved static data member support to
 *			ACCESS_DATA_MEMBER.
 *  01.10.91  DGM  054  Applied PKT fix for BRANCH_TRUE/FALSE_VO;
 *			caused "while (x, !x);" to fail.
 *  12.28.90  PKT  053  Updated.
 *  12.21.90  PKT  052  Moved MEMBER_FUNCTION_CALL and accessing a data
 *			member to "member.pl1".  Updated for improved
 *			TRANSMUTE_WITH_TEMP.  Improved member access and
 *			ambiguity checking.
 *  12.05.90  DGM  051  Call virtual functions non-virtually if they are
 *			called thru a class object (i.e. as opposed to a
 *			a pointer or referenced to a class object).
 *  11.09.90  PKT  050  Update for default arguments.  LEFT of a REF may
 *			now be value node id of DECLARE_TEMP_VO.
 *  11.06.90  DGM  049  Fixed DOT_VO to check for d.B::m when B is not a
 *			base class of D.  Fixed CALL_VO to call qualified
 *			virtual member functions non-virtually.  Give
 *			warning when directly calling a pure virtual.
 *			Proper support for CodeWatch constants.
 *  11.01.90  PKT  048  Updated for strict INITIALIZE_OBJECT.
 *			EXPAND(COMMA_VO...) and EXPAND(LEFT_VALUE_VO...)
 *			had their guts moved to clsutl.pl1.
 *			Guts of EXPAND(NOP_VO...) moved to convrt.pl1.
 *			Fixed MEMBER_FUNCTION_CALL: virtual call at right time.
 *			Fixed EXPAND(NEW_VO...) to report ERR_NEW_NO_MATCH.
 *  10.24.90  PKT  047  Fixed EXPAND(DOT_VO) not to confuse EMIT_TREE.
 *  10.18.90  TLF  046  Removed BASED_SYM, REF_WITH_LOCATOR, and 
 *                      REF_WITH_OFFSET to an external module.
 *  10.17.90  PKT  045  Tweak to EXPAND(DOT_VO) for debugger.
 *  10.16.90  PKT  044  Updates & fixes.
 *  10.12.90  DGM  043  Minor fix in IMPLICIT_ADDR_VO.
 *  10.10.90  DGM  042  Prevent warning for no return value in "main".
 *  09.28.90  PKT  041  Bug fixes.
 *  09.25.90  DGM  040  Preprocessor include file name changes.
 *  09.17.90  PKT  039  Bug fixes, so that operators new and delete work.
 *  09.14.90  DGM  038  Changed include file names and VOP names.
 *  09.13.90  DGM  037  Changed xxx_SC names to xxx_ST.
 *  09.13.90  DGM  036  Added include of CXX_VALUE_NAMES_PKG so we can
 *			use the new VALUE_TYPE_NAME (vid_t) routine
 *			while debugging.
 *  09.06.90  TLF  035  Added support for overloading binary comma.
 *  09.05.90  PKT  034  Support for free store operators.
 *  09.04.90  DGM  033  Typo fix in call to COMPATIBLE_RELATIONAL_POINTERS.
 *  08.31.90  TLF  032  Added support for overloading unary &.
 *                      Fixed bug: do not do overload checking for
 *                      pointer-to-function.
 *                      Added code to RETURN_REF_CHECK to handle references
 *                      to classes.
 *  08.29.90  DGM  031  Substituted GET_SIMPLE_TYPE/GET_SIMPLE_POINTER_TYPE
 *  08.27.90  TLF  030  More overloading support ('->', and '[]').
 *			with the new GET_BASIC_TYPE/GET_BASIC_POINTER_TYPE.
 *  08.21.90  TLF  029  Overloading & user conversions.  DGM.
 *  08.15.90  DGM  028  New type-node.
 *  08.07.90  PKT  027  More destruction support; added support for
 *			LEFT_VALUE_VO.
 *  07.26.90  DGM  026  Applied PKT fix to NOP_VO (for COMMA_VO).
 *  07.24.90  TLF  025  Changed all calls to BINARY_CHECKS and UNARY_CHECKS
 *                      to add another parameter.
 *  07.19.90  PKT  024  Destruction support.
 *  07.19.90  DGM  023  Implemented virtual function calls; these and
 *			normal member function calls are now done in
 *			MEMBER_FUNCTION_CALL.  Other minor updates.
 *  07.05.90  PKT  022  CXX_VALUE_NODE.COUNT set to 0 by context, not type.
 *                      Expand member function calls.  Updates from DGM
 *			for pointer conversions in member references.
 *  06.29.90  DGM  021  Changes to relational vops for (class) pointers.
 *  06.25.90  DGM  020  Minor changes (use the type maps when possible).
 *  06.19.90  PKT  019  Fixed bug to permit explicit comma operation
 *			as operand of COLON_VO for structures.
 *  06.18.90  TLF  018  Changes at INITIAL_VO, CALL_VO, ADDR_VO for
 *                      handling reference types.  Also changes at each
 *                      binary or unary vop to call the relevant 
 *                      binary or unary operator checking routine.
 *  06.14.90  PKT  017  Better handling of C compatibility; bug fixes.
 *  06.05.90  DGM  016  Updated for the new utilities.
 *  05.31.90  PKT  015  Changed for calling member functions and
 *			assignment returning lvalue.
 *  05.04.90  TLF  014  Add code for MOD, AND, OR, and XOR.
 *  05.02.90  DGM  013  Check for assignment to classes containing
 *			"const" members (error), and to "const" types
 *			during initialization (no error).
 *  04.27.90  DGM  012  Changed type map names from IS_xxx to IS_xxx_TYPE.
 *  04.19.90  DGM  011  Changed STRING_TOKEN in CONSTANT_VO to
 *			to COOKED_[W]STRING_LITERAL_TOKEN, and changed
 *			C_DECLARE_MISCELLANY_PKG to CXX_DECLARE_TYPE_PKG.
 *  04.17.90  PKT  010  Improved CALL_VO support, including arg conversion.
 *  04.05.90  TLF  009  Added FIELD_MASK, CONVERT_BITOP, and CONVERT_COMP_BIT.
 *  04.02.90  DGM  008  Changed MAKE_SIMPLE_TYPE to GET_SIMPLE_TYPE, and
 *			CXX_PROCESS_DECLARATION_PKG to C_DECLARE_MISCELLANY_PKG.
 *  03.27.90  DGM  007  Changes SEARCH_CLASS_LATTICE to SEARCH_CLASS.
 *  03.16.90  TLF  006  Added pointer compatibility semantic check
 *                      routines.  Added pointer subtraction.
 *  03.14.90  PKT  005  Many additions to support ANSI C.
 *  02.26.90  PKT  004  Updated FINISH_CONSTANT to set type info.
 *  02.22.90  DGM  003  Changed call to BASE_TYPE_NAME; use interface
 *			defined in CXX_SYMBOL_TABLE_NAMES_PKG.
 *  02.22.90  TLF  002  Updated.
 *  01.17.90  TLF  000  Original.
 *
 ***********************************************************************/

/* ---------------------------------------------------------------------
/* Version and copyright stamp
/* ------------------------------------------------------------------- */

declare	VERSION__	character (28) varying static internal initial

('@(#)LPI 05.14.93 125 EXPV');

/* ---------------------------------------------------------------------
/* Include files
/* ------------------------------------------------------------------- */

%nolist;
%include 'incfil';
%include GLOBAL_IN;
%include CXX_UTL_DEFS_IN;
%include CXX_UTL_SYMBOL_TABLE_PKG;
%include CXX_UTL_VALUE_NODE_PKG;
%include CXX_UTL_OPERATOR_PKG;
%include CXX_UTL_WRITE_PKG;
%include CXX_UTL_ROUNDU_PKG;
%include CXX_UTL_ADD_XREF_PKG;
%include CXX_STANDARD_DEFS_IN;
%include CXX_EXTERNAL_NAME_MAP_IN;
%include CXX_DEBUG_SWITCHES_IN;
%include CXX_SOURCE_MGR_PKG;
%include CXX_NODE_MGR_PKG;
%include CXX_SYMBOL_TABLE_PKG;
%include CXX_SYMBOL_TABLE_NAMES_PKG;
%include CXX_VALUE_NAMES_PKG;
%include CXX_TYPE_MAP_IN;
%include CXX_TARGET_HARDWARE_IN;
%include CXX_VALUE_NODE_IN;
%include CXX_OPERATOR_CODES_IN;
%include CXX_PP_TOKEN_POD_MGR_PKG;
%include CXX_PROCESS_EXPRESSION_PKG;
%include CXX_PROCESS_STATEMENT_PKG;
%include CXX_VALUE_NODE_MGR_PKG;
%include CXX_COMPOSITE_TYPE_PKG;
%include CXX_TYPE_SIZE_PKG;
%include CXX_TYPE_INFO_PKG;
%include CXX_TYPE_COMPATIBILITY_PKG;
%include CXX_DECLARE_TYPE_PKG;
%include CXX_DECLARE_SYMBOL_PKG;
%include CXX_GLOBAL_NAMES_PKG;
%include CXX_INITIALIZE_STRING_PKG;
%include CXX_ERROR_MGR_PKG;
%include CXX_OPERATOR_NAME_PKG;
%include CXX_DUMP_VALUE_TREE_PKG;
%include CXX_GET_EXPANDED_VALUE_PKG;
%include CXX_COUNT_UP_VALUE_PKG;
%include CXX_INTEGER_VALUE_PKG;
%include CXX_FOLD_VALUE_PKG;
%include CXX_CONVERT_VALUE_PKG;
%include CXX_CONVERT_CLASS_POINTER_PKG;
%include CXX_COUNT_DOWN_VALUE_PKG;
%include CXX_PROCESS_CONSTANT_PKG;
%include CXX_COPY_VALUE_PKG;
%include CXX_DUPLICATE_VALUE_PKG;
%include CXX_INTEGRAL_PROMOTION_PKG;
%include CXX_EVALUATE_INTEGER_PKG;
%include CXX_EVALUATE_POINTER_PKG;
%include CXX_MAKE_TEMPORARY_PKG;
%include CXX_GLOBAL_SEMANTIC_DATA_IN;
%include CXX_GLOBAL_EXPRESSION_DATA_IN;
%include CXX_LOOKUP_BUILTIN_PKG;
%include CXX_CHECK_ARGUMENT_LIST_PKG;
%include CXX_EXPRESSION_COMPATIBILITY_PKG;
%include CXX_COMPILATION_SWITCHES_IN;
%include CXX_CLASS_UTL_PKG;
%include CXX_CALL_DESTRUCTOR_PKG;
%include CXX_ACCESS_CONTROL_PKG;
%include CXX_MEMBER_VALUE_PKG;
%include CXX_MEMBER_POINTER_PKG;
%include CXX_BIND_EXPRESSION_UTL_PKG;
%include CXX_CHECK_REFERENCE_TYPE_PKG;
%include CXX_TYPE_CLASS_PKG;
%include CXX_OVERLOAD_PKG;
%include CXX_BASSYM_PKG;
%list;

/* ---------------------------------------------------------------------
/* EXPAND_VALUE
/*
/* Bind and expand an expression tree.  Except in the case of expanding
/* a few particular operators, the returned expression tree must either
/* be used as an operand or processed through INITIALIZE_OBJECT or
/* TRANSMUTE_WITH_TEMP.  This is true even if the result type is 'void'.
/* Exceptions include NOP_VO, BRANCH_VO, etc.
/*
/* The expanded expression is paged in on return, an its node id
/* is the returned value.
/* ------------------------------------------------------------------- */

EXPAND_VALUE: procedure (TREE) 
	      returns   (type (CXX_VID_T)) 
	      recursive
	      external  (X_EXPAND_VALUE);

declare
	TREE		type (POINTER_T);
declare
	NESTING_LEVEL	type (SHORT_T) static internal initial (-1);
declare
	EXPAND_DONE	type (BOOL_T);
declare
	WORK_TYPE_01    type (TYPE_INFO_T),
	WORK_TYPE_02    type (TYPE_INFO_T);
declare
	V		type (POINTER_T),	/* value under expansion */
	LEFT		type (CXX_VID_T),
	RIGHT		type (CXX_VID_T),
	THIRD		type (CXX_VID_T),		/* V's operands */
	T		type (CXX_VID_T),
	T1		type (CXX_VID_T),
	K		type (SHORT_T),
	(ID1, ID2)	type (NID_T),
	KN		type (NID_T),
	KV		type (CXX_VID_T),
	K1		type (SHORT_T),
	KV1		type (CXX_VID_T),
	K2		type (NID_T),
	KV2		type (CXX_VID_T),
	VV		type (CXX_VID_T),
	KB		type (BYTE_BITS_T),
	OVLD_FSYM	type (NID_T),
	I		type (SHORT_T),
	VOP		type (SHORT_T),
	SAVED_VOP	type (SHORT_T),
	TYPE		type (SHORT_T),
	TID		type (NID_T),
	OFFSET		type (LONG_T),
	BDRY		type (SHORT_T),
	ACTUAL_SZ	type (LONG_T),
	THIS_SIZE       type (LONG_T),
	THIS_SIZE_UNITS type (SHORT_T),
	OFFSET_UNITS	type (SHORT_T),
	SCOPE		type (NID_T),
	VICTIM		type (CXX_VID_T);
declare
	VOFF		type (BOOL_T),
	IS_CONST	type (BOOL_T),
	IS_DEST		type (BOOL_T),
	IS_ERROR	type (BOOL_T),
	IS_MAIN		type (BOOL_T),
	IS_SIGNED	type (BOOL_T),
	IS_BITFIELD	type (BOOL_T),
	RIGHT_IS_COMMA	type (BOOL_T);
declare
	FIELD		type (CXX_VID_T),
	MASK		type (CXX_VID_T),
	SHIFT		type (CXX_VID_T),
	FIELD_TYPE	type (SHORT_T),
	FLT52		float binary (52);
declare
	RIGHT_IS_NID	type (BOOL_T),
	RIGHT_IS_VID	type (BOOL_T);
declare
	1 LEFT_union	union,
	  2 LEFT	type (CXX_VID_T),
	  2 LEFT_NID	type (NID_T),
	1 RIGHT_union	union,
	  2 RIGHT	type (CXX_VID_T),
	  2 RIGHT_NID	type (NID_T),
	1 THIRD_union	union,
	  2 THIRD	type (CXX_VID_T),
	  2 THIRD_NID	type (NID_T);
declare
	P			type (POINTER_T);
declare
	S		character (64) varying based;
declare
	STRING_T	character (512) varying based;

        V = TREE;

	if TRACE_EXPAND_VALUE then do;
		NESTING_LEVEL = NESTING_LEVEL + 1;
		call DUMP_EXPAND_VALUE_DATA ('ENTERING');
	end;

	CXX_VALUE_NODE_PTR = V;

DO_EXPAND:
	if CXX_VALUE_NODE.LEFT_IS_NID then
		LEFT_NID	= CXX_VALUE_NODE.LEFT_NID;
	else	LEFT		= CXX_VALUE_NODE.LEFT;
	if CXX_VALUE_NODE.RIGHT_IS_NID then
		RIGHT_NID	= CXX_VALUE_NODE.RIGHT_NID;
	else	RIGHT		= CXX_VALUE_NODE.RIGHT;
	if CXX_VALUE_NODE.THIRD_IS_NID then
		THIRD_NID	= CXX_VALUE_NODE.THIRD_NID;
	else	THIRD		= CXX_VALUE_NODE.THIRD;
        VOP	= CXX_VALUE_NODE.OP;

        goto EXPAND (VOP);

REEXPAND:
	if TRACE_EXPAND_VALUE then
		call DUMP_EXPAND_VALUE_DATA ('RE-ENTERING');

        goto DO_EXPAND;

REORDER_FOLD_AND_EXIT:

        if LEFT->CXX_VALUE_NODE.OP <= VALUE_VO then do;
                K = LEFT->CXX_VALUE_NODE.OP;
                if RIGHT->CXX_VALUE_NODE.OP > K then do;
			/*
                        /* Swap to put "simpler" on right.
			/**/
                        if      VOP = GE_VO then VOP = LE_VO;
                        else if VOP = LE_VO then VOP = GE_VO;
                        else if VOP = GT_VO then VOP = LT_VO;
                        else if VOP = LT_VO then VOP = GT_VO;
                        V->CXX_VALUE_NODE.OP	= VOP;
                        V->CXX_VALUE_NODE.LEFT	= RIGHT;
                        V->CXX_VALUE_NODE.RIGHT	= LEFT;
		end;
	end;

FOLD_AND_EXIT:	/* Current value is V */

        V = FOLD_VALUE (V);

EXIT:   	/* Current value is V */

	if TRACE_EXPAND_VALUE then do;
		call DUMP_EXPAND_VALUE_DATA ('EXITING');
		NESTING_LEVEL = NESTING_LEVEL - 1;
	end;

        return (V);

RETURN_ZERO:
	/*
	/* Come here with V's CXX_VALUE_NODE.OFFSET equal to 0,
	/* and V's CXX_VALUE_NODE.TOP_TYPE.TYPE_CODE equal to 0,
	/* or the desired integral type. 
	/**/
	CXX_VALUE_NODE_PTR	= V;
        CXX_VALUE_NODE.OP	= INTEGER_VO;
        CXX_VALUE_NODE.LEFT	= NULL_CXX_VID;
        CXX_VALUE_NODE.RIGHT	= NULL_CXX_VID;
        goto DO_EXPAND;

RETURN_ZILCH:
	call COUNT_DOWN_VALUE (V);
	V = null ();
	goto EXIT;

RETURN_VOID:
	V->CXX_VALUE_NODE.OP = UNINITIALIZED_VO;
	V->CXX_VALUE_NODE.NULARY = TRUE;
	CXX_VALUE_NODE_PTR = V;
	call SET_VALUE_SIMPLE_TYPE (VOID_BT);
	goto EXIT;

/*------------------------------*/


EXPAND(IMPLICIT_ASSIGN_VO): ;			/* Assign,		    */
						/* without overloading	    */
						
EXPAND(COPY_VO): ;				/* Assign a value to a	    */
						/* previously uninitialized */
						/* object.  		    */
						/* Does not return a value. */
        CXX_VALUE_NODE.OP = ASSIGN_VO;

EXPAND(ASSIGN_VO):				/* Returns a value.	    */

        /* -------------------------------
        /* LEFT should be VALUE(REF(...)).
        /* RIGHT is expression.
        /* ----------------------------- */

	/*-------------------------------------------------------
	/*  This is indeed a strange action routine.  
	/*  It converts the assign_vo as follows:
	/*   The original RIGHT expression has an implicit cast
	/*   imposed, casting it to the type of the target of
	/*   the assign.  The original assign_vo becomes the
	/*   LEFT of a comma_vo.  The RIGHT of the comma is
	/*   the original LEFT of the assign.  Also, the LEFT of
	/*   the assign_vo becomes the ref, not the value.
	/*   The count on this comma_vo is set to 1, and on the
	/*   assign_vo is set to 0.
	/*  Later, in emitt, this particular form of comma_vo
	/*  is recognized, and the operators are emitted only for its
	/*  LEFT, which is the original assign.
	/*
	/*  This transformation is based on the idea that once
	/*  EXPAND_VALUE is done, assign_vo exists only for its
	/*  side effect and does not produce a value.  The 
	/*  arrangement with the comma_vo is necessary so that
	/*  EXPAND_VALUE will return an expression which obeys
	/*  C semantic rules, returning a value.  The count of
	/*  all expressions that don't return a value
	/*  is 0, even if they appear as an operand of comma,
	/*  to help get the counts correct in the file of ops.
	/*
	/*  This is changed around from ANSI C.  ANSI C hooked up
	/*  the RIGHT of the comma up with the RIGHT of the assign,
	/*  to get better code.  But in C++ the result of an assign
	/*  is an lvalue, and our optimizer is better than it
	/*  was when that design choice was made.
	/*-------------------------------------------------------*/


	if VOP = ASSIGN_VO then do;
		call BINARY_CHECKS
		      (V, LEFT, RIGHT, THIRD, EXPAND_DONE);
		if EXPAND_DONE then
			goto EXIT;
	end;

	/* Warn about value used before set if desired */

	else if SW_LINT then do;
		call CHECK_IF_USED_BEFORE_SET (LEFT, VOP);
		call CHECK_IF_USED_BEFORE_SET (RIGHT, REF_VO);
	end;

	CXX_VALUE_NODE_PTR = LEFT;		/* lvalue VALUE */
	call GET_VALUE_TYPE (WORK_TYPE_01);	/* lvalue type */

	if CXX_VALUE_NODE.ARRAY_DESIGNATOR then do;
		call RESTORE_ARRAY_VALUE (LEFT, WORK_TYPE_01);
		call SEMANTIC_ERROR (ERR_ARRAY_ASSIGN);
	end;
	if CXX_VALUE_NODE.FUNCTION_DESIGNATOR then
		call RESTORE_FUNCTION_VALUE (LEFT, WORK_TYPE_01);
        
        if   (VOP = ASSIGN_VO | VOP = IMPLICIT_ASSIGN_VO) 
	   & WORK_TYPE_01.NOT_AN_LVALUE then do;
		/*
		/* An lvalue is required here.
		/**/
		if CXX_VALUE_NODE.OP ^= VALUE_VO then do;
			/*
			/* Left side of assignment is not
			/* an lvalue as required.
			/**/
			call SEMANTIC_ERROR (ERR_BAD_LVALUE_ASSIGN);
			CXX_VALUE_NODE_PTR	= V;
			CXX_VALUE_NODE.OP	= IMPLICIT_CAST_VO;
			CXX_VALUE_NODE.LEFT	= LEFT;
			goto REEXPAND;
		end;

		/* VALUE_VO;  recoverable error */

		call SEMANTIC_ERROR (ERR_NOT_AN_LVALUE);
		LEFT = COPY_VALUE (LEFT);
		CXX_VALUE_NODE.NOT_AN_LVALUE	= FALSE;
		CXX_VALUE_NODE_PTR		= V;
		CXX_VALUE_NODE.LEFT		= LEFT;
	end;

	/* Transmute LEFT to eliminate DOT_STAR_VO */

	LEFT = TRANSMUTE_WITH_TEMP
	       (LEFT, VICTIM, FALSE, AUTO_ST, IMPLICIT_ADDR_VO);

        if CXX_VALUE_NODE.OP ^= VALUE_VO then 
		call COMPILER_ERROR (ERR_ASSERT_FAIL);

	/* Guard against writing a "const" object */

	if CXX_VALUE_NODE.LEFT_IS_NID then  /* sym-node id ? */
		goto DONE_CONST_CHECK;

	if CXX_VALUE_NODE.OP = VALUE_VO then do;
		/*
		/* Set the sym-node up; currently not needed.
		/**/
		CXX_VALUE_NODE_PTR = CXX_VALUE_NODE.LEFT; /* lvalue REF */
		if ^CXX_VALUE_NODE.LEFT_IS_NID |
		   (CXX_VALUE_NODE.OP ^= REF_VO) then do;
			CXX_VALUE_NODE_PTR = LEFT;  /* lvalue VALUE */
			goto DONE_CONST_CHECK;
		end;
		CXX_VALUE_NODE_PTR = LEFT;  /* lvalue VALUE */
	end;

	if VOP = COPY_VO then
		goto DONE_CONST_CHECK;

	TYPE = rank (WORK_TYPE_01.TOP_TYPE.CODE);
	if WORK_TYPE_01.TOP_TYPE.CONST then do;
               	call SEMANTIC_ERROR (ERR_ILLEGAL_CONST_ACCESS);
	end;
	else if IS_AGGREGATE_TAG_TYPE (TYPE) then do;
		call SET_SYM_NODE_R (WORK_TYPE_01.TOP_TYPE.TAG_SYMBOL);
		if SYM_NODE.NEEDS_ASSIGN | ^SW_STRICT_LVALUE then do;
			if ^SYM_NODE.IS_DUMMY then
				/*
				/* The assignment operator for this
				/* class has not been declared,
				/* because it can't be generated.
				/**/
				call SEMANTIC_ERROR_I
				     (ERR_ILLEGAL_CLASS_ASSIGN,
				      QUALIFIED_SYMBOL_NAME
				      (WORK_TYPE_01.TAG_SYMBOL));
		end;
		else if SYM_NODE.HAS_CONST_MEMBER then do;
			call SEMANTIC_ERROR (ERR_ILLEGAL_CONST_ACCESS);
			/*
			/* No longer goto EXIT here;
			/* was returning troublesome value-node. - PKT
			/**/
		end;
  	end;

	DONE_CONST_CHECK:

	call DETERMINE_SIZE (WORK_TYPE_01);

	KV = LEFT;			/* lvalue VALUE */
	LEFT = KV->CXX_VALUE_NODE.LEFT;	/* lvalue REF */
	call COUNT_UP_VALUE (LEFT);

	/*
	/* LEFT is the REF from V's LEFT, with 1 use pending
	/* KV is the VALUE from V's LEFT, with 1 use pending
	/**/

	if KV->CXX_VALUE_NODE.SIZE_UNITS = byte (BITS) then do;

		call COUNT_UP_VALUE (KV);  /* For C++ style assignment */

		IS_BITFIELD = TRUE;
		IS_SIGNED = KV->CXX_VALUE_NODE.SIGNED_BIT_FIELD;

		/* Cast target word as a non-field VALUE as a non-field */

		FIELD = ALLOC_CXX_VALUE_NODE_L (IMPLICIT_CAST_VO, KV);
		call SET_VALUE_TYPE (WORK_TYPE_01);
		CXX_VALUE_NODE.UNARY = TRUE;
		FIELD_TYPE = rank (WORK_TYPE_01.TOP_TYPE.CODE);

		if ^IS_SIGNED then do;
			/*
			/* Field type was unsigned by default.
			/**/
			if	(FIELD_TYPE = CHAR_BT)   |
				(FIELD_TYPE = SCHAR_BT)  then
				 FIELD_TYPE = UCHAR_BT;
			else if (FIELD_TYPE = SHORT_BT)  |
				(FIELD_TYPE = SSHORT_BT) then
				 FIELD_TYPE = USHORT_BT;
			else if (FIELD_TYPE = INT_BT)    |
				(FIELD_TYPE = SINT_BT)   then
				 FIELD_TYPE = UINT_BT;
			else if (FIELD_TYPE = LONG_BT)   |
				(FIELD_TYPE = SLONG_BT)  then
				 FIELD_TYPE = ULONG_BT;
		end;

		/* Pick up field info from VALUE */

		CXX_VALUE_NODE_PTR = KV; /* the original VALUE */
		WORK_TYPE_01.TOP_TYPE.CODE =
			byte (KV->CXX_VALUE_NODE.RIGHT_SHORT);
		WORK_TYPE_01.TYPE = KV->CXX_VALUE_NODE.THIRD_NID;
		WORK_TYPE_01.SIZE_UNITS = BITS; /* artificial, see FIELD_VO */

		/* Construct the mask for the right side */

		K1 = KV->CXX_VALUE_NODE.SIZE;
		SHIFT = INTEGER_VALUE (KV->CXX_VALUE_NODE.OFFSET, SHORT_BT);
		call COUNT_UP_VALUE (SHIFT); /* used again below */
		MASK = FIELD_MASK (K1);

		/* Get the value to be used for the result in KV2 */

		KV2 = RIGHT;
		RIGHT_IS_COMMA = FALSE;

		if RIGHT->CXX_VALUE_NODE.OP = COMMA_VO then do;
			do KV2 = RIGHT
			while (KV2->CXX_VALUE_NODE.OP = COMMA_VO);
				KV2 = KV2->CXX_VALUE_NODE.RIGHT;
			end;
			RIGHT_IS_COMMA = TRUE;
		end;
		else if (RIGHT->CXX_VALUE_NODE.OP = VALUE_VO) &
			(RIGHT->CXX_VALUE_NODE.LEFT ^= NULL_CXX_VID) then do;
			if RIGHT->CXX_VALUE_NODE.LEFT->
			          CXX_VALUE_NODE.OP = COMMA_VO then do;
				do KV2 = RIGHT->CXX_VALUE_NODE.LEFT
				while (KV2->CXX_VALUE_NODE.OP = COMMA_VO);
					KV2 = KV2->CXX_VALUE_NODE.RIGHT;
				end;
				KV1 = RIGHT;
				RIGHT = RIGHT->CXX_VALUE_NODE.LEFT;
				KV1->CXX_VALUE_NODE.LEFT = KV2;
				KV2 = KV1;
				RIGHT_IS_COMMA = TRUE;
			end;
		end;
		
		/* Mask the result of the assignment & put it in THIRD */

		if IS_SIGNED then do;
			KV2 = CONVERT_VALUE (KV2, INT_BT);
			if ^CXX_USE_LONG_OPERATIONS then
				KV2 = CONVERT_VALUE (KV2, SHORT_BT);
		end;
		else do;
			KV2 = CONVERT_VALUE (KV2, UINT_BT);
			if ^CXX_USE_LONG_OPERATIONS then
				KV2 = CONVERT_VALUE (KV2, USHORT_BT);
		end;
		call COUNT_UP_VALUE (MASK);  /* used again below */
		KV2 = GET_VALUE_AND_EXPAND_LR (AND_VO, KV2, MASK);
		THIRD = KV2;

		/* Mask the right side of the assignment & put it in KV2 */

		call COUNT_UP_VALUE (KV2);

		if IS_SIGNED then do;
			KV2 = CONVERT_VALUE (KV2, INT_BT);
			if ^CXX_USE_LONG_OPERATIONS then
				KV2 = CONVERT_VALUE (KV2, SHORT_BT);
		end;
		else do;
			KV2 = CONVERT_VALUE (KV2, UINT_BT);
			if ^CXX_USE_LONG_OPERATIONS then
				KV2 = CONVERT_VALUE (KV2, USHORT_BT);
		end;
		call COUNT_UP_VALUE (MASK);

		KV2 = GET_VALUE_AND_EXPAND_LR (AND_VO, KV2, MASK); /* ? */

		/* Construct a bit mask to clear field bits */

		MASK = GET_VALUE_AND_EXPAND_LR (LSHIFT_VO,     MASK, SHIFT);
		MASK = GET_VALUE_AND_EXPAND_L  (COMPLEMENT_VO, MASK);

		/* Mask target word and merge in right bits */

		FIELD = GET_VALUE_AND_EXPAND_LR (AND_VO,    FIELD, MASK);
		KV2   = GET_VALUE_AND_EXPAND_LR (LSHIFT_VO, KV2,   SHIFT);
		KV2   = GET_VALUE_AND_EXPAND_LR (OR_VO,     FIELD, KV2);

		KV2 = CONVERT_VALUE (KV2, FIELD_TYPE);
	end;
	else do;
		/*
		/* Convert right to type of left.
		/**/
		RIGHT = GENERAL_CONVERT_VALUE (RIGHT, WORK_TYPE_01, VOP);
		call COUNT_UP_VALUE (RIGHT); /* Will be used again on COMMA */
		KV2 = RIGHT;
		THIRD = RIGHT;               /* Result */
		IS_BITFIELD = FALSE;
	end;

	if RIGHT->CXX_VALUE_NODE.TOP_TYPE.CODE = byte (FUNCTION_DT) then do;
		/*
		/* Error; attempt to assign to or initialize a function.
		/**/
		call SEMANTIC_ERROR (ERR_CONVERT_FUNCTION);
	end;

	if ^AM_DEBUGGER then do;
		if XREF then
			call ADDXRF (LEFT->CXX_VALUE_NODE.LEFT_NID, TRUE);
	end;

	if VOP = COPY_VO then do;
		call COUNT_DOWN_VALUE (THIRD);
		call COUNT_DOWN_VALUE (KV);
		V->CXX_VALUE_NODE.LEFT  = NULL_CXX_VID;
		V->CXX_VALUE_NODE.RIGHT = NULL_CXX_VID;
		call COUNT_DOWN_VALUE (V);
		V = INITIALIZE_OBJECT (LEFT, KV2);
		if IS_BITFIELD then do;
			call COUNT_UP_VALUE (V);
			KV = ALLOC_CXX_VALUE_NODE_LR (COMMA_VO, RIGHT, V);
			call SET_VALUE_SIMPLE_TYPE (VOID_BT);
			V = KV;
		end;
		goto EXIT;
	end;
	else if SW_STRICT_LVALUE then do;
		call COUNT_DOWN_VALUE (KV);
		if ^IS_BITFIELD then do;
			call COUNT_DOWN_VALUE (THIRD);
			RIGHT = TRANSMUTE_WITH_TEMP
				(RIGHT, VICTIM, FALSE, AUTO_ST, COPY_VO);
			call COUNT_UP_VALUE (RIGHT);
			LEFT = ALLOC_CXX_VALUE_NODE_LR (ASSIGN_VO, LEFT, RIGHT);
			call SET_VALUE_SIMPLE_TYPE (VOID_BT);
			V->CXX_VALUE_NODE.OP    = COMMA_VO;
			V->CXX_VALUE_NODE.LEFT  = LEFT;      /* ASSIGN */
			V->CXX_VALUE_NODE.RIGHT = RIGHT;     /* Result */
			CXX_VALUE_NODE_PTR = V;
			call SET_VALUE_TYPE (WORK_TYPE_01);
			V->CXX_VALUE_NODE.NOT_AN_LVALUE = TRUE;
		end;
		else if RIGHT_IS_COMMA then do;
			LEFT = ALLOC_CXX_VALUE_NODE_LR (ASSIGN_VO, LEFT, KV2);
			call SET_VALUE_SIMPLE_TYPE (VOID_BT);
			RIGHT->CXX_VALUE_NODE.RIGHT = LEFT;
			CXX_VALUE_NODE_PTR = RIGHT;
			call SET_VALUE_SIMPLE_TYPE (VOID_BT);
			V->CXX_VALUE_NODE.OP    = COMMA_VO;
			V->CXX_VALUE_NODE.LEFT  = RIGHT;
			V->CXX_VALUE_NODE.RIGHT = THIRD;
			CXX_VALUE_NODE_PTR = V;
			call SET_VALUE_TYPE (WORK_TYPE_01);
			V->CXX_VALUE_NODE.NOT_AN_LVALUE = TRUE;
			VICTIM = NULL_CXX_VID;
		end;
		else do;
			LEFT = ALLOC_CXX_VALUE_NODE_LR (ASSIGN_VO, LEFT, KV2);
			call SET_VALUE_SIMPLE_TYPE (VOID_BT);
			V->CXX_VALUE_NODE.OP    = COMMA_VO;
			V->CXX_VALUE_NODE.LEFT  = LEFT;      /* ASSIGN */
			V->CXX_VALUE_NODE.RIGHT = THIRD;     /* Result */
			CXX_VALUE_NODE_PTR = V;
			call SET_VALUE_TYPE (WORK_TYPE_01);
			V->CXX_VALUE_NODE.NOT_AN_LVALUE = TRUE;
		end;
	end;
	else if ^IS_BITFIELD then do;
		call COUNT_DOWN_VALUE (THIRD);
		RIGHT = TRANSMUTE_WITH_TEMP
		        (RIGHT, VICTIM, FALSE, AUTO_ST, COPY_VO);
		LEFT = ALLOC_CXX_VALUE_NODE_LR (ASSIGN_VO, LEFT, RIGHT);
		call SET_VALUE_SIMPLE_TYPE (VOID_BT);
		/*
		/* Copy KV because its count may be greater than 1, and it
		/* must not be shared with any previous fetch of the value.
		/**/
		V->CXX_VALUE_NODE.OP	= COMMA_VO;
		V->CXX_VALUE_NODE.LEFT	= LEFT;
		V->CXX_VALUE_NODE.RIGHT	= COPY_VALUE (KV);
		V = EXPAND_VALUE (V);
	end;
	else if RIGHT_IS_COMMA then do;
		call COUNT_DOWN_VALUE (THIRD);
		LEFT = ALLOC_CXX_VALUE_NODE_LR (ASSIGN_VO, LEFT, KV2);
		call SET_VALUE_SIMPLE_TYPE (VOID_BT);
		RIGHT->CXX_VALUE_NODE.LEFT =
			TRANSMUTE_WITH_TEMP
			(RIGHT->CXX_VALUE_NODE.LEFT,
			 VICTIM, FALSE, AUTO_ST, COPY_VO);
		RIGHT->CXX_VALUE_NODE.RIGHT = LEFT;
		CXX_VALUE_NODE_PTR = RIGHT;
		call SET_VALUE_SIMPLE_TYPE (VOID_BT);
		/*
		/* Copy KV because its count may be greater than 1, and it
		/* must not be shared with any previous fetch of the value.
		/**/
		V->CXX_VALUE_NODE.OP	= COMMA_VO;
		V->CXX_VALUE_NODE.LEFT	= RIGHT;
		V->CXX_VALUE_NODE.RIGHT	= COPY_VALUE (KV);
		V = EXPAND_VALUE (V);
	end;
	else do;
		call COUNT_DOWN_VALUE (THIRD);
		KV2 = TRANSMUTE_WITH_TEMP
		      (KV2, VICTIM, FALSE, AUTO_ST, COPY_VO);
		LEFT = ALLOC_CXX_VALUE_NODE_LR (ASSIGN_VO, LEFT, KV2);
		call SET_VALUE_SIMPLE_TYPE (VOID_BT);
		/*
		/* Copy KV because its count may be greater than 1, and it
		/* must not be shared with any previous fetch of the value.
		/**/
		V->CXX_VALUE_NODE.OP	= COMMA_VO;
		V->CXX_VALUE_NODE.LEFT	= LEFT;
		V->CXX_VALUE_NODE.RIGHT	= COPY_VALUE (KV);
		V = EXPAND_VALUE (V);
	end;

	V = VALUE_BEFORE_EFFECT (V, VICTIM);
	goto EXIT;

EXPAND(INTEGER_VO):
        /*
        /* Value of the integer is in OFFSET of the CXX_VALUE_NODE.
        /* Desired type is in TOP_TYPE of the CXX_VALUE_NODE.
        /**/

        OFFSET = CXX_VALUE_NODE.OFFSET;
	call GET_VALUE_TYPE (WORK_TYPE_01);
        TYPE = rank (WORK_TYPE_01.TOP_TYPE.CODE);

FINISH_INTEGER:
        if TYPE = 0 then do;
		if (OFFSET <= MAX_INTEGER) & (OFFSET >= -MAX_INTEGER-1) then
			TYPE = INT_BT;
		else 	TYPE = LONG_BT;
	end;
	if V->CXX_VALUE_NODE.TOP_TYPE.CODE ^= byte (TYPE) then do;
		/*
		/* TODO: what if TYPE is ENUM_BT, then how do we set
		/* TOP_TYPE.TAG_SYMBOL?  I don't think this can
		/* currently happen, but this should get cleaned up.
		/**/
		V->CXX_VALUE_NODE.TOP_TYPE.CODE		= byte (TYPE);
		V->CXX_VALUE_NODE.TOP_TYPE.QUALIFIERS	= NULL_TQ;
	end;
        V->CXX_VALUE_NODE.OP		= INTEGER_VO;
        V->CXX_VALUE_NODE.LEFT		= NULL_CXX_VID;
        V->CXX_VALUE_NODE.RIGHT		= NULL_CXX_VID;
        V->CXX_VALUE_NODE.OFFSET	= OFFSET;
        V->CXX_VALUE_NODE.UNARY		= TRUE;
	CXX_VALUE_NODE_PTR = V;
	call SET_VALUE_SIMPLE_TYPE_DATA (V->CXX_VALUE_NODE.TOP_TYPE);
        goto FOLD_AND_EXIT;

FINISH_CONSTANT:
	/*
	/* TODO: what if TYPE is ENUM_BT, then how do we set
	/* TOP_TYPE.TAG_SYMBOL?  I don't think this can
	/* currently happen, but this should get cleaned up.
	/**/
        call SET_VALUE_SIMPLE_TYPE (TYPE);
        CXX_VALUE_NODE.UNARY = TRUE;
        goto FOLD_AND_EXIT;

EXPAND(CONSTANT_VO):

	/*
	/* If LEFT is non-zero, then:
	/* - LEFT is the value-node id of a value whose SPTR and SIZE
	/*   represent a token-pod-spelling string (and its length)
	/*   containing the constant.
	/* - RIGHT is one of: FLOAT_CONSTANT_TOKEN, OCTAL_CONSTANT_TOKEN,
	/*   DECIMAL_CONSTANT_TOKEN, HEX_CONSTANT_TOKEN, CHAR_CONSTANT_TOKEN,
	/*   COOKED_CHAR_CONSTANT_TOKEN, COOKED_WCHAR_CONSTANT_TOKEN,
	/*   COOKED_STRING_LITERAL_TOKEN, COOKED_WSTRING_LITERAL_TOKEN
	/*
	/* If LEFT is zero, then this is a request from CodeWatch:
	/* - RIGHT is one of: FLOAT_CONSTANT_TOKEN, OCTAL_CONSTANT_TOKEN,
	/*   DECIMAL_CONSTANT_TOKEN, HEX_CONSTANT_TOKEN, CHAR_CONSTANT_TOKEN.
	/* - SPTR is a pointer to a based varying string representing the
	/*   constant.
	/**/

	K = V->CXX_VALUE_NODE.RIGHT_SHORT;

        V->CXX_VALUE_NODE.RIGHT = NULL_CXX_VID;

	if V->CXX_VALUE_NODE.LEFT = NULL_CXX_VID then do;
		/*
		/* Constant from CodeWatch!
		/**/
		if K = FLOAT_CONSTANT_TOKEN then do;
			call PROCESS_CONSTANT
			     (V->CXX_VALUE_NODE.SPTR->S,/* input/result str */
			      OFFSET,		        /* result str length */
			      K,		        /* input type */
			      TYPE);		        /* result type */
			FLT52 = substr (V->CXX_VALUE_NODE.SPTR->S, 1, OFFSET);
			LEFT = ALLOC_EMPTY_CXX_VALUE_NODE ();
			LEFT->CXX_VALUE_NODE.FLTVAL = FLT52;
			V->CXX_VALUE_NODE.LEFT = LEFT;

			CXX_VALUE_NODE_PTR = V;
			goto FINISH_CONSTANT;
		end;
		/*
		/* Here, K is either OCTAL_CONSTANT_TOKEN,
		/* DECIMAL_CONSTANT_TOKEN, HEX_CONSTANT_TOKEN,
		/* or CHAR_CONSTANT_TOKEN.
		/**/
		call PROCESS_CONSTANT (V->CXX_VALUE_NODE.SPTR->S,
				       OFFSET,
				       K,
				       TYPE);
		goto FINISH_INTEGER_CONSTANT;
	end;

	if K = FLOAT_CONSTANT_TOKEN then do;
		/*
		/* For FLOAT_CONSTANT, the length of the string, minus 1,
		/* (which is the string length without the 'F' or 'L'
		/* suffix), is returned in OFFSET, and the type code of the
		/* constant (FLOAT, DOUBLE, or LONG DOUBLE) is returned in TYPE.
		/**/
		TYPE = rank (V->CXX_VALUE_NODE.TOP_TYPE.CODE);
		if TYPE = 0 then do;
			call PROCESS_CONSTANT
			     (V->CXX_VALUE_NODE.LEFT->
				 CXX_VALUE_NODE.SPTR->
				 TOKEN_SPELLING_POD.SPELLING,
			      OFFSET,
			      K,
			      TYPE);
			if (TYPE ^= LDOUBLE_BT) |
			   ^EXTENDED_PRECISION_LONG_DOUBLE then do;
				call CONVERT_FLOATING (TYPE, OFFSET, LEFT);
				call SFREE (LEFT->CXX_VALUE_NODE.SPTR);
			end;
			else	LEFT->CXX_VALUE_NODE.SIZE = OFFSET;
		end;
		CXX_VALUE_NODE_PTR = V;
		goto FINISH_CONSTANT;
	end;
	else if (K = COOKED_CHAR_CONSTANT_TOKEN) |
		(K = COOKED_WCHAR_CONSTANT_TOKEN) then do;
		/*
		/* For CHAR_CONSTANT_TOKEN, the constant is returned as an
		/* integer, right-justified in OFFSET, and TYPE is INT_BT.
		/**/
		call PROCESS_CONSTANT
		     (V->CXX_VALUE_NODE.LEFT->
			 CXX_VALUE_NODE.SPTR->
			 TOKEN_SPELLING_POD.SPELLING,
		      OFFSET,
		      K,
		      TYPE);
		goto FINISH_INTEGER_CONSTANT;
	end;
	else if (K = COOKED_STRING_LITERAL_TOKEN) |
		(K = COOKED_WSTRING_LITERAL_TOKEN) then do;
		/*
		/* Create a symbol initialized to the string.
		/*     Return ADDR(REF(...)).
		/**/
		KN = INITIALIZE_STRING (V, K = COOKED_WSTRING_LITERAL_TOKEN);
		LEFT = GET_REF_AND_EXPAND (KN);
		V = ALLOC_CXX_VALUE_NODE_L (VALUE_VO, LEFT);
		V->CXX_VALUE_NODE.ARRAY_DESIGNATOR = TRUE;
		/*
		/* VALUE of array-of-type expands to pointer-to-type.
		/**/
		goto REEXPAND;
        end;
	else do;
	        call PROCESS_CONSTANT
		     (V->CXX_VALUE_NODE.LEFT->
			 CXX_VALUE_NODE.SPTR->
			 TOKEN_SPELLING_POD.SPELLING,
		      OFFSET,	 /* resultant value */
		      K,	 /* input token type code -- xxx_TOKEN */
		      TYPE);	 /* resultant integral type -- xxx_BT */
	end;

FINISH_INTEGER_CONSTANT:
        call COUNT_DOWN_VALUE (LEFT);  /* Free its cvalue "holder" */
        goto FINISH_INTEGER;

EXPAND(REF_VO):

        /*
        LEFT is symbol id.
        RIGHT will be variable offset value id (or 0).
        THIRD will be a ptr value id for locator (or 0).
        OFFSET will be actual constant offset value (or 0).
        OFFSET_UNITS will be units of OFFSET (when either offset is used).

        (Both constant offset in OFFSET and variable offset represented
         by RIGHT must be maintained in the same units.)
        */

	call SET_SYM_NODE (LEFT_NID); /* the symbol */
	call GET_SYMBOL_TYPE (WORK_TYPE_01);
        WORK_TYPE_01.NOT_AN_LVALUE = CXX_VALUE_NODE.NOT_AN_LVALUE;

	call DETERMINE_SIZE (WORK_TYPE_01);
	OFFSET_UNITS = WORK_TYPE_01.BOUNDARY;

        if XREF & ^AM_DEBUGGER then
		call ADDXRF (LEFT_NID, FALSE);

	/*
	/* Do functions after overloading resolution, and
	/* after we know they're not -imath/-istring.
	/**/
	if SYM_NODE.TOP_TYPE.CODE ^= byte (FUNCTION_DT) then
		call NOTE_SYMBOL_REFERENCE (LEFT_NID);
	/*
	/* If the reference is to a parameter that has a nontrivial copy
	/* constructor, the parameter actually passed is a pointer.
	/* Also do it this way when hardware uses pointer.
	/* Fix it up.
	/**/
	if SYM_NODE.IS_PARAMETER then do;
		if BACK_END_TYPE_BY_REFERENCE (SYM_NODE.TYPE) then do;
			KV = ALLOC_REF_CXX_VALUE_NODE (LEFT_NID);
			WORK_TYPE_02 = WORK_TYPE_01;
			call ADD_POINTER_LEVEL (WORK_TYPE_02);
			call DETERMINE_SIZE (WORK_TYPE_02);
			call SET_VALUE_TYPE (WORK_TYPE_02);
			CXX_VALUE_NODE.OFFSET_UNITS =
				byte (WORK_TYPE_02.BOUNDARY);
			/*
			/* -TODO-
			/* Change the following to call PLAIN_VALUE_OF_REF.
			/**/
			THIRD = GET_VALUE_AND_EXPAND_L (VALUE_VO, KV);
			call SET_VALUE_TYPE (WORK_TYPE_02);
			LEFT_NID = WORK_TYPE_01.TAG_SYMBOL;
		end;
	end;

	CXX_VALUE_NODE_PTR = V;
        call SET_VALUE_TYPE (WORK_TYPE_01);
        V->CXX_VALUE_NODE.LEFT_NID = LEFT_NID;	/* symbol */
	V->CXX_VALUE_NODE.LEFT_IS_NID = TRUE;
	V->CXX_VALUE_NODE.LEFT_IS_NOT_VID = TRUE;
        V->CXX_VALUE_NODE.THIRD	= THIRD;	/* locator */
        V->CXX_VALUE_NODE.OFFSET_UNITS = byte (OFFSET_UNITS);
        goto EXIT;

EXPAND(PARAM_REF_VO):

	goto EXIT;

EXPAND(VALUE_VO):

        /*
        LEFT is a REF,
	or optionally LEFT is a COMMA and the appropriate REF may be found
	by following the COMMA's RIGHT.

        If REF type is "array of ...", then return ADDR(REF())
        with type "ptr to ..." on the ADDR (but leave "array of ..." on REF);
        otherwise, just copy type info up from REF.

        VALUE of REF of an enum constant turns into an INTEGER of enum type.
        */

	CXX_VALUE_NODE_PTR = LEFT;		/* REF */

        call GET_VALUE_TYPE (WORK_TYPE_01);

	if WORK_TYPE_01.TOP_TYPE.CODE = byte (ARRAY_DT) then do;
		call STRIP_TOP_TYPE (WORK_TYPE_01, TRUE); /* the "[...]" */
		goto FINISH_ADDR;
	end;

	if IS_INTEGRAL_TYPE (rank (WORK_TYPE_01.TOP_TYPE.CODE)) &
	   (CXX_VALUE_NODE.LEFT_IS_NID) &
	   (CXX_VALUE_NODE.OP = REF_VO) then do;
		call SET_SYM_NODE_R (CXX_VALUE_NODE.LEFT_NID);
		if SYM_NODE.IS_ENUM_MEMBER then do;
			if ^SYM_NODE.DEFINED then do;
				/*
				/* Warning; this enumerator
				/* does not yet have a value.
				/**/
				call SEMANTIC_ERROR_I
				     (ERR_UNDEF_ENUM_VALUE,
				      QUALIFIED_SYMBOL_NAME
				      (CXX_VALUE_NODE.LEFT_NID));
			end;
			OFFSET = SYM_NODE.LOCATION;
			call COUNT_DOWN_VALUE (LEFT);  /* REF */
			CXX_VALUE_NODE_PTR = V;
			call SET_VALUE_TYPE (WORK_TYPE_01);
			CXX_VALUE_NODE.OP = INTEGER_VO;
			CXX_VALUE_NODE.OFFSET = OFFSET;
			CXX_VALUE_NODE.LEFT = NULL_CXX_VID;
			goto REEXPAND;
		end;
	end;

	CXX_VALUE_NODE_PTR = V;
        call SET_VALUE_TYPE (WORK_TYPE_01);
        CXX_VALUE_NODE.UNARY = TRUE;
        goto EXIT;

EXPAND(UNARY_AND_VO):
EXPAND(IMPLICIT_ADDR_VO):
EXPAND(ADDR_VO):

	CXX_VALUE_NODE_PTR = LEFT;
	call BYPASS_COMMA ();
	if CXX_VALUE_NODE.OP = MEMBER_REF_VO then do;
		/*
		/* Operand is a member reference like A::x;
		/* result is a member pointer.  This is done first
		/* thing; otherwise UNARY_CHECKS might dereference
		/* this operand using 'this->'.
		/**/
		call COUNT_UP_VALUE (LEFT);
		call COUNT_DOWN_VALUE (V);
		call DETACH_COMMA (LEFT, KV1, KV2);
		V = COPY_VALUE (LEFT);
		V->CXX_VALUE_NODE.OP = MEMBER_PTR_VO;
		V->CXX_VALUE_NODE.RIGHT = NULL_CXX_VID;
		V->CXX_VALUE_NODE.OFFSET = 1; /* don't suppress virtualness */
		call SET_SYM_NODE_R (V->CXX_VALUE_NODE.LEFT_NID);
		if SYM_NODE.SIZE_UNITS = byte (BITS) then
			call SEMANTIC_ERROR (ERR_UNARY_ADDR_FIELD);
		call GET_VALUE_TYPE (WORK_TYPE_01);
		call DETERMINE_SIZE (WORK_TYPE_01);
		call SET_VALUE_TYPE (WORK_TYPE_01);
		call REATTACH_COMMA (V, KV1, KV2);
		goto EXIT;
	end;

	if VOP = UNARY_AND_VO then do;
		/*
		/* LEFT is id of a VALUE(REF(...)),
		/* possibly with some COMMAs between VALUE and REF.
		/*
		/* Do checks for overloading of '&',
		/* the unary address-of operator.
		/**/
		call UNARY_CHECKS (V, LEFT, EXPAND_DONE);
		/*
		/* If overload was found, then we're done.
		/**/
		if EXPAND_DONE then
			goto EXIT;
		/*
		/* Otherwise, drop through, and process as an ADDR_VO.
		/**/
		VOP = ADDR_VO;
	end;

	V->CXX_VALUE_NODE.OP = ADDR_VO;

        /*
        /* LEFT is id of a VALUE(REF(...)),
	/* possibly with some COMMAs between VALUE and REF.
	/*
        /* Discard the VALUE and return ADDR(REF(...)).
        /* Type of result is "ptr to type of VALUE".
        /**/

	CXX_VALUE_NODE_PTR = LEFT;

        call GET_VALUE_TYPE (WORK_TYPE_01);

	/* If this is a reference type, strip the 'REFERENCE',
	/* so that it looks like a non-reference type.
	/* Then make it look like a pointer to the type, and return the
	/* value for the pointer.
	/**/
	if WORK_TYPE_01.TOP_TYPE.CODE = byte (REFERENCE_DT) then do;
		/*
		/* Here, V's CXX_VALUE_NODE.LEFT is still LEFT.
		/* Get rid of the ADDR.
		/**/
		call COUNT_UP_VALUE (LEFT);
		call COUNT_DOWN_VALUE (V);

		V = COPY_VALUE (LEFT);
		call STRIP_TOP_TYPE (WORK_TYPE_01, FALSE);
		call ADD_POINTER_LEVEL (WORK_TYPE_01);
		call SET_VALUE_TYPE (WORK_TYPE_01);
		goto EXIT;
	end;

        /*
        /* The following allows expressions like: 
        /*      static struct mb mbr , mb1 , mb2 ;
        /*          .
        /*          .  (here addr is synthesized from EXPAND(COLON_VO);
        /*          .
        /*      mbr = 1 ? mb2 : ( sideeffect(), mb1) ;
        /*
        /*  or simply:
        /*      {   int a, b,c ; int *p;  p = &(a,b,c);  }
        /*
        /* Note: The result of the COMMA is always on the Right; 
        /*       Apply the ADDR to the result of the COMMA rather than itself.
        /**/

	if CXX_VALUE_NODE.FUNCTION_DESIGNATOR then do;
		/*
		/* Here, V's CXX_VALUE_NODE.LEFT is still LEFT.
		/**/
		call COUNT_UP_VALUE (LEFT);	/* (make a copy in case     */
		LEFT = COPY_VALUE (LEFT);	/*  there's another use)    */
		call COUNT_DOWN_VALUE (V);	/* discard addr		    */
		V = LEFT;
		CXX_VALUE_NODE_PTR = V;
		V->CXX_VALUE_NODE.FUNCTION_DESIGNATOR = FALSE;
		goto EXIT;
	end;

	if CXX_VALUE_NODE.ARRAY_DESIGNATOR then do;
		/*
		/* Check for &array.  Because in most other contexts arrays
		/* get their address taken implicitly, they are represented
		/* after expansion via ADDR, not VALUE.
		/**/
		call DETACH_COMMA (LEFT, KV1, KV2);
		if CXX_VALUE_NODE.OP = ADDR_VO then do;
			CXX_VALUE_NODE_PTR = CXX_VALUE_NODE.LEFT;
			if (CXX_VALUE_NODE.OP = REF_VO) &
			   (CXX_VALUE_NODE.TOP_TYPE.CODE = byte (ARRAY_DT))
			then do;
				/* &array meaningful per ANSI C */
				call GET_VALUE_TYPE (WORK_TYPE_01);
				LEFT = COPY_VALUE (LEFT);
				CXX_VALUE_NODE.OP = VALUE_VO;
				call SET_VALUE_TYPE (WORK_TYPE_01);
				call REATTACH_COMMA (LEFT, KV1, KV2);
				goto DISCARD_ADDR_VALUE;
			end;
		end;
		/* This is an array designator we can't handle. */
		call COMPILER_ERROR (ERR_ASSERT_FAIL);
	end;

	if (VOP ^= IMPLICIT_ADDR_VO) &
	   WORK_TYPE_01.NOT_AN_LVALUE &
	   (WORK_TYPE_01.TYPE_CODE ^= byte (FUNCTION_DT)) then do;
		/*
		/* Warning; an lvalue is required here.
		/* PKT changed this so that a static member function
		/* is not passed along here, because overloading made that
		/* code incorrect, and it wasn't clearly necessary.
		/**/
              call SEMANTIC_ERROR (ERR_NOT_AN_LVALUE);
	end;            
        if CXX_VALUE_NODE.OP = COMMA_VO then do;
		KV = CXX_VALUE_NODE.RIGHT;  /* Right of COMMA (result) */

		if CXX_VALUE_NODE.COUNT = 1 then do;
			/* Make ADDR1(COMMA(..., lvalue). */

			/* Eliminate the original ADDR value-node */
			V->CXX_VALUE_NODE.LEFT = NULL_CXX_VID;
			call COUNT_DOWN_VALUE (V);

			/* <Implicit>Addr-->(right)*/
			V = GET_VALUE_AND_EXPAND_L (VOP, KV);

			/* Hook in the ADDR(lvalue), with the comma */
			RIGHT = CXX_VALUE_NODE.LEFT;	/* the lvalue */
			CXX_VALUE_NODE.LEFT = LEFT;	/* the COMMA */
			CXX_VALUE_NODE_PTR = RIGHT;
			call GET_VALUE_TYPE (WORK_TYPE_01);
			CXX_VALUE_NODE_PTR = LEFT;	/* the COMMA */
			CXX_VALUE_NODE.RIGHT = RIGHT;
			call SET_VALUE_TYPE (WORK_TYPE_01);
			CXX_VALUE_NODE_PTR = V;
			goto EXIT;
		end;
		else do;
			/*
			/* This should be easier, because we can let the
			/* COMMA's other use take care of its side effects.
			/**/
			call COUNT_UP_VALUE (KV);	/* the lvalue */
			call COUNT_DOWN_VALUE (LEFT);	/* the COMMA */
			LEFT = KV;
			goto REEXPAND;
		end;
        end;

        if CXX_VALUE_NODE.OP = LEFT_VALUE_VO then do;
		/*
		/* Expand ADDR_VO on LEFT of LEFT_VALUE,
		/* then re-apply LEFT_VALUE.
		/**/
		KV = LEFT->CXX_VALUE_NODE.LEFT;
		RIGHT = LEFT->CXX_VALUE_NODE.RIGHT;
		call COUNT_UP_VALUE (KV);
		call COUNT_UP_VALUE (RIGHT);
		/* Here, V's CXX_VALUE_NODE.LEFT is still LEFT */
		call COUNT_DOWN_VALUE (V);
		/* KV and RIGHT are the ex-operands of the LEFT_VALUE */
		LEFT = GET_VALUE_AND_EXPAND_L (VOP, KV);
		V = VALUE_BEFORE_EFFECT (LEFT, RIGHT);
		goto EXIT;
        end;

	if (CXX_VALUE_NODE.OP = DOT_STAR_VO) |
	   (CXX_VALUE_NODE.OP = CAST_TO_BASE_VO) then do;
		if CXX_VALUE_NODE.TYPE_CODE ^= byte (FUNCTION_DT) then do;
			LEFT = TRANSMUTE_WITH_TEMP
			       (LEFT, VICTIM, TRUE, AUTO_ST, VOP);
			if (VICTIM ^= NULL_CXX_VID) &
			   ^WORK_TYPE_01.NOT_AN_LVALUE then
				call COMPILER_ERROR (ERR_ASSERT_FAIL);
			LEFT = EFFECT_BEFORE_VALUE (VICTIM, LEFT);
			CXX_VALUE_NODE_PTR = V;
			CXX_VALUE_NODE.LEFT = LEFT;
			goto REEXPAND;
		end;
		else do;
			/*
			/*  &(obj.*fmp)  or  &obj.f 
			/* Once we tried to support this for static
			/* member functions.
			/* PKT changed this to an error because
			/* (1) TauMetric says it is.
			/* (2) The ARM says it is.
			/* (3) Cfront's support seems to be only what
			/*     falls out from the obsolete non-static case.
			/* (4) It's not easy to handle the overloaded case.
			/**/
			call SEMANTIC_ERROR (ERR_ILLEGAL_MEMBER_FUN);
			call COUNT_DOWN_VALUE (LEFT);
			call COUNT_DOWN_VALUE (RIGHT);
			CXX_VALUE_NODE_PTR = V;
			call SET_VALUE_SIMPLE_TYPE (INT_BT);
			goto RETURN_ZERO;
		end;
	end;
        
        if CXX_VALUE_NODE.OP ^= VALUE_VO then do;
		/*
		/* &function or &constant
		/* For the case of taking the address of a constant
		/* when a REF type is being initialized, we exit
		/* if the value is NOT a VALUE_VO, and it's
		/* an implicit addr operation.
		/**/
		if VOP = IMPLICIT_ADDR_VO then
			goto FINISH_ADDR;
		/*
		/* Error; Argument of unary & is
		/* not an lvalue as required.
		/**/
		call SEMANTIC_ERROR (ERR_UNARY_ADDR_LVALUE);
		goto FINISH_ADDR;
        end;

	/* LEFT has VALUE_VO. */

        /* Check & applied to Bits, Labels, and Functions (special case).   */

        if CXX_VALUE_NODE.SIZE_UNITS = byte (BITS) then do;
		/*
		/* Error; unary & cannot be applied to a field name.
		/**/
		call SEMANTIC_ERROR (ERR_UNARY_ADDR_FIELD);
		goto FINISH_ADDR;
        end;

        if WORK_TYPE_01.TOP_TYPE.CODE = byte (LABEL_BT) then do;
		/*
		/* Error; unary & cannot be applied to a label name.
		/* But try it anyway!
		/**/
		call SEMANTIC_ERROR (ERR_UNARY_ADDR_LABEL);
        end;

DISCARD_ADDR_VALUE:
        KV = CXX_VALUE_NODE.LEFT;	/* The REF or COMMA */
        call COUNT_UP_VALUE (KV);	/* Up its count */
        call COUNT_DOWN_VALUE (LEFT);	/* Discard the VALUE */

        LEFT = KV;			/* The REF or COMMA */

        /* More checks ... */

	CXX_VALUE_NODE_PTR = LEFT;	/* The REF or COMMA */
	call BYPASS_COMMA ();
	if CXX_VALUE_NODE.OP ^= REF_VO then
		call COMPILER_ERROR (ERR_ASSERT_FAIL);
	if (CXX_VALUE_NODE.THIRD ^= NULL_CXX_VID) &
	   (CXX_VALUE_NODE.RIGHT = NULL_CXX_VID) &
	   (CXX_VALUE_NODE.OFFSET = 0) &
	   ^AM_DEBUGGER then do;
		/*
		/* a plain ref-with-locator:
		/* Eliminate the the REF_VO, because THIRD is the address.
		/* Recycle V.
		/* But CodeWatch prefers having the extra value nodes around.
		/**/
		CXX_VALUE_NODE_PTR = V;
		CXX_VALUE_NODE.LEFT = NULL_CXX_VID;
		call COUNT_DOWN_VALUE (V);
		call DETACH_COMMA (LEFT, KV1, KV2);
		KV = CXX_VALUE_NODE.THIRD;
		call COUNT_UP_VALUE (KV);
		call COUNT_DOWN_VALUE (LEFT);
		call ADD_POINTER_LEVEL (WORK_TYPE_01);
		V = CAST_TO_TYPE (KV, WORK_TYPE_01);
		call REATTACH_COMMA (V, KV1, KV2);
		goto EXIT;
	end;
        if  CXX_VALUE_NODE.LEFT_IS_NID &
	   (CXX_VALUE_NODE.LEFT ^= NULL_NID) then do;
		call SET_SYM_NODE (CXX_VALUE_NODE.LEFT_NID);
		if (SYM_NODE.NAME = MAIN_NAME) & ^SYM_NODE.IS_MEMBER then do;
			if ^AM_DEBUGGER & SW_C_PLUS_PLUS then
				call SEMANTIC_ERROR (ERR_ADDR_OF_MAIN);
		end;
		if ^AM_DEBUGGER then do;
			SYM_NODE.ALIAS = CXX_OPTIMIZER_NEEDS_ALIAS_BIT;
			if XREF then 
				call ADDXRF ((CURRENT_NODE_ID), TRUE);
		end;
		if SYM_NODE.REGISTER_AT &
		   (VOP ^= IMPLICIT_ADDR_VO) &
		   SW_STRICT_REGISTER then  do;
			/*
			/* Error; unary & cannot be applied
			/* to a register class variable.
			/**/
			call SEMANTIC_ERROR (ERR_UNARY_ADDR_REG);
			SYM_NODE.REGISTER_AT = FALSE;
		end;
        end;
	else if CXX_VALUE_NODE.LEFT ^= NULL_CXX_VID then do;
		if CXX_VALUE_NODE.LEFT->CXX_VALUE_NODE.OP ^=
		   DECLARE_TEMP_VO then
			call COMPILER_ERROR (ERR_ASSERT_FAIL);
		CXX_VALUE_NODE.LEFT->CXX_VALUE_NODE.NOT_AN_LVALUE = FALSE;
		/* will be used to set alias on the temp symbol */
	end;

FINISH_ADDR:
	CXX_VALUE_NODE_PTR	= V;
	V->CXX_VALUE_NODE.OP	= ADDR_VO;
	V->CXX_VALUE_NODE.LEFT	= LEFT;
	V->CXX_VALUE_NODE.UNARY	= TRUE;

	call ADD_POINTER_LEVEL (WORK_TYPE_01);
	call SET_VALUE_TYPE (WORK_TYPE_01);
	goto EXIT;

EXPAND(SREF_VO):

        /*
        /* LEFT is REF.
        /* RIGHT is Arg List containing subcripts as "seen left to right".
        /**/

	CXX_VALUE_NODE_PTR = LEFT;	/* REF */

        /*                                                                  
        /* Yes, Virginia, "array[i]" is equivalent to "i[array]" since both 
        /* are equivalent to "* (array + i)". Oh how I love C !!             
        /* Check for this case and permute.                               
        /**/

        if ^IS_DERIVED_TYPE (rank (CXX_VALUE_NODE.TOP_TYPE.CODE)) then do;
	    /* Not array or ptr, permute     */
            KV = LEFT;
	    CXX_VALUE_NODE_PTR = RIGHT;		/* Start of Arg List */
            if CXX_VALUE_NODE.RIGHT ^= NULL_CXX_VID then
                call SEMANTIC_ERROR (ERR_BAD_DEREFERNCE);
            KV1 = CXX_VALUE_NODE.LEFT;		/* Arg expression */
            LEFT = KV1;				/* Swap */
            CXX_VALUE_NODE.LEFT = KV;
	    CXX_VALUE_NODE_PTR = V;		/* SREF */
            CXX_VALUE_NODE.LEFT = LEFT;		/* Set new LEFT */
	    CXX_VALUE_NODE_PTR = LEFT;		/* and make it current */
        end;

        call COUNT_UP_VALUE (LEFT);   /* Original SVOP tree downed later    */

        /* 
        /* Get the type info on the REF. Make a Locator if pointer.     
        /**/
        call GET_VALUE_TYPE (WORK_TYPE_01);	/* Get type info on REF     */

                                        /* Must be "ptr to"  or "array of"  */
	TYPE = rank (WORK_TYPE_01.TOP_TYPE.CODE);
        if (TYPE ^= POINTER_DT) & (TYPE ^= ARRAY_DT) then do;
            call SEMANTIC_ERROR (ERR_BAD_DEREFERNCE);
            call COUNT_DOWN_VALUE (V);
            V = LEFT;
            goto EXIT;
        end;

        if WORK_TYPE_01.TOP_TYPE.CODE = byte (POINTER_DT) then do;
		/* "Ptr to ... "; Make Ref Locator. */
		LEFT = REF_WITH_LOCATOR (LEFT, WORK_TYPE_01);

		/* Check for a constant offset on the locator; this is probably
		/* in ADDRESS_UNITS (bytes), hence convert to SIZE_UNITS since 
		/* subscript calcuations below are also in SIZE_UNITS.
		/*
		/* <This could be avoided (leaving OFFSET in bytes) by
		/*  multiplying the subscript expression below by the number 
		/*  of bytes in SIZE_UNITS, but if a struct is indexed, then
		/*  the multiplier is difficult to calculate. 
		/*  Thus, all subscripts are calc'ed 
		/*  in terms of SIZE_UNITS, and OFFSET_UNITS in the REF is set 
		/*  to indicate such. This makes life easier for us, and also 
		/*  for the BE to properly set the scaling factor for indexed 
		/*  addressing modes (assuming the target supports such 
		/*  instructions).>
		/**/
		if CXX_VALUE_NODE.OFFSET ^= 0 then  
			CXX_VALUE_NODE.OFFSET =         
				ROUNDU (CXX_VALUE_NODE.OFFSET, 
					rank (CXX_VALUE_NODE.OFFSET_UNITS),
					rank (CXX_VALUE_NODE.SIZE_UNITS));
        end;

        /*
        /* Loop, building subscript index expression. Note that the right-  
        /* most qualifier is stripped and, hence, DETERMINE_SIZE is called
        /* via STRIP_TOP_TYPE, which causes it to calculate the 
        /* size/size_units for the extent & span of the current dimension.
        /* In the case of "ptr to ...", the size of "ptr" is calculated 
        /* rather than the size of the base type. 
        /*
        /* Also see comment above after REF_WITH_LOCATOR.
        /**/

        KV = INTEGER_VALUE_ZERO (); /* Init index expr:Makes life easier*/

        do while (RIGHT ^= NULL_CXX_VID);	/* Right = ARG_VO */

		call STRIP_TOP_TYPE (WORK_TYPE_01, TRUE);

		CXX_VALUE_NODE_PTR = RIGHT;	/* current argument */
		RIGHT = CXX_VALUE_NODE.RIGHT;	/* next arg (index) */
		KV1 = CXX_VALUE_NODE.LEFT;	/* Subscript expression */
		call COUNT_UP_VALUE (KV1);	/* SREF downed later */

		/*
		/* Expand the subscript expression.
		/* KV = KV + (index * extent); <Extent includes span in bytes>
		/**/
		KV1 = MUL_AND_ADD (KV1, WORK_TYPE_01.SIZE);
		KV = GET_VALUE_AND_EXPAND_LR (ADD_VO, KV, KV1);

		/* Check if more indices than qualifiers */
		if (WORK_TYPE_01.TOP_TYPE.CODE ^= byte (ARRAY_DT)) &
		   (RIGHT ^= NULL_CXX_VID) then
			/* Too many !!  */
			call SEMANTIC_ERROR (ERR_BAD_DEREFERNCE);
        end;

	CXX_VALUE_NODE_PTR = LEFT;		/* REF */
        call SET_VALUE_TYPE (WORK_TYPE_01);	/* Set remaining qualifiers */

        /*
        /* Decompose the variable and constant parts of the subscript expr  
        /*   for the REF_VO.                                               
        /**/

	CXX_VALUE_NODE_PTR = KV;  /* The subscript expression */

	/* Check variable or constant expression */

        call EVALUATE_INTEGER (KV, OFFSET, VOFF);

        if ^VOFF then do;
		/*
		/* If not variable, simple constant.
		/* OFFSET = const, set variable part = 0.
		/**/
		KV1 = NULL_CXX_VID;
		call COUNT_DOWN_VALUE (KV);
	end;
        else do;
		KV1 = CXX_VALUE_NODE.LEFT;	/* LEFT will have OP */
		KV2 = CXX_VALUE_NODE.RIGHT;	/* RIGHT possibly constant */

		if CXX_VALUE_NODE.OP = ADD_VO then do;
			/* Page right */
			CXX_VALUE_NODE_PTR = KV2;
			/* check if constant */
			call EVALUATE_INTEGER (KV2, OFFSET, VOFF);
		end;
		else	VOFF = TRUE;

		if VOFF then do;
			/* Some complex variable expression */
			KV1 = KV;               /* variable part */
			OFFSET = 0;             /* No constant part */
		end;
		else do;
			/* Save variable part (left). */
			call COUNT_UP_VALUE (KV1);
			/* Count down Op & right const part */
			call COUNT_DOWN_VALUE (KV);
		end;
        end;

        /* Now setup the REF with all appropriate parts:
        /*
        /*  RIGHT  will be variable offset value id (or NULL_CXX_VID).
        /*  THIRD  will be a ptr value id for locator (or NULL_CXX_VID).
        /*  OFFSET will be actual constant offset value (or 0).
        /*  OFFSET_UNITS is SIZE_UNITS (see comments above).
        /**/

	CXX_VALUE_NODE_PTR = LEFT;	/* REF */

	/* Variable part of REF const part, e.g.* (p+3)[4] */

        CXX_VALUE_NODe.RIGHT  = KV1;

	/* Set REF offset/units */

        CXX_VALUE_NODE.OFFSET = CXX_VALUE_NODE.OFFSET + OFFSET;
        CXX_VALUE_NODE.OFFSET_UNITS = CXX_VALUE_NODE.SIZE_UNITS;

	/* Count the original SVOP tree */

        call COUNT_DOWN_VALUE (V);

	/* Expand a VALUE/REF */

        V = GET_VALUE_AND_EXPAND_L (VALUE_VO, LEFT);

        goto EXIT;

EXPAND(ARROW_STAR_VO):

	/* Check for overloaded operator and fix up operands */

	call BINARY_CHECKS (V,
			    LEFT,
			    RIGHT,
			    THIRD,
			    EXPAND_DONE);
	if EXPAND_DONE then
		goto EXIT;

	LEFT = GET_VALUE_AND_EXPAND_L (IMPLICIT_STAR_VO, LEFT);
	CXX_VALUE_NODE_PTR = V;
	
EXPAND(DOT_STAR_VO):

	/* V is paged in.  Forget it, and use LEFT and RIGHT. */

	CXX_VALUE_NODE.LEFT = NULL_CXX_VID;
	CXX_VALUE_NODE.RIGHT = NULL_CXX_VID;
	if VOP = DOT_STAR_VO then do;
		LEFT = VALUE_OF (LEFT);
		RIGHT = VALUE_OF (RIGHT);
	end;

	/*
	/* Look for the member name (CURRENT_NAME) as a (possibly inherited)
	/* member of the class pointed to by the left operand of '.'
	/* (whose (pointer) type is in TYPE_INFO).  If ID is
	/* not NULL_NID, then it is the sym-node id representing an
	/* explicit class qualifier for the member.
	/**/

	CXX_VALUE_NODE_PTR = LEFT;
        call GET_VALUE_TYPE (WORK_TYPE_01);
	TYPE = rank (WORK_TYPE_01.TOP_TYPE.CODE);
        if ^IS_AGGREGATE_TAG_TYPE (TYPE) then do;
        	/*
		/* Error; value left of ".*" or "->*" does
		/* not refer to a class/struct/union.
		/**/
        	call SEMANTIC_ERROR (ERR_NOT_CLASS_STRUCT_UNION);
		call COUNT_DOWN_VALUE (LEFT);
		call COUNT_DOWN_VALUE (RIGHT);
		goto RETURN_ZERO;
        end;

	if IS_OVERLOADED_VALUE (RIGHT, KN) then
		call SEMANTIC_ERROR_I (ERR_DEREF_OVLD_FUN_MBR_PTR, 
				       QUALIFIED_SYMBOL_NAME (KN));

	KN = WORK_TYPE_01.TOP_TYPE.TAG_SYMBOL;

	CXX_VALUE_NODE_PTR = RIGHT;
	call GET_VALUE_TYPE (WORK_TYPE_02);
	
	if WORK_TYPE_02.TYPE_CODE ^= byte (MEMBER_POINTER_DT) then do;
		/*
		/* Error; right of .* or ->* is not member pointer.
		/**/
		call SEMANTIC_ERROR (ERR_NOT_MEMBER_PTR);
		call COUNT_DOWN_VALUE (LEFT);
		call COUNT_DOWN_VALUE (RIGHT);
		goto RETURN_ZERO;
	end;
	else if WORK_TYPE_02.TAG_SYMBOL ^= NULL_NID then do;
		call SET_SYM_NODE_R (WORK_TYPE_02.TAG_SYMBOL);
		if ^SYM_NODE.DEFINED then do;
			/*
			/* Error; this class must be defined before a
			/* reference to it, through a pointer to member,
			/* can be made.
			/*
			/* This situation can only arise when the cfront
			/* member-function-reference type is used.  E.g.:
			/*
			/*   struct A *ap;
			/*   typedef void A::T();
			/*   T *mp;       // Same as: void (A::*mp)();
			/*   (ap->*mp)(); // A must be defined by this point
			/**/
			call SEMANTIC_ERROR_I
			     (ERR_MEMPTR_CLASS_UNDEF_AT_USE,
			      QUALIFIED_SYMBOL_NAME (WORK_TYPE_02.TAG_SYMBOL));
		end;
	end;

	call BYPASS_COMMA ();
	if CXX_VALUE_NODE.OP = MEMBER_REF_VO then begin;

		declare TYPE_DATA	type (TYPE_DATA_T);

		/* 
		/* Like a function designator, implicitly convert
		/* from member-ref to function, to member-ptr to function.
		/* But if it's data, no such conversion.
		/**/
		call GET_TOP_LEVEL_TYPE_INFO (WORK_TYPE_02, 1, TYPE_DATA);
		if TYPE_DATA.CODE ^= byte (FUNCTION_DT) then do;
			/*
			/* Error; right of .* or ->* is not member pointer.
			/**/
			call SEMANTIC_ERROR (ERR_NOT_MEMBER_PTR);
			call COUNT_DOWN_VALUE (LEFT);
			call COUNT_DOWN_VALUE (RIGHT);
			goto RETURN_ZERO;
		end;
		call DETACH_COMMA (RIGHT, KV1, KV2);
		RIGHT = COPY_VALUE (RIGHT);
		CXX_VALUE_NODE.OP = MEMBER_PTR_VO;
		call REATTACH_COMMA (RIGHT, KV1, KV2);
	end;

	if ^IS_ANY_BASE_CLASS_OF
	    (WORK_TYPE_02.TOP_TYPE.TAG_SYMBOL, KN) then do;
		/*
		/* Error; specified class is not a base of the object's class.
		/**/
		call SEMANTIC_ERROR_II
		     (ERR_NOT_BASE_CLASS_OF,
		      SYMBOL_NAME (WORK_TYPE_02.TOP_TYPE.TAG_SYMBOL),
		      SYMBOL_NAME (KN));
		call COUNT_DOWN_VALUE (LEFT);
		call COUNT_DOWN_VALUE (RIGHT);
		goto RETURN_ZERO;
	end;

	call COUNT_DOWN_VALUE (V);
	V = MEMBER_OF_OBJECT (LEFT, RIGHT);
	goto EXIT;

EXPAND(DOT_VO): begin;

	declare
		INTERMEDIATE_CLASS		type (NID_T),
		START_CLASS			type (NID_T),
		MEMBER_SYMBOL			type (NID_T);

	/*
        /* LEFT should be VALUE (REF (...)) --> class/struct/union,
	/* possibly with some COMMAs interspersed.
	/*
        /* RIGHT is token-node id representing a member of the class
	/* referred to by LEFT.
        /*
	/* If CXX_VALUE_NODE.ID is not NULL_NID, then it is the sym-node id
	/* representing an explicit class qualifier of the
	/* member name referred to by RIGHT.  It shall already have been
	/* checked that CXX_VALUE_NODE.ID is a subclass of the class of LEFT.
        /*
        /* Special case added: where LEFT is a CALL_FUNCTION --> struct/union.
        /* This case has been modified to properly handle f ().m1.m2.m3 ... .
        /*
        /*    [ p->m is transformed to this.]
        /**/

	INTERMEDIATE_CLASS = CXX_VALUE_NODE.ID_NID;
	CXX_VALUE_NODE.ID = NULL_OID;

	CXX_VALUE_NODE_PTR = LEFT;
        call GET_VALUE_TYPE (WORK_TYPE_01);

	/*
	/* Look for the member name (RIGHT) as a (possibly inherited)
	/* member of the class pointed to by the expression LEFT
	/* (whose (pointer) type is in WORK_TYPE_01).  If ID is
	/* not NULL_NID, then it is the sym-node id representing an
	/* explicit class qualifier for the member.
	/**/

	if INTERMEDIATE_CLASS ^= NULL_NID then
		START_CLASS = INTERMEDIATE_CLASS;
	else	START_CLASS = WORK_TYPE_01.TOP_TYPE.TAG_SYMBOL;

	if V->CXX_VALUE_NODE.THIRD_IS_NID then
		MEMBER_SYMBOL = SEARCH_CLASS (START_CLASS, THIRD_NID, 
					      CONVERSION_FUNCTION_SK);
	else	MEMBER_SYMBOL = SEARCH_CLASS (START_CLASS, RIGHT_NID, ANY_SK);

	if MEMBER_SYMBOL = NULL_NID then do;
		/*
		/* Error; can't find the (inherited) member.
		/**/
		if INTERMEDIATE_CLASS ^= NULL_NID then
			I = ERR_NOT_A_MEMBER_QUAL_NAME;
		else	I = ERR_NOT_A_MEMBER_NAME;
		if V->CXX_VALUE_NODE.THIRD_IS_NID then do;
			call SEMANTIC_ERROR_II
			     (I,
			      TOKEN_MEMBER_NAME (CONVERSION_NAME, THIRD_NID),
			      QUALIFIED_SYMBOL_NAME (START_CLASS));
		end;
		else do;
			call SEMANTIC_ERROR_II
			     (I,
			      TOKEN_MEMBER_NAME (RIGHT_NID, START_CLASS),
			      QUALIFIED_SYMBOL_NAME (START_CLASS));
		end;
	        call COUNT_DOWN_VALUE (LEFT);
	        goto RETURN_ZERO;
	end;
	else if SYM_NODE.IS_TYPE then do;
		/*
		/* Error; object.type!
		/**/
		call SEMANTIC_ERROR_I (ERR_BAD_TYPE_REF,
				       QUALIFIED_SYMBOL_NAME (MEMBER_SYMBOL));
	        call COUNT_DOWN_VALUE (LEFT);
	        goto RETURN_ZERO;
	end;
	else if SYM_NODE.IS_ENUM_MEMBER then do;
		/*
		/* Handle object.enumerator.
		/**/
		call GET_SYM_NODE_R (SYM_NODE.TOP_TYPE.TAG_SYMBOL, P);
		if P->SYM_NODE.IS_AGGREGATE_MEMBER then do;
			if ^IS_ACCESSIBLE_STATIC
			    (SYM_NODE.TOP_TYPE.TAG_SYMBOL) then do;
				if ^AM_DEBUGGER then do;
					call SEMANTIC_ERROR_I
					     (ERR_PRIV_BASE_MEMBER_REF,
					      FULL_QUALIFIED_SYMBOL_NAME
					      (MEMBER_SYMBOL));
				end;
			end;
		end;
		call RELEASE_SYM_NODE (SYM_NODE.TOP_TYPE.TAG_SYMBOL);
		call COUNT_DOWN_VALUE (LEFT);
		V = GET_VALUE_REF_AND_EXPAND (MEMBER_SYMBOL);
		goto EXIT;
	end;

	/* Eliminate the node we started with */

	call COUNT_UP_VALUE (LEFT);
	call COUNT_DOWN_VALUE (V);
	
	RIGHT = GET_MEMBER_POINTER_VALUE (MEMBER_SYMBOL, INTERMEDIATE_CLASS);
	V = MEMBER_OF_OBJECT (LEFT, RIGHT);
	goto EXIT;

end;	/* DOT_VO */

EXPAND(FUNCTIONAL_CAST_VO):
	/*
	/* RIGHT is a possibly empty argument list.
	/* LEFT has been set up by the parser based on a type node,
	/* and does not have a DERIVED_TYPE_SKIP or EXTRA_PTR_LEVEL.
	/**/

	/* Use RIGHT independently of V */

	CXX_VALUE_NODE.RIGHT = NULL_CXX_VID;

	/*  Get the type information from the left */

	CXX_VALUE_NODE_PTR = LEFT;
	call GET_VALUE_TYPE (WORK_TYPE_01);

	/* Get rid of V and LEFT, since we have the type information */

        call COUNT_DOWN_VALUE (V);

	/* If there is exactly 1 argument, this is a conversion */

	if RIGHT ^= NULL_CXX_VID then do;
		CXX_VALUE_NODE_PTR = RIGHT;
		if CXX_VALUE_NODE.RIGHT = NULL_CXX_VID then do;
			KV = CXX_VALUE_NODE.LEFT;
			call COUNT_UP_VALUE (KV);
			call COUNT_DOWN_VALUE (RIGHT);
			V = GENERAL_CONVERT_VALUE (KV, WORK_TYPE_01,
						   FUNCTIONAL_CAST_VO);
			CXX_VALUE_NODE.NOT_AN_LVALUE = TRUE;
			goto EXIT;
		end;
	end;

	V = GET_CONSTRUCTOR_VALUE (WORK_TYPE_01.TYPE, RIGHT, NULL_NID, VOP);
	CXX_VALUE_NODE.NOT_AN_LVALUE = TRUE;
	goto EXIT;

EXPAND(CAST_VO):;
	/*
	/* Classic cast.
	/**/

EXPAND(IMPLICIT_CAST_VO):
        /*
        /* Type of LEFT is target type.
        /* RIGHT is the value being cast.
        /**/

	if CXX_VALUE_NODE.TOP_TYPE.CODE ^= byte (NULL_BT) then
		/* already set up */
		goto EXIT;
   
	/* Get the type information from the LEFT */
	CXX_VALUE_NODE_PTR = LEFT;
	call GET_VALUE_TYPE (WORK_TYPE_01);

	/* Get rid of V and LEFT -- they've served their purpose */
	CXX_VALUE_NODE_PTR = V;
	CXX_VALUE_NODE.RIGHT = NULL_CXX_VID;
        call COUNT_DOWN_VALUE (V);	/* RIGHT not attached to V */

	TYPE = rank (WORK_TYPE_01.TOP_TYPE.CODE);
	TID = NULL_NID;			/* Class with constructor */
	if IS_AGGREGATE_TAG_TYPE (TYPE) then do;
		if ^SW_NO_CLASS_CAST then do;
			KN = WORK_TYPE_01.TOP_TYPE.TAG_SYMBOL;
			call SET_SYM_NODE_R (KN);
			if SYM_NODE.NEEDS_INIT then
				TID = SYM_NODE.TYPE;
		end;
		else if VOP = CAST_VO then
			call SEMANTIC_ERROR (ERR_CAST_STRUCT_UNION);
	end;
		
	V = GENERAL_CONVERT_VALUE (RIGHT, WORK_TYPE_01, VOP);

	if (VOP = CAST_VO) & ^(TID = NULL_NID & SW_X_CAST_LVALUE) then
		CXX_VALUE_NODE.NOT_AN_LVALUE = TRUE;

	goto EXIT;


EXPAND(TYPE_VO):

        /*
        No LEFT or RIGHT.
        The type information is already filled in.
        Just complete the size fields.
        */

        call GET_VALUE_TYPE (WORK_TYPE_01);
        call DETERMINE_SIZE (WORK_TYPE_01);
	CXX_VALUE_NODE_PTR = V;
        call SET_VALUE_TYPE (WORK_TYPE_01);
        CXX_VALUE_NODE.NULARY = TRUE;
        goto EXIT;


EXPAND(IMPLICIT_STAR_VO):
	CXX_VALUE_NODE.OP = STAR_VO;

EXPAND(STAR_VO):
        /*
        /* LEFT should be some ptr value (or redundant "**func").      
        /**/

	if VOP = STAR_VO then do;
		call UNARY_CHECKS (V, LEFT, EXPAND_DONE);
		if EXPAND_DONE then
			goto EXIT;
	end;

	CXX_VALUE_NODE_PTR = LEFT;

        /*
        /* Consider "* (long *)p" Is this an lvalue?
        /*      A cast expression does not yield an lvalue; but, if the 
        /*      unary * operator "points to an object, the result is an
        /*      lvalue designating the object". <Sect. 3.3.3.2>
        /* -------------------------------------------------------------
        /* This actually turns out to be rather convenient. The result
        /* of a conditional expression is not an lvalue. In the case
        /* of conditionals with structs, the structs are turned into
        /* pointer refs via ADDR_VO and then derefernced via STAR_VO. 
        /* For nested conditionals with structs, like 
        /*          "i ? s1 : (j ? s2 : s3) "   <sick, huh ??>
        /* would cause an error when expanding an & on the result of 
        /* the inner conditional.
        /* 
        /* The above allows us to squelch this potential problem without
        /* special code 1(would need to catch this in EXPAND(COLON_VO)
        /* otherwise.
        /**/

        call GET_VALUE_TYPE (WORK_TYPE_01);

	TYPE = rank (WORK_TYPE_01.TOP_TYPE.CODE);
	if   IS_OVERLOADED_VALUE (LEFT, KN)
	   & (TYPE = POINTER_DT | TYPE = MEMBER_POINTER_DT) then do;
		/*
		/* This could be an overloaded member function,
		/* for which one of the variants is static, and
		/* if not overloaded would turn out to be a pointer to
		/* function.  It may be buried in commas.
		/*
		/* It could be any overloaded function.
		/**/
		call SET_SYM_NODE_R (KN);
		if SYM_NODE.IS_AGGREGATE_MEMBER then do;
			/*
			/* OK if non-overloaded static; error if 
			/* non-overloaded non-static.
			/* To resolve overloading properly for this
			/* expression would require the trouble of putting
			/* something into the value node which will tell us
			/* that '*' has been applied, and to report an error
			/* later.
			/**/
			CXX_VALUE_NODE_PTR = LEFT;
			if CXX_VALUE_NODE.FUNCTION_DESIGNATOR then
				call SEMANTIC_ERROR_I
				     (ERR_DEREF_OVLD_FUN,
				      QUALIFIED_SYMBOL_NAME (KN));
			else	call SEMANTIC_ERROR_I
				     (ERR_DEREF_OVLD_FUN_PTR,
				      QUALIFIED_SYMBOL_NAME (KN));
			call COUNT_DOWN_VALUE (LEFT);
			goto RETURN_ZERO;
		end;
		/*
		/* Let it go by, don't even call it an error.
		/* Becomes a function designator.
		/**/
	end;

	else if WORK_TYPE_01.TOP_TYPE.CODE ^= byte (POINTER_DT) then do;
		/*
		/* Subscript or a unary "*" can only
		/* be applied to a pointer value.
		/**/
		call SEMANTIC_ERROR (ERR_BAD_DEREFERNCE);
		call COUNT_DOWN_VALUE (LEFT);
		goto RETURN_ZERO;
        end;

	CXX_VALUE_NODE_PTR = LEFT;

	if CXX_VALUE_NODE.FUNCTION_DESIGNATOR |
	   ((CXX_VALUE_NODE.TOP_TYPE.CODE = byte (ARRAY_DT)) &
	    (CXX_VALUE_NODE.OP ^= ADDR_VO)) then do;
		/*
		/* Discard the STAR; up the left of the STAR,
		/* discard the STAR, and set V to the original
		/* left of the the STAR.
		/**/
        	call COUNT_UP_VALUE (LEFT);
        	call COUNT_DOWN_VALUE (V);
        	V = LEFT;
        	goto EXIT;
	end;

	call STRIP_TOP_TYPE (WORK_TYPE_01, TRUE);  /* Removes "*" */

	/*
	/* If the operand of * points to a function, the result is a
	/* function designator. Thus, throw away the '*' and return the
	/* VALUE(REF()-->ptr-to-funct)-->ptr-to-funct.
	/**/

	if WORK_TYPE_01.TOP_TYPE.CODE = byte (FUNCTION_DT) then do;
		/*
		/* E.g. *pf ---> f.
		/* Make a copy in case there's another use.
		/* Discard STAR, but leave as *pf.
		/**/
		call COUNT_UP_VALUE (LEFT);
		LEFT = COPY_VALUE (LEFT);
		call COUNT_DOWN_VALUE (V);
		V = LEFT;
		CXX_VALUE_NODE_PTR = V;
		CXX_VALUE_NODE.FUNCTION_DESIGNATOR = TRUE;
		goto EXIT;
	end;

	LEFT = REF_WITH_LOCATOR (LEFT, WORK_TYPE_01);
	CXX_VALUE_NODE_PTR = V;
        CXX_VALUE_NODE.OP = VALUE_VO;
        CXX_VALUE_NODE.LEFT = LEFT;
	if WORK_TYPE_01.TYPE_CODE = byte (ARRAY_DT) then do;
		/* It's an array designator. */
		V = EXPAND_VALUE (V);
		/* CXX_VALUE_NODE.TOP_TYPE is pointer. */
		CXX_VALUE_NODE.ARRAY_DESIGNATOR = TRUE;
		goto EXIT;
	end;
        goto REEXPAND;

EXPAND(SIZEOF_VO):

	/*
	/* LEFT is either a TYPE value or an expression.
	/* Return the size of LEFT in same units as a CHAR.
	/**/

	LEFT = VALUE_OF (LEFT);			/* DGM, 108, 3.16.92 */
	CXX_VALUE_NODE_PTR = LEFT;
        call GET_VALUE_TYPE (WORK_TYPE_01);

	/* Handle reference to member */

	if CXX_VALUE_NODE.OP = MEMBER_REF_VO then do;
		LEFT = DEREFERENCE_MEMBER (LEFT, TRUE);
		call GET_VALUE_TYPE (WORK_TYPE_01);
	end;

	/*
	/* If it's sizeof a function, eliminate the fakery which
	/* by default converts it to a pointer to function.
	/**/

	if (WORK_TYPE_01.TOP_TYPE.CODE = byte (POINTER_DT)) |
	   (WORK_TYPE_01.TOP_TYPE.CODE = byte (MEMBER_POINTER_DT)) then do;
		if CXX_VALUE_NODE.FUNCTION_DESIGNATOR then
			call STRIP_TOP_TYPE (WORK_TYPE_01, TRUE);
		else if IS_OVERLOADED_VALUE (LEFT, KN) then
			call SEMANTIC_ERROR_I (ERR_SIZEOF_OVLD_FUN_PTR,
					       QUALIFIED_SYMBOL_NAME (KN));
	end;

	/* Handle sizeof arrays */

        if CXX_VALUE_NODE.ARRAY_DESIGNATOR then do;
		/*
		/* Here, we have a simple "sizeof (array_name)", so we will
		/* return the actual size of the array.  If it's not this
		/* simple, either the VOP won't be ADDR_VO or ARRAY_DESIGNATOR
		/* will be FALSE.  E.g. in "sizeof (0, array_name)", the array
		/* name get converted to a pointer (since it *not* the operand
		/* of a sizeof, but rather a comma); see ANSI-C, sec.3.2.2.1.
		/*
		/* Get the LEFT which is the REF whose size is
		/* set to the actual size of the array.
		/**/
		call BYPASS_COMMA ();
		if CXX_VALUE_NODE.OP ^= ADDR_VO then
			/*
			/* We're not set up to handle such a a fancy
			/* array designator -- cross our fingers
			/* and hope they don't exist.
			/**/
			call COMPILER_ERROR (ERR_ASSERT_FAIL);

		CXX_VALUE_NODE_PTR = CXX_VALUE_NODE.LEFT;
		if CXX_VALUE_NODE.TOP_TYPE.CODE = byte (ARRAY_DT) then
			call GET_VALUE_TYPE (WORK_TYPE_01);
        end;
        else if (WORK_TYPE_01.TOP_TYPE.CODE = byte (POINTER_DT)) &
		(CXX_VALUE_NODE.OP = ADDR_VO) &
		^CXX_VALUE_NODE.LEFT_IS_NOT_VID &
		(CXX_VALUE_NODE.LEFT ^= NULL_CXX_VID) then do;
		/*
		/* Here, look for an array-of-array reference; e.g.
		/* "sizeof (array_of_array_name [index]).  In this case,
		/* we would have ADDR (REF (dummy, 0, ADD (etc))); the
		/* top type of the ADDR is pointer and the REF has its
		/* size set correctly to the size of the sub-array.
		/**/
		CXX_VALUE_NODE_PTR = CXX_VALUE_NODE.LEFT; /* REF ? */
		if (CXX_VALUE_NODE.OP = REF_VO) &
		   ^CXX_VALUE_NODE.THIRD_IS_NOT_VID &
		   (CXX_VALUE_NODE.THIRD ^= NULL_CXX_VID) then do;
			call GET_VALUE_TYPE (WORK_TYPE_02);
			CXX_VALUE_NODE_PTR = CXX_VALUE_NODE.THIRD; /* ADD ? */
			if CXX_VALUE_NODE.OP = ADD_VO then do;
				if WORK_TYPE_02.TOP_TYPE.CODE =
				   byte (ARRAY_DT) then
	               			WORK_TYPE_01 = WORK_TYPE_02;
			end;
		end;
        end;

        call COUNT_DOWN_VALUE (LEFT);	/* discard the LEFT value */
	CXX_VALUE_NODE_PTR = V;
        call SIMPLE_TYPE_SIZE (CHAR_BT, OFFSET, OFFSET_UNITS, BDRY);

	OFFSET_UNITS = 0;		/* paranoia strikes PKT */

        TYPE = 0;
        if WORK_TYPE_01.SIZE_UNITS = 0 then do; 
		if WORK_TYPE_01.TOP_TYPE.CODE = byte (FUNCTION_DT) then do; 
			/*
			/* Error; operand of "sizeof"
			/* cannot designate a function.
			/**/ 
			call SEMANTIC_ERROR (ERR_SIZEOF_FUNCT);
		end;
		else do; 
			/*
			/* Error; operand of "sizeof" is of unknown size.
			/**/
			call SEMANTIC_ERROR (ERR_SIZEOF_UNKNOWN);
		end;

		WORK_TYPE_01.SIZE_UNITS = BDRY;
		OFFSET = 0;
		goto FINISH_INTEGER;
        end;

        if WORK_TYPE_01.SIZE_UNITS = BITS then do; 
		/*
		/* Error; operand of "sizeof" cannot designate a bit-field.
		/**/
		call SEMANTIC_ERROR (ERR_SIZEOF_BIT_FIELD);
		goto FINISH_INTEGER;
        end;

        if WORK_TYPE_01.SIZE_UNITS ^= BDRY then
		WORK_TYPE_01.SIZE = ROUNDU (WORK_TYPE_01.SIZE, 
					    WORK_TYPE_01.SIZE_UNITS, BDRY);

        OFFSET = WORK_TYPE_01.SIZE;
        if OFFSET = 0 then do;
		 /*
		 /* Error; sizeof returns a zero value.
		 /**/
		 call SEMANTIC_ERROR (ERR_SIZEOF_RET_ZERO);
	end;

        goto FINISH_INTEGER;

EXPAND(EXPLICIT_COMMA_VO):
EXPAND(COMMA_VO):
        /*
        /* It's possible that a constant BRANCH_TRUE/FALSE was eliminated
        /* from the RIGHT. If so, eliminate the COMMA vop and replace it 
        /* with a NOP since the result of the COMMA's LEFT was type of RIGHT.
        /*
        /*  example: while (i++, 1) {...}
        /**/

	if (RIGHT = NULL_CXX_VID) | (LEFT = NULL_CXX_VID) then
		call COMPILER_ERROR (ERR_ASSERT_FAIL);

	if VOP = EXPLICIT_COMMA_VO then do;
		call CHECK_BINARY_OVERLOAD (V, EXPAND_DONE);
		if EXPAND_DONE then
			goto EXIT;
	end;

	CXX_VALUE_NODE_PTR = V;
	CXX_VALUE_NODE.LEFT = NULL_CXX_VID;
	CXX_VALUE_NODE.RIGHT = NULL_CXX_VID;
	call COUNT_DOWN_VALUE (V);

	CXX_VALUE_NODE_PTR = RIGHT;
        if (CXX_VALUE_NODE.TOP_TYPE.CODE = byte (VOID_BT)) &
	   (CXX_VALUE_NODE.OP = UNINITIALIZED_VO) then do;
		/*
		/* Oops, its not there !
		/* Already done above (DGM, 074 (ANSI-C sampler 053)) ...
		/**/
		CXX_VALUE_NODE.LEFT = NULL_CXX_VID; /* Unhook the LEFT */
		/* call COUNT_DOWN_VALUE (V);    /* Count down the COMMA */
		V = CONVERT_TO_VOID (LEFT);	 /* Replace COMMA with NOP */
		goto EXIT;			 /* Return V */
        end;

	LEFT = GET_VALUE_AND_EXPAND_L (NOP_VO, LEFT);

	CXX_VALUE_NODE_PTR = RIGHT;

        if (CXX_VALUE_NODE.SIZE_UNITS = byte (BITS)) &
	    CXX_VALUE_NODE.NOT_AN_LVALUE then
		RIGHT = GET_VALUE_AND_EXPAND_L (FIELD_VO, RIGHT);

	V = EFFECT_BEFORE_VALUE (LEFT, RIGHT);
	if SW_STRICT_LVALUE then do;
		V = COPY_VALUE (V);
		CXX_VALUE_NODE.NOT_AN_LVALUE = TRUE;
	end;
	if CXX_VALUE_NODE.ARRAY_DESIGNATOR |
	   CXX_VALUE_NODE.FUNCTION_DESIGNATOR then do;
		V = COPY_VALUE (V);
		CXX_VALUE_NODE.ARRAY_DESIGNATOR	= FALSE;
		CXX_VALUE_NODE.FUNCTION_DESIGNATOR = FALSE;
	end;

        /*
        /* goto FOLD_AND_EXIT;
	/*
        /* Important: DO NOT "fold and exit". Comma operators are not
        /* allowed in initial expressions for static data and auto
        /* aggregates. Folding (1, 2) "reduces away" needed info for
        /* static initialization. This folding may produce simpler expr
        /* trees, but there are no other inherent advantages since 
        /* "EMITT" is equipped to toss away constant expressions
        /* which are essentially nop's.
        /**/
        goto EXIT;

EXPAND(LEFT_VALUE_VO):

	/* Create an expression tree which evaluates the LEFT prior to
	/* evaluating the expression RIGHT for its side-effects.  The result
	/* of LEFT is preserved and is the result of the new expression.
	/* This is similar to COMMA_VO except that
	/* the value returned is from the first-executed expression, not the
	/* second.
	/* 
	/* The result type is the same as that of LEFT.
	/**/

	if (LEFT = NULL_CXX_VID) | (RIGHT = NULL_CXX_VID) then
		call COMPILER_ERROR (ERR_ASSERT_FAIL);

	CXX_VALUE_NODE.LEFT = NULL_CXX_VID;
	CXX_VALUE_NODE.RIGHT = NULL_CXX_VID;
	call COUNT_DOWN_VALUE (V);

	RIGHT = GET_VALUE_AND_EXPAND_L (NOP_VO, RIGHT);
	V = VALUE_BEFORE_EFFECT (LEFT, RIGHT);
	goto EXIT;

EXPAND(DBG_SUBSCRIPT_VO):
	/*
	/* Preserve the LEFT and RIGHT operands unaltered,
	/* but set the result type just as for SSADD_VO.
	/**/
	begin;
	declare
		(FD, AD)	type (BOOL_T);

		call COUNT_UP_VALUE (LEFT);
		call COUNT_UP_VALUE (RIGHT);
		KV = GET_VALUE_AND_EXPAND_LR (SSADD_VO, LEFT, RIGHT);
		call GET_VALUE_TYPE (WORK_TYPE_01);
		FD = CXX_VALUE_NODE.FUNCTION_DESIGNATOR;
		AD = CXX_VALUE_NODE.ARRAY_DESIGNATOR;
		call COUNT_DOWN_VALUE (KV);
		CXX_VALUE_NODE_PTR = V;
		call SET_VALUE_TYPE (WORK_TYPE_01);
		CXX_VALUE_NODE.FUNCTION_DESIGNATOR = FD;
		CXX_VALUE_NODE.ARRAY_DESIGNATOR = AD;
	end;
	goto EXIT;

EXPAND(SSADD_VO):
	/*
	/* LEFT is the value of an operand to the left of a square brace.
	/* RIGHT is the expression in the set of braces '[' ']'.
	/* This action routine is used to check for an overloaded '[]'
	/* and call the appropriate overloaded function.
	/**/

	call BINARY_CHECKS (V,
			    LEFT,
			    RIGHT,
			    THIRD,
			    EXPAND_DONE);

	if EXPAND_DONE then do;
		/*
		/* An overloaded function was found.  V is now the id of
		/* an expression tree that calls the overloaded function.
		/**/
		goto EXIT;
	end;

	CXX_VALUE_NODE_PTR = LEFT;
        call GET_VALUE_TYPE (WORK_TYPE_01);
	CXX_VALUE_NODE_PTR = RIGHT;

	if (WORK_TYPE_01.TOP_TYPE.CODE ^= byte (POINTER_DT)) &
	   (CXX_VALUE_NODE.TOP_TYPE.CODE ^= byte (POINTER_DT)) then do;
		/*
		/* Neither of the operands of this [] is a pointer.
		/**/
		call SEMANTIC_ERROR (ERR_SUBSCRIPT_OPERAND);
		call COUNT_DOWN_VALUE (LEFT);
		call COUNT_DOWN_VALUE (RIGHT);
		goto RETURN_ZERO;
	end;

	/* Check operands and ensure pointer is on left */

	call NORMALIZE_BEFORE_INDEX (ADD_VO);

	/* Change to an ADD */

	CXX_VALUE_NODE_PTR = V;
	CXX_VALUE_NODE.OP = ADD_VO;
	call INDEX_PTR ();
	V = FOLD_VALUE (V);
	V = GET_VALUE_AND_EXPAND_L (IMPLICIT_STAR_VO, V);
	goto EXIT;

EXPAND(ADD_VO):

	call BINARY_CHECKS (V,
			    LEFT,
			    RIGHT,
			    THIRD,
			    EXPAND_DONE);
	if EXPAND_DONE then
		goto EXIT;

	CXX_VALUE_NODE_PTR = LEFT;
        call GET_VALUE_TYPE (WORK_TYPE_01);

	CXX_VALUE_NODE_PTR = RIGHT;
        call GET_VALUE_TYPE (WORK_TYPE_02);

	if (WORK_TYPE_01.TOP_TYPE.CODE = byte (POINTER_DT)) |
	   (WORK_TYPE_02.TOP_TYPE.CODE = byte (POINTER_DT)) then do;
                call NORMALIZE_BEFORE_INDEX (ADD_VO);
                call INDEX_PTR ();
		goto FOLD_AND_EXIT;
	end;

	/*
	/* Here, neither LEFT nor RIGHT are pointers.
	/* Make sure they are arithmetic type.
	/**/

	if ^IS_ARITHMETIC_TYPE (rank (WORK_TYPE_01.TOP_TYPE.CODE)) |
	   ^IS_ARITHMETIC_TYPE (rank (WORK_TYPE_02.TOP_TYPE.CODE)) then 
  		call SEMANTIC_ERROR (ERR_NONARITH_ADD);
        call CONVERT_COMMON ();
        goto REORDER_FOLD_AND_EXIT;

EXPAND(ADD_ASSIGN_VO):
EXPAND(SUB_ASSIGN_VO):
EXPAND(MUL_ASSIGN_VO):
EXPAND(DIV_ASSIGN_VO):
EXPAND(MOD_ASSIGN_VO):
EXPAND(LSHIFT_ASSIGN_VO):
EXPAND(RSHIFT_ASSIGN_VO):
EXPAND(AND_ASSIGN_VO):
EXPAND(OR_ASSIGN_VO):
EXPAND(XOR_ASSIGN_VO):

	call BINARY_CHECKS (V,
			    LEFT,
			    RIGHT,
			    THIRD,
			    EXPAND_DONE);
	if EXPAND_DONE then
		goto EXIT;

        call COUNT_UP_VALUE (LEFT);

	/* expand the binary operation */

        RIGHT = GET_VALUE_AND_EXPAND_LR (VOP - 1, LEFT, RIGHT);

	CXX_VALUE_NODE_PTR = V;
        CXX_VALUE_NODE.OP = ASSIGN_VO;
        CXX_VALUE_NODE.RIGHT = RIGHT;
        goto REEXPAND;

EXPAND(SUB_VO):

	call BINARY_CHECKS (V,
			    LEFT,
			    RIGHT,
			    THIRD,
			    EXPAND_DONE);
	if EXPAND_DONE then
		goto EXIT;

	CXX_VALUE_NODE_PTR = LEFT;
        call GET_VALUE_TYPE (WORK_TYPE_01);

        if WORK_TYPE_01.TOP_TYPE.CODE ^= byte (POINTER_DT) then do;
		/*
		/* LEFT is not a pointer.
		/* Make sure both the LEFT and RIGHT are of arithmetic type.
		/**/
		CXX_VALUE_NODE_PTR = RIGHT;
        	call GET_VALUE_TYPE (WORK_TYPE_02);
		if ^IS_ARITHMETIC_TYPE (rank (WORK_TYPE_01.TOP_TYPE.CODE)) |
		   ^IS_ARITHMETIC_TYPE (rank (WORK_TYPE_02.TOP_TYPE.CODE)) then
  			call SEMANTIC_ERROR (ERR_NONARITH_SUB);
                call CONVERT_COMMON ();
                goto FOLD_AND_EXIT;
	end;
  
        /* LEFT is a pointer value */
  
	CXX_VALUE_NODE_PTR = RIGHT;
        call GET_VALUE_TYPE (WORK_TYPE_02);
  	if WORK_TYPE_02.TOP_TYPE.CODE ^= byte (POINTER_DT) then do;
  		/*
  		/* LEFT is a pointer and RIGHT is not.
  		/* Make sure the RIGHT is an integral type.
  		/**/
                  RIGHT = CHECK_INTEGER (RIGHT);
                  RIGHT = GET_VALUE_AND_EXPAND_L (MINUS_VO, RIGHT);
                  call NORMALIZE_BEFORE_INDEX (SUB_VO);
                  call INDEX_PTR ();
                  goto FOLD_AND_EXIT;
  	end;
  
          /* This is: POINTER - POINTER */

	if COMPATIBLE_POINTERS (LEFT, RIGHT, VOP) then do;
		/*
		/* Error; incompatible pointer types;
		/* diagnostic already given in COMPATIBLE_POINTERS.
		/**/
		;
	end;
  
        call STRIP_TOP_TYPE (WORK_TYPE_02, TRUE); /* of RIGHT */
        call STRIP_TOP_TYPE (WORK_TYPE_01, TRUE); /* of LEFT */

        if WORK_TYPE_01.SIZE_UNITS ^= WORK_TYPE_02.SIZE_UNITS then
		call SEMANTIC_ERROR (ERR_UNKNOWN_PTR_SUBTR_SIZE);

        /* Determine size to scale result by */

	if (WORK_TYPE_01.SIZE = 0) | (WORK_TYPE_01.SIZE_UNITS = 0) then do;
		/*
                /* Error; unknown sized objects for pointer subtraction..
		/**/
                call SEMANTIC_ERROR (ERR_UNKNOWN_PTR_SUBTR_SIZE);
                THIS_SIZE = 1;
                THIS_SIZE_UNITS = ADDRESS_UNITS;
	end;
	else do;
		THIS_SIZE = WORK_TYPE_01.SIZE;
		THIS_SIZE_UNITS = WORK_TYPE_01.SIZE_UNITS;
	end;

        /* This scaling won't work properly on all machines! */

        KV = INTEGER_VALUE (ROUNDU (THIS_SIZE,
				    THIS_SIZE_UNITS,
				    ADDRESS_UNITS),
			    0);

        /* Attempt to fold */

        if EVALUATE_POINTER (LEFT, KN, WORK_TYPE_01.SIZE, 0) &
	   EVALUATE_POINTER (RIGHT, K2, WORK_TYPE_02.SIZE, 0) then do;
		if KN = K2 then do; /* same symbol */
                        call COUNT_DOWN_VALUE (LEFT);
                        call COUNT_DOWN_VALUE (RIGHT);
			/*
			/* The difference of the two offsets
			/* returned by EVALUATE_POINTER.
			/**/
                        LEFT = INTEGER_VALUE
			       (WORK_TYPE_01.SIZE - WORK_TYPE_02.SIZE, 0);
                        goto FINISH_SUB_PTR;
		end;
	end;

        /* Construct a SUB of two pointers with "int" result type */

        LEFT = ALLOC_CXX_VALUE_NODE_LR (SUB_VO, LEFT, RIGHT);
        call SET_VALUE_SIMPLE_TYPE (INT_BT);

        /* Result is difference divided by scale factor */

FINISH_SUB_PTR:
	CXX_VALUE_NODE_PTR = V;
        CXX_VALUE_NODE.OP = DIV_VO;
        CXX_VALUE_NODE.LEFT = LEFT;
        CXX_VALUE_NODE.RIGHT = KV; /* size scale computed above */
        goto REEXPAND;

EXPAND(MUL_VO):

	call BINARY_CHECKS (V, LEFT, RIGHT, THIRD, EXPAND_DONE);
	if EXPAND_DONE then
		goto EXIT;

	/* Make sure LEFT and RIGHT are arithmetic types */

	CXX_VALUE_NODE_PTR = LEFT;
	call GET_VALUE_TYPE (WORK_TYPE_01);
	CXX_VALUE_NODE_PTR = RIGHT;
	call GET_VALUE_TYPE (WORK_TYPE_02);
	if ^IS_ARITHMETIC_TYPE (rank (WORK_TYPE_01.TOP_TYPE.CODE)) |
	   ^IS_ARITHMETIC_TYPE (rank (WORK_TYPE_02.TOP_TYPE.CODE)) then 
  		call SEMANTIC_ERROR (ERR_NONARITH_MUL);
        call CONVERT_COMMON ();
        goto REORDER_FOLD_AND_EXIT;

EXPAND(DIV_VO):

	call BINARY_CHECKS (V, LEFT, RIGHT, THIRD, EXPAND_DONE);
	if EXPAND_DONE then
		goto EXIT;

	/* Make sure LEFT and RIGHT are arithmetic types */

	CXX_VALUE_NODE_PTR = LEFT;
	call GET_VALUE_TYPE (WORK_TYPE_01);
	CXX_VALUE_NODE_PTR = RIGHT;
	call GET_VALUE_TYPE (WORK_TYPE_02);
	if ^IS_ARITHMETIC_TYPE (rank (WORK_TYPE_01.TOP_TYPE.CODE)) |
	   ^IS_ARITHMETIC_TYPE (rank (WORK_TYPE_02.TOP_TYPE.CODE)) then 
  		call SEMANTIC_ERROR (ERR_NONARITH_DIV);
        call CONVERT_COMMON ();

	CXX_VALUE_NODE_PTR = RIGHT;

        if (CXX_VALUE_NODE.OP = INTEGER_VO) &
           (CXX_VALUE_NODE.OFFSET = 0) then do;
		/*
                /* Error; division by zero is not defined.
		/**/
                call SEMANTIC_ERROR(ERR_ZERO_DIVIDE);
	end;

	CXX_VALUE_NODE_PTR = V;
        goto FOLD_AND_EXIT;

EXPAND(MOD_VO):

	call BINARY_CHECKS (V, LEFT, RIGHT, THIRD, EXPAND_DONE);
	if EXPAND_DONE then
		goto EXIT;

	/* Make sure LEFT and RIGHT are integral types */

	CXX_VALUE_NODE_PTR = LEFT;
	call GET_VALUE_TYPE (WORK_TYPE_01);
	CXX_VALUE_NODE_PTR = RIGHT;
	call GET_VALUE_TYPE (WORK_TYPE_02);
	if ^IS_INTEGRAL_TYPE (rank (WORK_TYPE_01.TOP_TYPE.CODE)) |
	   ^IS_INTEGRAL_TYPE (rank (WORK_TYPE_02.TOP_TYPE.CODE)) then
		call SEMANTIC_ERROR (ERR_NONINT_MOD);

	LEFT = CHECK_INTEGER (LEFT);
	RIGHT = CHECK_INTEGER (RIGHT);
	call CONVERT_COMMON ();
	goto FOLD_AND_EXIT;

EXPAND(AND_VO): ;
EXPAND(OR_VO): ;
EXPAND(XOR_VO): ;

	call BINARY_CHECKS (V, LEFT, RIGHT, THIRD, EXPAND_DONE);
	if EXPAND_DONE then
		goto EXIT;

	/* Make sure LEFT and RIGHT are integral types */

	CXX_VALUE_NODE_PTR = LEFT;
	call GET_VALUE_TYPE (WORK_TYPE_01);
	CXX_VALUE_NODE_PTR = RIGHT;
	call GET_VALUE_TYPE (WORK_TYPE_02);

	if ^IS_INTEGRAL_TYPE (rank (WORK_TYPE_01.TOP_TYPE.CODE)) |
	   ^IS_INTEGRAL_TYPE (rank (WORK_TYPE_02.TOP_TYPE.CODE)) then
		call SEMANTIC_ERROR (ERR_NONINT_BITOP);

	/* (106)
	/* LEFT = CONVERT_COMP_BIT (LEFT);
	/* RIGHT = CONVERT_COMP_BIT (RIGHT);
	/* call CONVERT_BITOP ();
	/**/
	call CONVERT_COMMON ();		/* (106) */

	goto REORDER_FOLD_AND_EXIT;

EXPAND(COMPLEMENT_VO):

	call UNARY_CHECKS (V, LEFT, EXPAND_DONE);
	if EXPAND_DONE then
		goto EXIT;

	LEFT = CHECK_INTEGER (LEFT);

EXPAND(MINUS_VO):

	/* Make sure we have an arithmetic type */

	call UNARY_CHECKS (V, LEFT, EXPAND_DONE);
	if EXPAND_DONE then
		goto EXIT;

	CXX_VALUE_NODE_PTR = LEFT;
	if ^IS_ARITHMETIC_TYPE (rank (CXX_VALUE_NODE.TOP_TYPE.CODE)) then
		call SEMANTIC_ERROR (ERR_NONARITH_MINUS);

        LEFT = CONVERT_ARITH (LEFT);
        call GET_VALUE_TYPE (WORK_TYPE_01);

	CXX_VALUE_NODE_PTR = V;
	call SET_VALUE_TYPE (WORK_TYPE_01);

	/* minus->constant, leaving counts, etc. */

	CXX_VALUE_NODE.OP	= VOP;
	CXX_VALUE_NODE.LEFT	= LEFT;
	CXX_VALUE_NODE.UNARY	= TRUE;

	goto FOLD_AND_EXIT;

EXPAND(PLUS_VO):

	call UNARY_CHECKS (V, LEFT, EXPAND_DONE);
	if EXPAND_DONE then
		goto EXIT;

        call COUNT_UP_VALUE (LEFT);	/* Up the LEFT */

	/* Make sure we have an arithmetic type */

	CXX_VALUE_NODE_PTR = LEFT;
	if ^IS_ARITHMETIC_TYPE (rank (CXX_VALUE_NODE.TOP_TYPE.CODE)) then
		call SEMANTIC_ERROR (ERR_NONARITH_PLUS);

        LEFT = CONVERT_ARITH (LEFT);	/* Integral promotion required */

        call COUNT_DOWN_VALUE (V);	/* Discard the + */
        V = LEFT;			/* Result is its operand */
	CXX_VALUE_NODE_PTR = V;
        goto EXIT;

EXPAND(RSHIFT_VO):
EXPAND(LSHIFT_VO):

	call BINARY_CHECKS (V, LEFT, RIGHT, THIRD, EXPAND_DONE);
	if EXPAND_DONE then
		goto EXIT;

	/* Make sure LEFT and RIGHT are integral types */

	CXX_VALUE_NODE_PTR = LEFT;
	TYPE = rank (CXX_VALUE_NODE.TOP_TYPE.CODE);
	CXX_VALUE_NODE_PTR = RIGHT;
	if ^IS_INTEGRAL_TYPE (TYPE) |
	   ^IS_INTEGRAL_TYPE (rank (CXX_VALUE_NODE.TOP_TYPE.CODE)) then
		call SEMANTIC_ERROR (ERR_NONINT_BITOP);

        RIGHT = CHECK_INTEGER (RIGHT);
        RIGHT = CONVERT_VALUE (RIGHT, SHORT_BT);

        if (VOP = RSHIFT_VO) & ^CXX_USE_LONG_OPERATIONS then do;
		/*
		/* If the value being shifted right is shorter than
		/* an int, then leave it short rather than extending.
		/**/
		CXX_VALUE_NODE_PTR = LEFT;
                call GET_VALUE_TYPE (WORK_TYPE_01);
		TYPE = rank (WORK_TYPE_01.TOP_TYPE.CODE);
                if (TYPE = CHAR_BT)   |
		   (TYPE = UCHAR_BT)  |
		   (TYPE = SCHAR_BT)  |
		   (TYPE = SSHORT_BT) |
		   (TYPE = SHORT_BT)  |
		   (TYPE = USHORT_BT) then do;
                        if (TYPE = CHAR_BT)  |
			   (TYPE = UCHAR_BT) |
			   (TYPE = SCHAR_BT) then do;
                                LEFT = CONVERT_VALUE (LEFT, SHORT_BT);
				CXX_VALUE_NODE_PTR = LEFT;
                        end;
                        /* LEFT is now SHORT or USHORT */
                        goto FINISH_SHIFT;
                end;
        end;

        LEFT = CHECK_INTEGER (LEFT);

FINISH_SHIFT:
        call GET_VALUE_TYPE (WORK_TYPE_01); /* of LEFT */
	CXX_VALUE_NODE_PTR = V;
        call SET_VALUE_TYPE (WORK_TYPE_01);
        CXX_VALUE_NODE.LEFT = LEFT;
        CXX_VALUE_NODE.RIGHT = RIGHT;
        goto FOLD_AND_EXIT;

EXPAND(AND_AND_VO):
EXPAND(OR_OR_VO):

	call BINARY_CHECKS (V, LEFT, RIGHT, THIRD, EXPAND_DONE);
	if EXPAND_DONE then
		goto EXIT;

	/* Record -ztemp destruction level, if applicable */

	if V->CXX_VALUE_NODE.TERNARY then do;
		KV = V->CXX_VALUE_NODE.THIRD;
		KN = 1;
		V->CXX_VALUE_NODE.THIRD = NULL_CXX_VID;
		V->CXX_VALUE_NODE.TERNARY = FALSE;
	end;
	else	KN = 0;

	RIGHT = CONVERT_VALUE (RIGHT, LOGICAL_BT);

	/* Account for -ztemp destruction of RIGHT expression */

	if KN ^= 0 then do;
		/*
		/* Affix the destruction of the newer temporaries to RIGHT.
		/**/
		call COUNT_UP_VALUE (KV);
		KV2 = CURRENT_DESTRUCTORS ();
		RIGHT = VALUE_BEFORE_EFFECT (RIGHT,
					     DESTROY_DIFFERENCE (KV2, KV));
		/*
		/* Pop the newer destruction from the current set.
		/**/
		call POP_DESTRUCTORS (KV);
	end;

	V->CXX_VALUE_NODE.RIGHT = RIGHT;

EXPAND(NOT_VO):

	if VOP = NOT_VO then do;
		call UNARY_CHECKS (V, LEFT, EXPAND_DONE);
		if EXPAND_DONE then
			goto EXIT;
	end;

	LEFT = CONVERT_VALUE (LEFT, LOGICAL_BT);
	CXX_VALUE_NODE_PTR = V;
	CXX_VALUE_NODE.LEFT = LEFT;
	if VOP = NOT_VO then
		CXX_VALUE_NODE.UNARY = TRUE;
	goto FINISH_LOGICAL;

EXPAND(EQ_VO):
EXPAND(GE_VO):
EXPAND(LE_VO):
EXPAND(NE_VO):
EXPAND(LT_VO):
EXPAND(GT_VO):

	call BINARY_CHECKS (V, LEFT, RIGHT, THIRD, EXPAND_DONE);
	if EXPAND_DONE then
		goto EXIT;

	/*
	/* Equality operator constraints [X3J11/88-159:3.3.9]:
	/*
	/* One of the following shall hold:
	/*
	/* - Both operands have arithmetic type.
	/* - Both operands are pointers to qualified or
	/*   unqualified versions of compatible types.
	/* - One operand is a pointer to an object or incomplete type and the
	/*   other is a pointer to a qualified or unqualified version of void.
	/* - One operand is a pointer and the other is a null pointer constant.
	/*
	/* Relational operator constraints [X3J11/88-159:3.3.8]:
	/*
	/* One of the following shall hold:
	/*
	/* - Both operands have arithmetic type.
	/* - Both operands are pointers to qualified or unqualified versions
	/*   of compatible object types.
	/* - Both operands are pointers to qualified or unqualified versions
	/*   of compatible incomplete types.
	/**/

	CXX_VALUE_NODE_PTR = LEFT;
        call GET_VALUE_TYPE (WORK_TYPE_01);

	CXX_VALUE_NODE_PTR = RIGHT;
	call GET_VALUE_TYPE (WORK_TYPE_02);

	/* Check enumerator compatibility */

	if (WORK_TYPE_01.TOP_TYPE.CODE = byte (ENUM_BT)) &
	   (WORK_TYPE_02.TOP_TYPE.CODE = byte (ENUM_BT)) then do;
		if WORK_TYPE_01.TOP_TYPE.TAG_SYMBOL ^=
		   WORK_TYPE_02.TOP_TYPE.TAG_SYMBOL then do;
			/*
			/* Warning; comparison of different enumeration types.
			/**/
			if ^SW_CLASSIC_C_MODE then do;
				call SEMANTIC_ERROR_II
				     (ERR_DISSIMILAR_ENUM_TYPES,
				      QUALIFIED_SYMBOL_NAME
				      (WORK_TYPE_01.TAG_SYMBOL),
				      QUALIFIED_SYMBOL_NAME
				      (WORK_TYPE_02.TAG_SYMBOL));
			end;
		end;
	end;

	if (WORK_TYPE_02.TOP_TYPE.CODE = byte (MEMBER_POINTER_DT) |
	    WORK_TYPE_02.TOP_TYPE.CODE = byte (POINTER_DT)) & /* RIGHT */
           (WORK_TYPE_01.TOP_TYPE.CODE ^= byte (MEMBER_POINTER_DT) &
            WORK_TYPE_01.TOP_TYPE.CODE ^= byte (POINTER_DT)) then do;/* LEFT */
                /*
		/* Swap to put the pointer value on the left.
		/**/
		KV = LEFT; LEFT = RIGHT; RIGHT = KV;
		WORK_TYPE_01 = WORK_TYPE_02;	/* New LEFT */
		if	VOP = LT_VO then VOP = GE_VO;
		else if VOP = GE_VO then VOP = LT_VO;
		else if VOP = GT_VO then VOP = LE_VO;
		else if VOP = LE_VO then VOP = GT_VO;
	end;

	/* See if neither LEFT nor RIGHT was a pointer */

        if (WORK_TYPE_01.TOP_TYPE.CODE ^= byte (MEMBER_POINTER_DT)) & 
	   (WORK_TYPE_01.TOP_TYPE.CODE ^= byte (POINTER_DT)) then do;
		call CONVERT_RELATIONAL ();
		goto FINISH_RELATIONAL;
	end;

        /* Here, at least the LEFT is a pointer */

	IS_ERROR = ^COMPATIBLE_RELATIONAL_POINTERS (LEFT, RIGHT, VOP);
	if (WORK_TYPE_01.TYPE_CODE = byte (MEMBER_POINTER_DT)) |
	   (WORK_TYPE_02.TYPE_CODE = byte (MEMBER_POINTER_DT)) then do;
		V = COMPARE_MEMBER_POINTERS (LEFT, RIGHT, VOP);
		goto EXIT;
	end;
	if ^IS_ERROR then
		goto FINISH_RELATIONAL;

	/* 
	/* -TODO- Check out what this stuff below is for.
	/* I don't think we need to do this any more
	/* (except maybe for an obscure K&R switch).
	/*
	/* One situation which brings us here is that one of the
	/* expressions has function type, e.g. "object.member_function".
	/**/

	CXX_VALUE_NODE_PTR = RIGHT;		/* Done already above ? */
	call GET_VALUE_TYPE (WORK_TYPE_02);

	/* Cast the one with greater boundary */

	if WORK_TYPE_02.SIZE_UNITS > WORK_TYPE_01.SIZE_UNITS then
		RIGHT = GENERAL_CONVERT_VALUE (RIGHT, WORK_TYPE_01, VOP);
	else if WORK_TYPE_02.SIZE_UNITS < WORK_TYPE_01.SIZE_UNITS then
		LEFT = GENERAL_CONVERT_VALUE (LEFT, WORK_TYPE_02, VOP);

FINISH_RELATIONAL:
	CXX_VALUE_NODE_PTR = V;
	CXX_VALUE_NODE.OP = VOP;
	CXX_VALUE_NODE.LEFT = LEFT;
	CXX_VALUE_NODE.RIGHT = RIGHT;

FINISH_LOGICAL:
        call SET_VALUE_SIMPLE_TYPE (LOGICAL_BT);
	if (VOP = NOT_VO) | (VOP = AND_AND_VO) | (VOP = OR_OR_VO) then
		goto FOLD_AND_EXIT;
	goto REORDER_FOLD_AND_EXIT;


EXPAND(BRANCH_EQ_VO):
EXPAND(BRANCH_GE_VO):
EXPAND(BRANCH_LE_VO):
EXPAND(BRANCH_NE_VO):
EXPAND(BRANCH_LT_VO):
EXPAND(BRANCH_GT_VO):

	CXX_VALUE_NODE.TERNARY = TRUE;
	call SET_VALUE_SIMPLE_TYPE (VOID_BT);
	goto EXIT;

EXPAND(BRANCH_TRUE_VO): ;
EXPAND(BRANCH_FALSE_VO): ;

	CXX_VALUE_NODE_PTR = RIGHT;
        if CXX_VALUE_NODE.OP = COMMA_VO then do;
		/*
		/* Transform:
		/*
		/*  BRANCH_TRUE/FALSE (L, COMMA (X, Y))
		/*
		/* Into:
		/*
		/*  COMMA (X, BRANCH_TRUE/FALSE (L, Y))
		/**/
                KV = LEFT;			/* L */
                LEFT = CXX_VALUE_NODE.LEFT;	/* X */
                RIGHT = CXX_VALUE_NODE.RIGHT;	/* Y */
		call COUNT_UP_VALUE (KV);
		call COUNT_UP_VALUE (LEFT);
                call COUNT_UP_VALUE (RIGHT);
		call COUNT_DOWN_VALUE (V);
		RIGHT = GET_VALUE_AND_EXPAND_LR
			(VOP, KV, RIGHT);	/* BRANCH_TRUE/FALSE (L, Y) */
		V = EFFECT_BEFORE_VALUE (LEFT, RIGHT);
		goto EXIT;
	end;

	/*
	/* We don't try the above kind of trick with LEFT_VALUE_VO,
	/* i.e. to get the branch folded in with its value operand,
	/* because there's not such a clear-cut transformation as for
	/* COMMA_VO, and because there are so many cases which could
	/* come out of the folding, each of which would have to be 
	/* combined differently with LEFT_VALUE.
	/**/

        KV = CONVERT_VALUE (RIGHT, LOGICAL_BT);

	CXX_VALUE_NODE_PTR = V;
        CXX_VALUE_NODE.RIGHT = KV;
	call SET_VALUE_SIMPLE_TYPE (VOID_BT);
        goto FOLD_AND_EXIT;

EXPAND(BRANCH_COMPUTED_VO):

        K = 0;
        THIRD = CXX_VALUE_NODE.RIGHT;

	/* Count its ARGS on the RIGHT */

        do while (^CXX_VALUE_NODE.RIGHT_IS_NOT_VID &
		  (CXX_VALUE_NODE.RIGHT ^= NULL_CXX_VID));
		K = K + 1;
		CXX_VALUE_NODE_PTR = CXX_VALUE_NODE.RIGHT;
        end;

	CXX_VALUE_NODE_PTR = V;
        CXX_VALUE_NODE.OFFSET = K;		/* Number of labels */
	call SET_VALUE_SIMPLE_TYPE (VOID_BT);	/* Non-value producing */
        goto EXIT;

EXPAND(INC_VO): ;
EXPAND(DEC_VO): ;

	call UNARY_CHECKS (V, LEFT, EXPAND_DONE);
	if EXPAND_DONE then
		goto EXIT;

        RIGHT = INTEGER_VALUE_ONE ();
	CXX_VALUE_NODE_PTR = V;
        if VOP = INC_VO then
		CXX_VALUE_NODE.OP = ADD_ASSIGN_VO;
	else	CXX_VALUE_NODE.OP = SUB_ASSIGN_VO;
        CXX_VALUE_NODE.RIGHT = RIGHT;
        goto REEXPAND;

EXPAND(POST_INC_VO): ;
EXPAND(POST_DEC_VO): ;

	call UNARY_CHECKS (V, LEFT, EXPAND_DONE);
	if EXPAND_DONE then
		goto EXIT;

        call COUNT_UP_VALUE (LEFT);
	KV = LEFT;

/*
/* DGM (061) ...
/*	if CXX_VALUE_NODE.SIZE_UNITS = byte (BITS) then
/*               LEFT = GET_VALUE_AND_EXPAND_L (FIELD_VO, LEFT);
/**/
	/* Make sure we have an lvalue */

	CXX_VALUE_NODE_PTR = LEFT;
	call GET_VALUE_TYPE (WORK_TYPE_01);
	if WORK_TYPE_01.NOT_AN_LVALUE then do;
		call SEMANTIC_ERROR (ERR_BAD_LVALUE_ASSIGN);
		call COUNT_DOWN_VALUE (LEFT);
		LEFT = NULL_CXX_VID;
	end;
	else do;
		/*
		/* Guard against modifying a "const" object.
		/**/
		if WORK_TYPE_01.TOP_TYPE.CONST then
			call SEMANTIC_ERROR (ERR_ILLEGAL_CONST_ACCESS);
		/*
		/* Do the increment/decrement and assignment.
		/**/
		if VOP = POST_INC_VO then
			VOP = ADD_VO;
		else	VOP = SUB_VO;
		call COUNT_UP_VALUE (LEFT);
		RIGHT = GET_VALUE_AND_EXPAND_LR
			(VOP, LEFT, INTEGER_VALUE_ONE ());
		LEFT = GET_VALUE_AND_EXPAND_LR (COPY_VO, LEFT, RIGHT);
	end;

	CXX_VALUE_NODE_PTR = V;
	CXX_VALUE_NODE.LEFT = NULL_CXX_VID;
	CXX_VALUE_NODE.RIGHT = NULL_CXX_VID;
	call COUNT_DOWN_VALUE (V);

	CXX_VALUE_NODE_PTR = KV;
	CXX_VALUE_NODE.NOT_AN_LVALUE = TRUE; /* DGM, 2.26.91 */
	V = VALUE_BEFORE_EFFECT (KV /* the original value */, LEFT);
	goto EXIT;

EXPAND(DECLARE_LABEL_VO):
EXPAND(SAVE_VO):

	CXX_VALUE_NODE.NULARY = TRUE;
	call SET_VALUE_SIMPLE_TYPE (LABEL_BT);
	goto EXIT;

EXPAND(CONDITIONAL_VO):

        /*
        LEFT is test value.
        RIGHT is COLON value.
        */

	LEFT = VALUE_OF (LEFT);
	LEFT = CHECK_USER_CONVERSION (LEFT, ARITHORPTR_TK, NULL_NID);
        LEFT = CONVERT_VALUE (LEFT, LOGICAL_BT);

	CXX_VALUE_NODE_PTR = RIGHT;
        call GET_VALUE_TYPE (WORK_TYPE_01);

	CXX_VALUE_NODE_PTR = V;
        call SET_VALUE_TYPE (WORK_TYPE_01);
        CXX_VALUE_NODE.LEFT = LEFT;

        /* Check if the CONDITIONAL vop detected an lvalue */

        if ^WORK_TYPE_01.NOT_AN_LVALUE then do;
		/* If so, then the COLON_VO made ptr refs */
		call ADD_POINTER_LEVEL (WORK_TYPE_01);
		CXX_VALUE_NODE_PTR = V;
		/* Set up type info for ptr refs */
		call SET_VALUE_TYPE (WORK_TYPE_01);
		/* Dereference it. */
                V = GET_VALUE_AND_EXPAND_L (STAR_VO, (V));    
                goto EXIT;
	end;        

	/* Cond result not an lvalue */
        CXX_VALUE_NODE.NOT_AN_LVALUE = TRUE;
        goto FOLD_AND_EXIT;  

EXPAND(COLON_VO):

	/*
        /* Convert LEFT and RIGHT to a common type
        /* and stick ALTERNATE values on them.
        /**/

	/* Account for -ztemp destruction of RIGHT expression */

	if CXX_VALUE_NODE.TERNARY then do;
		KV = CXX_VALUE_NODE.THIRD;
		CXX_VALUE_NODE.THIRD = NULL_CXX_VID;
		CXX_VALUE_NODE.TERNARY = FALSE;

		/* Affix the destruction of the newer temporaries to RIGHT */
		call COUNT_UP_VALUE (KV);
		KV2 = CURRENT_DESTRUCTORS ();
		RIGHT = VALUE_BEFORE_EFFECT (RIGHT,
					     DESTROY_DIFFERENCE (KV2, KV));

		/* Pop the newer destruction from the current set */
		call POP_DESTRUCTORS (KV);
	end;

        /* Check whether the operands meet the C++ lvalue rule */

	if ^SW_STRICT_LVALUE then do;
		if IDENTICAL_CONDITIONAL_LVALUES (LEFT, RIGHT, V) then do;
			CXX_VALUE_NODE_PTR = V;
			call GET_VALUE_TYPE (WORK_TYPE_01);
			/*
			/* Added the following to fix:
			/* int&f(int&x,int&y){return(x>y?x:y);}
			/**/
			if WORK_TYPE_01.TOP_TYPE.CODE = byte (REFERENCE_DT) then
				call STRIP_TOP_TYPE (WORK_TYPE_01, TRUE);
			else	WORK_TYPE_01.NOT_AN_LVALUE = FALSE;
			/* Turn into ptr refs */
			LEFT  = GET_VALUE_AND_EXPAND_L
				(IMPLICIT_ADDR_VO, LEFT);
			RIGHT = GET_VALUE_AND_EXPAND_L
				(IMPLICIT_ADDR_VO, RIGHT);
			goto DONE_COLON_VO;
		end;
	end;

	LEFT = VALUE_OF (LEFT);
	RIGHT = VALUE_OF (RIGHT);

	/* See if operands are class types */

	if COMPATIBLE_CONDITIONAL_CLASSES (LEFT, RIGHT, IS_ERROR) then
		IS_ERROR = TRUE;
	if IS_ERROR then do;
		/*
		/* Classes compatible, or class error found.
		/**/
		CXX_VALUE_NODE_PTR = LEFT;
		call GET_VALUE_TYPE (WORK_TYPE_01);
		goto DONE_COLON_RVALUE;
	end;

	/* See if operands are pointer types */

	if COMPATIBLE_CONDITIONAL_POINTERS (LEFT, RIGHT, V, IS_ERROR) then do;
		CXX_VALUE_NODE_PTR = V;
		call GET_VALUE_TYPE (WORK_TYPE_01);
		goto DONE_COLON_RVALUE;
	end;
	else if IS_ERROR then
		goto CONVERT_COLON_VO;   /* Convert to same type; go on */

	/* See if the operands are enum types */

	CXX_VALUE_NODE_PTR = RIGHT;
	TYPE = rank (CXX_VALUE_NODE.TOP_TYPE.CODE);
	CXX_VALUE_NODE_PTR = LEFT;

	if (TYPE = ENUM_BT) &
	   (LEFT->CXX_VALUE_NODE.TOP_TYPE.CODE = byte (ENUM_BT)) then do;
		/*
		/* Here, the second and third operand of a conditional
		/* expression are of enumeration type.  If they are
		/* both of the same enumeration then leave the types
		/* as is and set the type of the COLON to that enumeration
		/* type.  But if they are of different enumeration types
		/* then set their types and the type of the COLON to
		/* int (this is apparently not an error).
		/**/
		TID = LEFT->CXX_VALUE_NODE.TOP_TYPE.TAG_SYMBOL;
		if TID ^= RIGHT->CXX_VALUE_NODE.TOP_TYPE.TAG_SYMBOL then do;
			LEFT  = CONVERT_VALUE (LEFT, INT_BT);
			RIGHT = CONVERT_VALUE (RIGHT, INT_BT);
		end;
		CXX_VALUE_NODE_PTR = LEFT;
		call GET_VALUE_TYPE (WORK_TYPE_01);
		goto DONE_COLON_RVALUE;
	end;

        /* See if either of the operands are void types */

	/*
	/* Operands with type void and no qualifiers (for sideeffects).  E.g:
	/*
	/*	void f(); int i; i ? (void)0 : f ();
	/*
	/* Hang NOPs to comsume the expressions (rather than alternates).
	/*
	/* In addition, attempt to diagnose and handle the idiom:
	/*
	/*      e1 ? e2: 0;
	/*
	/* where e2 is of type void.
	/**/

	else if (TYPE = VOID_BT) |
		(CXX_VALUE_NODE.TOP_TYPE.CODE = byte (VOID_BT)) then do;
		CXX_VALUE_NODE_PTR = RIGHT;
		if CXX_VALUE_NODE.TOP_TYPE.CODE = byte (VOID_BT) then do; 
			call GET_VALUE_TYPE (WORK_TYPE_01);
			WORK_TYPE_01.NOT_AN_LVALUE = TRUE;
		end;
		else if (CXX_VALUE_NODE.OP = INTEGER_VO) &
			(CXX_VALUE_NODE.OFFSET = 0) then do;
			/* Here, Left is void, Right is 0. */
			call COUNT_DOWN_VALUE (RIGHT);
			RIGHT = GET_CONSTRUCTOR_VALUE (GET_VOID_TYPE (), 
						       NULL_CXX_VID, NULL_NID,
						       IMPLICIT_CAST_VO);
			call SEMANTIC_ERROR (ERR_REQ_VOID_IN_CONDITIONAL);
		end;
		else do;
			/*
			/* (Left is void; Right is something else).
			/* Incompatible types as second and third operands of 
			/* conditional. If one operand has type "void", then 
			/* both operands must have type "void"; try explicit 
			/* casting.
			/**/
			call SEMANTIC_ERROR (ERR_BAD_VOID_IN_CONDITIONAL);
		end;

		CXX_VALUE_NODE_PTR = LEFT; /* 117 */
		if CXX_VALUE_NODE.TOP_TYPE.CODE = byte (VOID_BT) then do; 
			call GET_VALUE_TYPE (WORK_TYPE_01);
			WORK_TYPE_01.NOT_AN_LVALUE = TRUE;
		end;
		else if (CXX_VALUE_NODE.OP = INTEGER_VO) &
			(CXX_VALUE_NODE.OFFSET = 0) then do;
			/* Here, Right is void, Left is 0. */
			call COUNT_DOWN_VALUE (LEFT);
			LEFT = GET_CONSTRUCTOR_VALUE (GET_VOID_TYPE (),
						      NULL_CXX_VID, NULL_NID,
						      IMPLICIT_CAST_VO);
			call SEMANTIC_ERROR (ERR_REQ_VOID_IN_CONDITIONAL);
		end;
		else do; 
			/* (Right is void; Left is something else).
			/* Incompatible types as second and third operands of 
			/* conditional. If one operand has type "void", then 
			/* both operands must have type "void"; try explicit 
			/* casting.
			/**/
			call SEMANTIC_ERROR(ERR_BAD_VOID_IN_CONDITIONAL);
		end;
		goto DONE_COLON_VO;
	end;

	/* Else convert operands to arithmetic types */

CONVERT_COLON_VO:

	/*
	/* ANSI C++ (X3J16/92-0600), section 5.16:
	/*
	/* "If both the second and third expressions are of arithmetic
	/*  type, then if they are of the same type the result is of
	/*  that type; otherwise the usual arithmetic conversions
	/*  are performed to bring them to a common type."
	/**/

	if SAME_VALUE_TYPE (LEFT, RIGHT) then do;
		CXX_VALUE_NODE_PTR = LEFT;
		call GET_VALUE_TYPE (WORK_TYPE_01);
		V->CXX_VALUE_NODE.LEFT = LEFT;
		V->CXX_VALUE_NODE.RIGHT = RIGHT;
		CXX_VALUE_NODE_PTR = V;
		call SET_VALUE_TYPE (WORK_TYPE_01);
	end;
	else do;
		CXX_VALUE_NODE_PTR = V;
		call CONVERT_COMMON ();
	end;

DONE_COLON_RVALUE:
	WORK_TYPE_01.NOT_AN_LVALUE = TRUE;

        /* Got common types, hang alternates values on them */

DONE_COLON_VO:

	LEFT  = GET_VALUE_AND_EXPAND_L (ALTERNATE_VO, LEFT);
	RIGHT = GET_VALUE_AND_EXPAND_L (ALTERNATE_VO, RIGHT);

        /* Set up type info on the COLON vop */

	CXX_VALUE_NODE_PTR = V;
	call SET_VALUE_TYPE (WORK_TYPE_01);
	CXX_VALUE_NODE.LEFT = LEFT;
	CXX_VALUE_NODE.RIGHT = RIGHT;
	goto EXIT;

EXPAND(COND_REF_VO):
EXPAND(COND_VALUE_VO):
EXPAND(ALT_VALUE_VO):

	goto EXIT;

EXPAND(CALL_FUNCTION_VO): ;
EXPAND(CALL_VO): ;

	/*
	/* The LEFT operand is either
	/*	ADDR_VO(REF_VO(symbol)-->function)-->pointer to function
	/* or								   
	/*	VALUE_VO(REF_VO(whatever)-->pointer)-->pointer to function
	/* or
	/*	DOT_STAR_VO(VALUE(REF(object), member function reference))-->function
	/* or
	/*	VALUE_VO(REF_VO(overloaded function symbol))-->function
	/* or
	/*	CALL_FUNCTION_VO-->pointer to function
	/* or
	/*	COMMA_VO or LEFT_VALUE_VO involving one of the above.
        /* In the first case, the LEFT of the REF
        /* is the node_id of a symbol_node of the function.
        /* RIGHT is first ARG value or 0. Other args are linked
        /*         via the RIGHT fields of the ARG values.
        /* THIRD is set to the number of arguments present.
	/*
	/* The code generator expects VALUE(REF(function symbol))
	/* rather than ADDR(REF(function symbol)) as the operand of call.
	/* We tranform that case of LEFT in EMIT_TREE.
        /**/

	LEFT = VALUE_OF (LEFT);

	CXX_VALUE_NODE_PTR = LEFT;
        call GET_VALUE_TYPE (WORK_TYPE_01);

	/*
	/* Investigate the form of the LEFT expression, to find out
	/* whether it's an object bound to a member function, 
	/**/

	call BYPASS_COMMA ();
	TYPE = rank (WORK_TYPE_01.TOP_TYPE.CODE);
	SAVED_VOP = CXX_VALUE_NODE.OP;
	KV2 = NULL_CXX_VID;
	if TYPE = FUNCTION_DT then do;
		if SAVED_VOP = DOT_STAR_VO then do;
			KV2 = CXX_VALUE_NODE.RIGHT;
			KV = CXX_VALUE_NODE.LEFT;
		end;
		else if SAVED_VOP = UNINITIALIZED_VO then
			/* Error; call bad function, e.g. func_type()() */
			call SEMANTIC_ERROR (ERR_CALL_UNINITIALIZED);
	end;
	else if TYPE = POINTER_DT then do;
		call STRIP_TOP_TYPE (WORK_TYPE_01, TRUE);
		TYPE = rank (WORK_TYPE_01.TOP_TYPE.CODE);
	end;
	else if TYPE = MEMBER_POINTER_DT then do;
		/*
		/* We strip the type for overloaded member pointers, because
		/* it could be for &Class::static_overloaded_function,
		/* or for Class::member_function.
		/**/
		call STRIP_TOP_TYPE (WORK_TYPE_01, TRUE);
		TYPE = rank (WORK_TYPE_01.TOP_TYPE.CODE);
	end;

	VV = NULL_CXX_VID;

        if TYPE ^= FUNCTION_DT then do;
		if ^CHECK_CALL_OVERLOAD (LEFT, RIGHT) then do;
			/*
			/* Error; this is not a function.
			/**/
			call SEMANTIC_ERROR (ERR_NOT_A_FCT);
			goto EXIT; /* --- edit --- */
			goto CALL_ERROR;
		end;
		else do;
			/*
			/* LEFT is a DOT_STAR_VO of the form of a normal member
			/* function reference to the overloaded function.
			/**/
			CXX_VALUE_NODE_PTR = V;
			CXX_VALUE_NODE.LEFT = LEFT;
			goto EXPAND (CALL_VO);
		end;
	end;

	/*
	/* -TODO- At this point, the ANSI C compiler had code which checked
	/*        for VALUE (REF (...locator...)) and would optimize away
	/*	  the outermost VALUE-REF layer.  I haven't bothered with
	/*	  this, because the extra layer is no longer added,
	/*	  except when the thing being called is an array subscript,
	/*        in which case it needs more analysis before the
	/*	  optimization would be correct.  PKT leaves this as TODO
	/*	  because he thinks he may be missing something.
	/**/

	/* Handle overloading, non-pointers only */

	if (SAVED_VOP = DOT_STAR_VO) & (KV2 ^= NULL_CXX_VID) then
		call COUNT_UP_VALUE (KV2);

	else if SAVED_VOP = MEMBER_REF_VO then do;
		/*
		/* Fix up to look like an ordinary reference,
		/* adding 'this->' and diagnosing associated
		/* errors, if non-static.
		/**/
		call DETACH_COMMA (LEFT, T1, KV1);
		LEFT = COPY_VALUE (LEFT);
		LEFT = DEREFERENCE_MEMBER (LEFT, TRUE);
		SAVED_VOP = CXX_VALUE_NODE.OP;
		KV2 = CXX_VALUE_NODE.RIGHT;
		KV = CXX_VALUE_NODE.LEFT;
		call REATTACH_COMMA (LEFT, T1, KV1);
		/* call SET_SYM_NODE_R (K2); DGM, 12.4.91 */
		if (SAVED_VOP = DOT_STAR_VO) & (KV2 ^= NULL_CXX_VID) then
			call COUNT_UP_VALUE (KV2);
	end;

	if IS_OVERLOADED_VALUE (LEFT, K2) then do;
		if SAVED_VOP = DOT_STAR_VO then do;
			/*
			/* For a member function, OVERLOAD needs 'this'
			/* on the argument list.
			/**/
			call COUNT_UP_VALUE (KV);
			call COUNT_UP_VALUE (RIGHT);
			KV = GET_VALUE_AND_EXPAND_LR (ARG_VO, KV, RIGHT);
			OVLD_FSYM = OVERLOAD (KV, NULL_NID, K2, 0);
			call COUNT_DOWN_VALUE (KV);
		end;
		else	OVLD_FSYM = OVERLOAD (RIGHT, K2, NULL_NID, 0);

		if OVLD_FSYM = NULL_NID then do;
			/*  No match could be found for this
			/*  overloaded function reference.
			/**/
			call SEMANTIC_ERROR_I (ERR_NO_OVERLOAD_MATCH,
					       ACTUAL_FUNREF (K2, RIGHT));
			goto CALL_ERROR;
		end;
		K2 = OVLD_FSYM;

		/*
		/* The function to call is K2/OVLD_FSYM.
		/* We must get the parameter list of the overloaded
		/* function, so it can be passed to CHECK_ARGUMENTS.
		/**/
		call SET_SYM_NODE (OVLD_FSYM);
		call GET_SYMBOL_TYPE (WORK_TYPE_01);
		if ^AM_DEBUGGER & XREF then
			call ADDXRF ((CURRENT_NODE_ID), TRUE);

		if (SAVED_VOP = DOT_STAR_VO) & (KV2 ^= NULL_CXX_VID) then do;
			/*
			/* Change KV2, the MEMBER_PTR_VO node, to designate
			/* the overloaded member function just selected.
			/**/
			KV2 = FIXUP_OVERLOADED_MEMBER (KV2, K2);
		end;

		else do;
			/* Check access to symbol, if overloaded member. */
			if SYM_NODE.OVERLOAD & SYM_NODE.IS_AGGREGATE_MEMBER
					     & ^AM_DEBUGGER then do;
				if ^IS_ACCESSIBLE_STATIC (OVLD_FSYM) then do;
					call SEMANTIC_ERROR_I
					     (ERR_PRIV_BASE_MEMBER_REF,
					      FULL_QUALIFIED_SYMBOL_NAME
					      (OVLD_FSYM));
				end;
			end;

			/* If a member function, must be static. */
			if (SYM_NODE.STORAGE_CLASS ^= byte (STATIC_ST)) &
			    SYM_NODE.IS_AGGREGATE_MEMBER then do;
				call SEMANTIC_ERROR_I
					(ERR_MISSING_OBJECT,
					 FULL_QUALIFIED_SYMBOL_NAME 
					 (OVLD_FSYM));
				goto CALL_ERROR;
			end;

			/*
			/* Change LEFT to be the normal function designator
			/* to the overloaded function just selected.
			/* ADDR_VO(REF_VO(symbol)-->function)-->pointer
			/**/
			call DETACH_COMMA (LEFT, KV1, KV);
			call COUNT_DOWN_VALUE (LEFT);
			LEFT = GET_REF_AND_EXPAND (OVLD_FSYM);
			LEFT = ALLOC_CXX_VALUE_NODE_L (ADDR_VO, LEFT);
			call ADD_POINTER_LEVEL (WORK_TYPE_01);
			call SET_VALUE_TYPE (WORK_TYPE_01);
			CXX_VALUE_NODE.FUNCTION_DESIGNATOR = TRUE;
			CXX_VALUE_NODE.UNARY = TRUE;
			call REATTACH_COMMA (LEFT, KV1, KV);
			call STRIP_TOP_TYPE (WORK_TYPE_01, FALSE);
		end;
	end;

	KN = WORK_TYPE_01.TOP_TYPE.SIGNATURE;

	/*
	/* KN is the formal parameters (SIG_NODE)
	/* K2 is the function symbol for the call
	/**/

	/* This is not a direct call to a builtin function; expand the CALL */

	call STRIP_TOP_TYPE (WORK_TYPE_01, TRUE);  /* strip the "()" */

	TYPE = rank (WORK_TYPE_01.TOP_TYPE.CODE);

        if (TYPE = ARRAY_DT) | (TYPE = FUNCTION_DT) then do;
		/*
		/* Not allowed! (diagnosed elsewhere).
		/**/
		call ADD_POINTER_LEVEL (WORK_TYPE_01);
	end;

	if TYPE = VOID_BT then
		VOP = CALL_VO;
	else	VOP = CALL_FUNCTION_VO;

	CXX_VALUE_NODE_PTR = V;
        CXX_VALUE_NODE.OP = VOP;

        call SET_VALUE_TYPE (WORK_TYPE_01);

	/* Count arguments and compare with formal params */

	K = CHECK_ARGUMENTS (V, KN, K2, VICTIM);
	CXX_VALUE_NODE_PTR = V;
	RIGHT = CXX_VALUE_NODE.RIGHT;

	/*
        /* If this is a direct function call, check for
	/* special functions and for possible in-lining.
	/**/

        if K2 ^= NULL_NID then do;
		call SET_SYM_NODE_R (K2);
		if ^SYM_NODE.IS_MEMBER &
		    ((SYM_NODE.EXTERNAL_LINKAGE &
		      (SYM_NODE.LINKAGE_KIND = byte (C_LINKAGE))) |
		     SYM_NODE.MAIN_FUNCTION |
		     SYM_NODE.ASM_FUNCTION |
		     SYM_NODE.COMPILATION_ASSERT_FUNCTION |
		     (SYM_NODE.NAME = PROFILE_MARK_NAME)) then do;
			K1 = 0;
			if (SYM_NODE.NAME = ALLOCA_NAME) |
			   (SYM_NODE.NAME = BUILTIN_ALLOCA_NAME) then do;
				/*
				/* If a procedure calls "alloca" then
				/* the current function needs a frame.
				/**/
				call SET_SYM_NODE_R (CURRENT_FUNCTION);
				call SET_BLOCK_NODE (SYM_NODE.VALUE);
				BLOCK_NODE.ALLOC_AUTO_USED = TRUE;
			end;
			else if SYM_NODE.NAME = SETJMP_NAME then do;
				/*
				/* If call to "setjmp" is made, then
				/* emit a special label after the call.
				/**/
				;
				VV = GET_VALUE_AND_EXPAND_L
				     (LABEL_VO, DECLARE_LABEL_VALUE (0));
				VV->CXX_VALUE_NODE.SETJMP = TRUE;
				call SET_SYM_NODE (CURRENT_FUNCTION);
				SYM_NODE.CONTAINS_CALL_TO_SETJMP = TRUE;
			end;
			else if SYM_NODE.MAIN_FUNCTION then do;
				if ^AM_DEBUGGER & SW_C_PLUS_PLUS then
					call SEMANTIC_ERROR (ERR_CALL_MAIN);
			end;
			else if SYM_NODE.ASM_FUNCTION then do;
				/*
				/* Here, we have a call to a special "asm"
				/* function.  Mark the CALL as well as the
				/* REF(asm-function), ADDR(REF(asm-function)),
				/* or VALUE(REF(asm-function)), and each of
				/* its ARGs as ASM; the VALUE/REF and the
				/* ARGs will *not* be emitted, rather a code
				/* representing the particular asm function
				/* and the expression to which the arguments
				/* refer will be put directly directly into
				/* the operator as operands.
				/**/ 
				CXX_VALUE_NODE.ASM = TRUE;
				CXX_VALUE_NODE_PTR = LEFT;
				CXX_VALUE_NODE.ASM = TRUE;
				if ^CXX_VALUE_NODE.LEFT_IS_NOT_VID &
				   (CXX_VALUE_NODE.LEFT ^= NULL_CXX_VID) then
					CXX_VALUE_NODE.LEFT->
						CXX_VALUE_NODE.ASM = TRUE;
				CXX_VALUE_NODE_PTR = V;
				do I = K to 1 by -1
				while (^CXX_VALUE_NODE.RIGHT_IS_NOT_VID &
				       (CXX_VALUE_NODE.RIGHT ^= NULL_CXX_VID));
					CXX_VALUE_NODE_PTR =
						CXX_VALUE_NODE.RIGHT;
					CXX_VALUE_NODE.ASM = TRUE;
				end;
			end;
			else if SYM_NODE.COMPILATION_ASSERT_FUNCTION then do;
				/*
				/* Here, we have a call to the special
				/* "void ____lpi_compilation_assert (int)"
				/* function.  Mark the CALL as well as the
				/* VALUE (REF (compilation-assert-function))
				/* and its ARG as COMPILATION_ASSERT; the
				/* VALUE/REF and the ARG will *not* be
				/* emitted, rather the expression to which
				/* the argument refers will be put directly
				/* into the operator as an operand.
				/**/ 
				CXX_VALUE_NODE.COMPILATION_ASSERT = TRUE;
				LEFT->CXX_VALUE_NODE.COMPILATION_ASSERT = TRUE;
				if ^LEFT->CXX_VALUE_NODE.LEFT_IS_NOT_VID &
				   (LEFT->CXX_VALUE_NODE.LEFT ^= NULL_CXX_VID)
				then
					CXX_VALUE_NODE.LEFT->
					CXX_VALUE_NODE.COMPILATION_ASSERT =
						TRUE;
				CXX_VALUE_NODE.RIGHT->
				CXX_VALUE_NODE.COMPILATION_ASSERT = TRUE;
			end;
			else if SYM_NODE.NAME = PROFILE_MARK_NAME then do;
				/*
				/* Here, we have a call to the profiling
				/* MARK function from <prof.h>.  Mark the
				/* CALL as well as the ADDR(REF(function)) 
				/* as ASM.
				/*
				/* The MARK macro from <prof.h> generates:
				/* will translate:
				/*   MARK(label);
				/* into:
				/*   {static long ____lpi_mark_label;
				/*   ____lpi_mark_label:
				/*   ____lpi_mark (____lpi_mark_label);}
				/* We change the ____lpi_mark_label label
				/* name to "M.label" (SET_LABEL_DEFINITION),
				/* and will change the ____lpi_mark_label
				/* data name to ".label" (below); we change
				/* the call to ____lpi_mark from:
				/*   CALL(ADDR(REF(____lpi_mark)),
				/*        ARG(VALUE(REF(____lpi_mark_label))))
				/* into:
				/*   CALL(ADDR(REF(____lpi_mark)),REF(.label))
				/* and finally (in emitv) into:
				/*   ASM(PROFILE_MARK_OP,REF(.label))
				/**/
				CXX_VALUE_NODE.ASM = TRUE;
				/* ADDR */
				CXX_VALUE_NODE_PTR = LEFT;
				CXX_VALUE_NODE.ASM = TRUE;
				/* REF */
				CXX_VALUE_NODE_PTR = CXX_VALUE_NODE.LEFT;
				CXX_VALUE_NODE.ASM = TRUE;
				/* profile mark function symbol */
				call SET_SYM_NODE (CXX_VALUE_NODE.LEFT_NID);
				SYM_NODE.ASM_FUNCTION = TRUE;
				/* ARG */
				CXX_VALUE_NODE_PTR = V->CXX_VALUE_NODE.RIGHT;
				CXX_VALUE_NODE.ASM = TRUE;
				/* VALUE */
				CXX_VALUE_NODE_PTR = CXX_VALUE_NODE.LEFT;
				/* REF */
				CXX_VALUE_NODE_PTR = CXX_VALUE_NODE.LEFT;
				/* symbol */
				call SET_SYM_NODE_R (CXX_VALUE_NODE.LEFT_NID);
				SYM_NODE.NAME = 
					FORM_IDENTIFIER_TOKEN
					('.' ||
					 substr (TOKEN_NAME
						 (SYM_NODE.NAME), 14));
				/* 2nd ARG */
				CXX_VALUE_NODE_PTR = V->CXX_VALUE_NODE.RIGHT
						      ->CXX_VALUE_NODE.RIGHT;
				CXX_VALUE_NODE.ASM = TRUE;
			end;
			else	K1 = ANY_BIF (TOKEN_NAME (SYM_NODE.NAME));
			if K1 ^= 0 then do;
				/*
				/* Here, we found a "builtin" function,
				/* for which we can generate inline code.
				/**/
				call MAKE_BUILTIN_OPERATOR (V, K1, K);
				/*
				/* Re-expand the builtin VOP.
				/**/
				goto REEXPAND;
			end;
		end;
        end;

	if (SAVED_VOP = DOT_STAR_VO) & (KV2 ^= NULL_CXX_VID) then do;
		/* Discard the dot-star operation, but save its LEFT,
		/* as the object for the member function call.
		/**/
		call DETACH_COMMA (LEFT, KV1, T1);
		KV = CXX_VALUE_NODE.LEFT;
		call COUNT_UP_VALUE (KV);
		call COUNT_DOWN_VALUE (LEFT);
		LEFT = MEMBER_FUNCTION_CALL (KV2, KV, RIGHT, K, VICTIM);
		CXX_VALUE_NODE_PTR = LEFT;
		IS_DEST = (CXX_VALUE_NODE.OP = INTEGER_VO);
		OFFSET = CXX_VALUE_NODE.OFFSET;
		call REATTACH_COMMA (LEFT, KV1, T1);

		if IS_DEST then do;
			/* Trivial explicit destructor or assignment */
			call FIXUP_MEMBER_CALL (OFFSET, RIGHT, V);
			V = GET_VALUE_AND_EXPAND_LR (COMMA_VO, LEFT, V);
			V = VALUE_BEFORE_EFFECT (V, VICTIM);
			goto EXIT;
		end;
	end;
	else	call NOTE_SYMBOL_REFERENCE (K2);

	CXX_VALUE_NODE_PTR = V;
	CXX_VALUE_NODE.LEFT = LEFT;
	CXX_VALUE_NODE.RIGHT = RIGHT;
	if SAVED_VOP = DOT_STAR_VO then
		K = CHECK_ARG_SAVE (V);		/* arg count */
        CXX_VALUE_NODE.OFFSET = K;		/* Arg count for WRITOP */
        if RIGHT = NULL_CXX_VID then
            CXX_VALUE_NODE.UNARY = TRUE;
	V = VALUE_BEFORE_EFFECT (V, VICTIM);
	if VV ^= NULL_CXX_VID then
		V = VALUE_BEFORE_EFFECT (V, VV);
        goto EXIT;

CALL_ERROR:
        call COUNT_DOWN_VALUE (LEFT);
        call COUNT_DOWN_VALUE (RIGHT);
        goto RETURN_ZERO;

EXPAND(ARG_VO):

        /*
        LEFT is an argument value.
        RIGHT is next argument's ARG value or 0.

        Copy LEFT's type info to the ARG itself.        
        The actual conversions are handled at the site
        of the CALL_VO by ADJUST_ARG.
        */

	CXX_VALUE_NODE_PTR = LEFT;
        call GET_VALUE_TYPE (WORK_TYPE_01);
	CXX_VALUE_NODE_PTR = V;
        call SET_VALUE_TYPE (WORK_TYPE_01);
        CXX_VALUE_NODE.OP = VOP;
        CXX_VALUE_NODE.LEFT = LEFT;
        CXX_VALUE_NODE.UNARY = TRUE;
        goto EXIT;


EXPAND(ARG_REF_VO):
	goto EXIT;

EXPAND(RETURN_VO):
EXPAND(IMPLICIT_RETURN_VO):

        /*
        /* LEFT is value to return or 0.
        /**/

	call SET_SCOPE_NODE_R (CURRENT_FUNCTION_SCOPE);
	K2 = SCOPE_NODE.OWNER;
	call SET_SYM_NODE_R (K2);
	IS_CONST = SYM_NODE.IS_CONSTRUCTOR_FUNCTION;
	IS_DEST = SYM_NODE.IS_DESTRUCTOR_FUNCTION;
	IS_MAIN = (SYM_NODE.NAME = MAIN_NAME) & ^SYM_NODE.IS_MEMBER;
	/*
	/* SYM_NODE.TYPE is the type of the function;
	/* put it into the value node and strip to the return type.
	/**/
	call SET_TYPE_NODE_R (SYM_NODE.TYPE);
	call GET_TYPE_NODE_TYPE (WORK_TYPE_01);
	WORK_TYPE_02 = WORK_TYPE_01;
	call STRIP_TOP_TYPE (WORK_TYPE_01, TRUE);

        if LEFT ^= NULL_CXX_VID then do;
		/*
		/* This is a return from a function.
		/**/
		if (WORK_TYPE_01.TOP_TYPE.CODE = byte (VOID_BT)) |
		   IS_CONST then do;
                        /*
			/* Error; this function can not return a value.
			/**/
			call SEMANTIC_ERROR_I
			     (ERR_NO_RET_VALUE,
			      FULL_QUALIFIED_SYMBOL_NAME (K2));
			LEFT = GET_VALUE_AND_EXPAND_L (NOP_VO, LEFT);
			TYPE = VOID_BT;
		end;
		else do;
			if WORK_TYPE_01.TOP_TYPE.CODE ^=
			   byte (REFERENCE_DT) then
				LEFT = VALUE_OF (LEFT);
			LEFT = GENERAL_CONVERT_VALUE (LEFT, WORK_TYPE_01, VOP);
			if WORK_TYPE_01.TOP_TYPE.CODE =
			   byte (REFERENCE_DT) then do;
				call STRIP_TOP_TYPE (WORK_TYPE_01, FALSE);
				call ADD_POINTER_LEVEL (WORK_TYPE_01);
				call SET_VALUE_TYPE (WORK_TYPE_01);
			end;
			TYPE = rank (CXX_VALUE_NODE.TOP_TYPE.CODE);
		end;
		KN = LOOKUP_RETURN_PARAMETER (K2);
		if KN ^= NULL_NID then do;
			KV = GET_REF_AND_EXPAND (KN);
			KV = GET_VALUE_AND_EXPAND_L (VALUE_VO, KV);
			KV = GET_VALUE_AND_EXPAND_L (STAR_VO, KV);
							/* yields VALUE (REF) */
			KV2 = CXX_VALUE_NODE.LEFT;	/* the REF */
			call COUNT_UP_VALUE (KV2);
			call COUNT_DOWN_VALUE (KV);
			LEFT = INITIALIZE_OBJECT (KV2, LEFT);
			TYPE = VOID_BT;
		end;
	end;
	else do;
		/*
		/* This is a return without an expression.
		/**/
		if (WORK_TYPE_01.TOP_TYPE.CODE ^= byte (VOID_BT)) &
		   ^IS_CONST & ^SW_CLASSIC_C_MODE then do;
			if VOP = RETURN_VO & ^SW_X_WARN_RETURN_VALUE then do;
	                        /*
				/* Error; return value required.
				/**/
        	                call SEMANTIC_ERROR (ERR_REQUIRES_RET_VALUE);
			end;
			else if ^IS_MAIN | SW_WARN_MAIN_NO_RETURN_VALUE then do;
				/*
				/* Warning; return value a good idea.
				/* But let's *not* give a warning for
				/* not returning a value from "main".
				/* And don't give a warning if the flag
				/* SW_NOWARN_NO_RETURN_VALUE (via -classicc)
				/* *and* the function was declared with a
				/* missing type specifier (i.e. implicit int).
				/**/
				IS_ERROR = FALSE;
				if ^SW_NOWARN_NO_RETURN_VALUE then
					IS_ERROR = TRUE;
				else if WORK_TYPE_01.
					TOP_TYPE.CODE ^= byte (INT_BT) then
					IS_ERROR = TRUE;
				else do;
					call SET_SYM_NODE_R (K2);
					if ^SYM_NODE.BASE_TYPE_UNSPECIFIED then
						IS_ERROR = TRUE;
				end;
				if ^IS_ERROR then
					;
				else if VOP = RETURN_VO then do;
					/* Explicit return */
					call SEMANTIC_ERROR_I
					     (ERR_NEEDS_RET_VALUE,
					      FULL_QUALIFIED_SYMBOL_NAME (K2));
				end;
				else if IS_MAIN then
					call SEMANTIC_ERROR
					     (ERR_MAIN_NO_RET_VALUE);
				else	call SEMANTIC_ERROR_I
					     (ERR_MIGHT_RET_NO_VALUE,
					      FULL_QUALIFIED_SYMBOL_NAME (K2));
			end;
		end;
		TYPE = VOID_BT;
	end;

	/*
	/* TYPE is VOID_BT if LEFT represents an effect to be performed
	/* prior to return and the RETURN_OP will have no operand.
	/**/

	VICTIM = DESTROY_DIFFERENCE (CURRENT_DESTRUCTORS (), NULL_CXX_VID);

	if TYPE ^= VOID_BT then do;
		CXX_VALUE_NODE_PTR = LEFT;
		CXX_VALUE_NODE.NOT_AN_LVALUE = TRUE;
		LEFT = VALUE_BEFORE_EFFECT (LEFT, VICTIM);
		LEFT = TRANSMUTE_WITH_TEMP (LEFT, VICTIM, FALSE, 
					    AUTO_ST, RETURN_VO);
		if VICTIM ^= NULL_CXX_VID then
			call COMPILER_ERROR (ERR_ASSERT_FAIL);
	end;
	else	LEFT = CONCATENATE_STATEMENTS (LEFT, VICTIM);

	/*
	/* A destructor, instead of returning directly, goes to a special
	/* label to destroy members and bases.
	/**/

	if IS_DEST then
		KN = LOOKUP_LABEL (DTOR_RETURN_LABEL_NAME,
				   CURRENT_FUNCTION_SCOPE);
	CXX_VALUE_NODE_PTR = V;
	call SET_VALUE_SIMPLE_TYPE (VOID_BT);

	if TYPE = VOID_BT then do;
		/* Return a void expr --> comma (expr, return) */
		if ^IS_DEST then do;
			if ^IS_MAIN | SW_DO_NOT_MAP_EXIT_TO_LPI_EXIT then do;
				V->CXX_VALUE_NODE.LEFT = NULL_CXX_VID;
				V->CXX_VALUE_NODE.NULARY = TRUE;
			end;
			else	V = CALL_TO_LPI_EXIT (NULL_CXX_VID);
		end;
		else do;
			V->CXX_VALUE_NODE.OP = BRANCH_VO;
			V->CXX_VALUE_NODE.LEFT_NID = KN;
			V->CXX_VALUE_NODE.LEFT_IS_NID = TRUE;
			V->CXX_VALUE_NODE.LEFT_IS_NOT_VID = TRUE;
			V = EXPAND_VALUE (V);
		end;
		V = CONCATENATE_STATEMENTS (LEFT, V);
		goto EXIT;
	end;
		
	if ^IS_MAIN | SW_DO_NOT_MAP_EXIT_TO_LPI_EXIT then do;
		V->CXX_VALUE_NODE.LEFT = LEFT;
		V->CXX_VALUE_NODE.UNARY = TRUE;
	end;
	else	V = CALL_TO_LPI_EXIT (LEFT);

        goto EXIT;

EXPAND(CONVERT_VO):

        /*
        Turn convert of OR_OR or AND_AND into a cast;
        Otherwise,
        Just set size information.
        */

        call GET_VALUE_TYPE (WORK_TYPE_01);
        call DETERMINE_SIZE (WORK_TYPE_01);
        call SET_VALUE_TYPE (WORK_TYPE_01);
        CXX_VALUE_NODE.UNARY = TRUE;

        if WORK_TYPE_01.TOP_TYPE.CODE = byte (INT_BT) then do;
		CXX_VALUE_NODE_PTR = LEFT;
                if (CXX_VALUE_NODE.OP = OR_OR_VO) |
		   (CXX_VALUE_NODE.OP = AND_AND_VO) then
			VOP = IMPLICIT_CAST_VO;
		CXX_VALUE_NODE_PTR = V;
                CXX_VALUE_NODE.OP = VOP;
	end;

        goto EXIT;

EXPAND(RANK_VO): ;
EXPAND(SRANK_VO): ;

        /*
        LEFT is a CHAR or UCHAR value.
        */

	CXX_VALUE_NODE_PTR = LEFT;

	if CXX_VALUE_NODE.TOP_TYPE.CODE = byte (ENUM_BT) then
		TYPE = GET_ENUM_INTEGRAL_TYPE (CXX_VALUE_NODE.TOP_TYPE);
	else	TYPE = rank (CXX_VALUE_NODE.TOP_TYPE.CODE);

        if (TYPE = CHAR_BT) | (TYPE = SCHAR_BT) then
		VOP = SRANK_VO;
	else	VOP = RANK_VO;

	CXX_VALUE_NODE_PTR = V;
        CXX_VALUE_NODE.OP = VOP;
        call SET_VALUE_SIMPLE_TYPE (SHORT_BT);
        CXX_VALUE_NODE.UNARY = TRUE;
        goto FOLD_AND_EXIT;
	
EXPAND(BYTE_VO): ;

        /*
        LEFT is should be an arithmetic value.
        TYPE is already set to UCHAR_BT or CHAR_BT.
        */

        call GET_VALUE_TYPE (WORK_TYPE_01);
        call DETERMINE_SIZE (WORK_TYPE_01);

        LEFT = CONVERT_VALUE (LEFT, SHORT_BT);

	CXX_VALUE_NODE_PTR = V;
        call SET_VALUE_TYPE (WORK_TYPE_02);
        V->CXX_VALUE_NODE.LEFT = LEFT;
        V->CXX_VALUE_NODE.UNARY = TRUE;
        goto FOLD_AND_EXIT;

EXPAND(CONVERT_UNITS_VO): ;

	goto EXIT;

EXPAND(FIELD_VO): ;

	KV1 = NULL_CXX_VID;

	CXX_VALUE_NODE_PTR = LEFT;

        if (CXX_VALUE_NODE.OP = COMMA_VO) & SW_STRICT_LVALUE then do;
		/*
                /* Special case constructed for ASSIGN to a bit field.
		/* Type on this COMMA is desired result type: the type
		/* declared for the field.  RIGHT is the integer value
		/* which was assigned to field but not yet converted to
		/* the dcl'd type.  This convert is postponed to now in
		/* case the "result" value of the assignment is never used.
		/* Size units of the COMMA has been set to BITS merely to
		/* send us here to do this convert after all.
                /**/
                call COUNT_UP_VALUE (LEFT); /* the COMMA */
		CXX_VALUE_NODE_PTR = CXX_VALUE_NODE.RIGHT; /* integer value */
                call GET_VALUE_TYPE (WORK_TYPE_01);
                RIGHT = ALLOC_CXX_VALUE_NODE_L (IMPLICIT_CAST_VO, LEFT);
		/* cast integer back to field (non-bit) */
                call SET_VALUE_TYPE (WORK_TYPE_01);
                CXX_VALUE_NODE.UNARY = TRUE;
                goto FINISH_FIELD; /* to do real convert to dcl'd type */
	end;
        else if (CXX_VALUE_NODE.OP = COMMA_VO) |
        	(CXX_VALUE_NODE.OP = LEFT_VALUE_VO) then do;
		KV = LEFT;
        	if CXX_VALUE_NODE.OP = COMMA_VO then do;
			KV1 = CXX_VALUE_NODE.LEFT;
			LEFT = CXX_VALUE_NODE.RIGHT;
		end;
		else do;
			KV1 = CXX_VALUE_NODE.RIGHT;
			LEFT = CXX_VALUE_NODE.LEFT;
		end;
		call COUNT_UP_VALUE (KV1);
		call COUNT_UP_VALUE (LEFT);
		call COUNT_DOWN_VALUE (KV);
		CXX_VALUE_NODE_PTR = LEFT;
	end;

        /* Here we have a VALUE (REF (bit-field-member)) */

        call GET_VALUE_TYPE (WORK_TYPE_01);
	IS_SIGNED = CXX_VALUE_NODE.SIGNED_BIT_FIELD;

        /* Pick up field info saved in VALUE from symbol (see DOT) */

	K	= CXX_VALUE_NODE.SIZE;
	OFFSET	= CXX_VALUE_NODE.OFFSET;
	K1	= CXX_VALUE_NODE.RIGHT_NID;
	K2	= CXX_VALUE_NODE.THIRD_NID;

	/* Change size-units of the LEFT from bits to whatever (non-bits) */

        call DETERMINE_SIZE (WORK_TYPE_01);

        /* Cast as a non-bit value */

        RIGHT = ALLOC_CXX_VALUE_NODE_L (IMPLICIT_CAST_VO, LEFT);
        call SET_VALUE_TYPE (WORK_TYPE_01);
        CXX_VALUE_NODE.UNARY = TRUE;

	/* Get declared type of the bit-field for final casting below */

	if (K1 ^= NULL_BT) & (K2 ^= NULL_NID) then do;
        	WORK_TYPE_01.TYPE = K2;
		call GET_TOP_TYPE (K2, WORK_TYPE_01.TOP_TYPE);
	end;

        /* Shift and mask field bits */

	if IS_SIGNED then do;
		/*
		/* If explicitly signed type, shift left until sign
		/* position hit; then shift right and drag sign bit.
		/* ACTUAL_SZ will be bits here.
		/**/
		if (RIGHT->CXX_VALUE_NODE.TOP_TYPE.CODE = byte (CHAR_BT)) |
		   (RIGHT->CXX_VALUE_NODE.TOP_TYPE.CODE = byte (SCHAR_BT)) then
			RIGHT = GET_VALUE_AND_EXPAND_L (SRANK_VO, RIGHT);
		if CXX_USE_LONG_OPERATIONS then do;
			K1 = INTEGRAL_PROMOTION
			     (rank (RIGHT->CXX_VALUE_NODE.TOP_TYPE.CODE));
			RIGHT = CONVERT_VALUE (RIGHT, K1);
		end;
		else	K1 = rank (RIGHT->CXX_VALUE_NODE.TOP_TYPE.CODE);
		call SIMPLE_TYPE_SIZE (K1, ACTUAL_SZ, THIS_SIZE_UNITS, BDRY);
		ACTUAL_SZ = ROUNDU (ACTUAL_SZ, BDRY, BITS);

		RIGHT = GET_VALUE_AND_EXPAND_LR
			(LSHIFT_VO,
			 RIGHT,
			 INTEGER_VALUE (ACTUAL_SZ - OFFSET - K, 0));
		RIGHT = CONVERT_VALUE (RIGHT, K1);
		RIGHT = GET_VALUE_AND_EXPAND_LR
			(RSHIFT_VO,
			 RIGHT,
			 INTEGER_VALUE (ACTUAL_SZ - K, 0));
        end;
        else do;
		/*
		/* Treat as both "int" and "unsigned int" alike;
		/* will be ANSI C, Classic C, and PCC compatible.
		/**/
		RIGHT = GET_VALUE_AND_EXPAND_LR
			(RSHIFT_VO,
			 RIGHT,
			 INTEGER_VALUE (OFFSET, 0));
		RIGHT = GET_VALUE_AND_EXPAND_LR
			(AND_VO,
			 RIGHT,
			 FIELD_MASK (K));
        end;

        /* Cast result as field's declared type */

        LEFT = ALLOC_CXX_VALUE_NODE (TYPE_VO);
        call SET_VALUE_TYPE (WORK_TYPE_01);
        LEFT = EXPAND_VALUE (LEFT);

FINISH_FIELD:
	if KV1 ^= NULL_CXX_VID then
		RIGHT = EFFECT_BEFORE_VALUE (KV1, RIGHT);
	CXX_VALUE_NODE_PTR = V;
        CXX_VALUE_NODE.OP = IMPLICIT_CAST_VO;
        CXX_VALUE_NODE.LEFT = LEFT;
        CXX_VALUE_NODE.RIGHT = RIGHT;
        goto REEXPAND;

EXPAND(BLOCK_END_VO):

	CXX_VALUE_NODE.NULARY = TRUE;

EXPAND(STMNT_ID_VO): ;
EXPAND(ENTRY_VO): ;
EXPAND(LABEL_VO): ;
EXPAND(BRANCH_SWITCH_VO):
EXPAND(EXIT_VO):

	call SET_VALUE_SIMPLE_TYPE (VOID_BT);
	goto EXIT;

EXPAND(PROCEDURE_VO):
EXPAND(ALTERNATE_VO):
EXPAND(BRANCH_VO):
EXPAND(BRANCH_SAVE_VO):

	CXX_VALUE_NODE.UNARY = TRUE;
	call SET_VALUE_SIMPLE_TYPE (VOID_BT);
	goto EXIT;

/* NOP_VO
/* Throw away the value returned by the operand expression, and return
/* the void value, of type VOID_BT instead.  Preserve the operand expression
/* for its side effects.  Usually, introduce a NOP_VO node into the expression
/* tree because the back end requires it.  If the expression is determined
/* to have no side-effects, throw away the entire expression and return
/* a NULL_CXX_VID (via RETURN_ZILCH).
/*
/* This is the same as converting to 'void' except that it occurs later
/* and is free to produce a NULL_CXX_VID.  Most expression processing assumes
/* that the operand expression is not NULL_CXX_VID.
/**/

EXPAND(NOP_VO):

	if CXX_VALUE_NODE.LEFT_IS_NID then do;
		if CXX_VALUE_NODE.LEFT_NID = NULL_NID then
			call COMPILER_ERROR (ERR_ASSERT_FAIL);
		goto RETURN_ZILCH;
	end;

	call COUNT_UP_VALUE (LEFT);
	call COUNT_DOWN_VALUE (V);

	LEFT = CONVERT_TO_VOID (LEFT);

	/*
	/* Call INITIALIZE_OBJECT with no object, just to
	/* clear up any UNINITIALIZED_VOs & CONDITIONAL_VOs
	/* in the expression tree.
	/**/

	V = INITIALIZE_OBJECT (NULL_CXX_VID, LEFT);
	goto EXIT;

EXPAND(PTR_VO):

        if ^EVALUATE_POINTER (LEFT, KN, OFFSET, OFFSET_UNITS) then
		LEFT = NULL_CXX_VID;
	else if KN ^= NULL_NID then do;
                call SET_SYM_NODE_R (KN);
                if ^ ( SYM_NODE.STORAGE_CLASS = byte (STATIC_ST)
		     | SYM_NODE.EXTERNAL_LINKAGE
		     | SYM_NODE.INTERNAL_LINKAGE
 		     ) then
			LEFT = NULL_CXX_VID;
	end;

        call COUNT_UP_VALUE (LEFT);
        call COUNT_DOWN_VALUE (V);
        V = LEFT;

        if V = NULL_CXX_VID then do;
		/*
                /* Error; this pointer-valued initial
		/* expression is not a constant.
		/**/
		call SEMANTIC_ERROR (ERR_NOT_CONST_PTR_EXPR);
	end;
	else	CXX_VALUE_NODE_PTR = V;

        goto EXIT;

EXPAND(INITIAL_VO):

        /* Page the symbol to initialize and set the initial_attribute */

	RIGHT_IS_VID = ^CXX_VALUE_NODE.RIGHT_IS_NOT_VID;
	RIGHT_IS_NID =  CXX_VALUE_NODE.RIGHT_IS_NID;

        call SET_SYM_NODE (LEFT_NID);	/* symbol */
        SYM_NODE.INITIAL_AT = TRUE;
	KN = LEFT_NID;

        /* Expand the Left and make a VAL-->REF. If Left is a union and 
        /*  Right is a temporary static data sym, then get token id of first
        /*  member and expand a Dot until the 1st member is non-union 
        /*  (i.e., assigning to first member). 
        /*
        /*  Note that initializing a union to an expression (RIGHT < 0) of 
        /*  compatible type is handled directly by EXPAND(ASSIGN_VO).
        /**/

        LEFT = GET_VALUE_REF_AND_EXPAND (LEFT_NID);   

	call GET_VALUE_TYPE (WORK_TYPE_01);

	K2 = NULL_NID;

	if WORK_TYPE_01.TOP_TYPE.CODE = byte (REFERENCE_DT) then do;
		/*
		/*  The variable being initialized is a REFERENCE type.
		/*  Call a utility to do semantic checks, and any unique
		/*  conversions that are necessary to convert the
		/*  RIGHT so that a reference to it can be taken.
		/**/
		CXX_VALUE_NODE_PTR = RIGHT;
		call GET_VALUE_TYPE (WORK_TYPE_02);
		/*
		/* See if the RIGHT is an aggregate type *now* rather
		/* than below because INIT_REF_CHECK may (will) change
		/* it to a pointer type.  This fixes:
		/*	union U { int x; };
		/*	main () { U x; U &y = x; }
		/**/
		if IS_AGGREGATE_TAG_TYPE
		   (rank (WORK_TYPE_02.TOP_TYPE.CODE)) then
			K2 = WORK_TYPE_02.TOP_TYPE.TAG_SYMBOL;
		/*
		/* Get the REF.
		/**/
		CXX_VALUE_NODE_PTR = LEFT->CXX_VALUE_NODE.LEFT;
		/*
		/* Pass the type of the sym-node as the 1st argument.
		/**/
		RIGHT = INIT_REF_CHECK (WORK_TYPE_01,
					RIGHT,
					VOP,
					0,
					LEFT->CXX_VALUE_NODE.LEFT->
					      CXX_VALUE_NODE.LEFT_NID,
					KV);
		call SET_SYM_NODE (LEFT_NID);
		/*
		/* Make the type of the target POINTER, instead of REFERENCE.
		/**/
		call STRIP_TOP_TYPE (WORK_TYPE_01, FALSE);
		call ADD_POINTER_LEVEL (WORK_TYPE_01);
		WORK_TYPE_01.NOT_AN_LVALUE = FALSE;
		CXX_VALUE_NODE_PTR = LEFT;
		call SET_VALUE_TYPE (WORK_TYPE_01);
	end;

        /* See if right is an expression of struct, union, or class type */

	if RIGHT_IS_VID & (RIGHT ^= NULL_CXX_VID) then do;
		RIGHT = VALUE_OF (RIGHT);
		CXX_VALUE_NODE_PTR = RIGHT;
		call GET_VALUE_TYPE (WORK_TYPE_02);
		CXX_VALUE_NODE_PTR = LEFT;
        end;
	else do;
		call SET_SYM_NODE_R (RIGHT_NID);
		call GET_SYMBOL_TYPE (WORK_TYPE_02);
		call SET_SYM_NODE_R (KN);
	end;

	if (K2 = NULL_NID) &
	   IS_AGGREGATE_TAG_TYPE (rank (WORK_TYPE_02.TOP_TYPE.CODE)) then
		K2 = WORK_TYPE_02.TAG_SYMBOL;

	/* Handle the initialization of a union object */

	call GET_SYMBOL_TYPE (WORK_TYPE_01);
	if (WORK_TYPE_01.TOP_TYPE.CODE = byte (UNION_BT)) then do;
		/*
		/* See if there is a user-conversion/constructor
		/* to convert the right hand side to the type of
		/* the union object on the left.
		/**/
		if RIGHT_IS_VID & (RIGHT ^= NULL_CXX_VID) then do;
			if QUIET_USER_CONVERSIONS
			   (WORK_TYPE_01.TYPE,
			    RIGHT, FALSE, FALSE, NULL_NID) ^= NULL_NID then
				goto DONE_INITIALIZING_UNION_MEMBER;
		end;
       		/*
       		/* If left symbol is union type, then may need to
       		/* track down first member for assignment below.
       		/**/
		do while ((WORK_TYPE_01.TOP_TYPE.CODE =
			   byte (UNION_BT)) &
			  (WORK_TYPE_01.TAG_SYMBOL ^= K2));
			call SET_SYM_NODE_R
			     (WORK_TYPE_01.TOP_TYPE.TAG_SYMBOL);
			KN = SYM_NODE.FIELD1;
			/* Expand ref to 1st member */
			KV = GET_SIMPLE_MEMBER_VALUE (KN);
			LEFT = MEMBER_OF_OBJECT (LEFT, KV);
			call SET_SYM_NODE_R (KN);
			call GET_SYMBOL_TYPE (WORK_TYPE_01);
		end;        
	end;

	DONE_INITIALIZING_UNION_MEMBER:

	/*
        /* For arrays, VAL (REF) was changed to ADDR (REF) 
	/* by EXPAND (VALUE_VO) but for the upcoming ASSIGN,
	/* we need to restore the original VALUE_VO.
	/**/

        if CXX_VALUE_NODE.OP = ADDR_VO then do;
		/*
		/* Oops! Got ADDR (REF)... on array.
                /* Also done below for right.
		/**/
		CXX_VALUE_NODE_PTR = CXX_VALUE_NODE.LEFT; /* REF */
		call GET_VALUE_TYPE (WORK_TYPE_01);
		CXX_VALUE_NODE_PTR = LEFT;		  /* ADDR */
		call SET_VALUE_TYPE (WORK_TYPE_01);	  /* Copy type-info */
		CXX_VALUE_NODE.OP = VALUE_VO;
		CXX_VALUE_NODE.UNARY = TRUE;
        end;

        /* Expand the right side (temp static or expression) */

	if RIGHT_IS_NID & (RIGHT_NID ^= NULL_NID) then do;
		/*
		/* This is a temporary static data sym for an auto aggregate.
		/**/
		RIGHT = GET_VALUE_REF_AND_EXPAND (RIGHT_NID);
		if CXX_VALUE_NODE.OP = ADDR_VO then do;
			/*
			/* Make a VALUE (REF) on array.
			/* See comments above.
			/**/
			CXX_VALUE_NODE_PTR = CXX_VALUE_NODE.LEFT;
			call GET_VALUE_TYPE (WORK_TYPE_01);
			CXX_VALUE_NODE_PTR = RIGHT;
			call SET_VALUE_TYPE (WORK_TYPE_01);
			CXX_VALUE_NODE.OP = VALUE_VO;
			CXX_VALUE_NODE.UNARY = TRUE;
		end;
        end;

        /* Change INITIAL_VO to COPY_VO and re-expand */

	CXX_VALUE_NODE_PTR = V;
        CXX_VALUE_NODE.OP = COPY_VO;
        CXX_VALUE_NODE.LEFT = LEFT;
        CXX_VALUE_NODE.LEFT_IS_NID = FALSE;
        CXX_VALUE_NODE.LEFT_IS_NOT_VID = FALSE;
        CXX_VALUE_NODE.RIGHT = RIGHT;
        goto REEXPAND;

/* ------------------------------------------------------------------------ 
/* The following are library functions which are expanded for the pur-      
/* pose of generating in-line code rather than library calls. The           
/* following are re-expanded from CALL_VOP when a builtin function name     
/* is detected; the original argument list as generated by the CALL is      
/* hung off the Left field (for one argument intrinsics), or the Left and   
/* Right fields (for two argument intrinsics).                              
/*                                                                          
/* Note: All operands originally went thru prototype checking; all operands 
/*       are ensured correct if no errors previously diagnosed.             
/* ------------------------------------------------------------------------ 
/*                                                                          
/* Ops for Math Intrinsics -                                                
/**/

EXPAND(ABS_VO):

        goto EXIT;

/* ------------------------------------------------------------------------ 
/*  The following math intrinsics all have the property of producing single 
/*  and double precision operations depending upon the operands. If each    
/*  argument is single precision rather than double precision, then it is   
/*  assumed that the single floating versions of the OP is desired for      
/*  "in-lining" rather than type double as the prototype states.            
/*
/*  Note that in the presence of prototyping, that a conversion of float->  
/*  double is usually performed, but this is circumvented earlier on
/*  (see CONVERT_ARGUMENT_TO_PROTOTYPE) to avoid a big hassle here.
/**/

EXPAND(ATAN2_VO):;         /* Two argument math intrinsics MUST go first ! */
EXPAND(FMOD_VO):;
EXPAND(POW_VO):

	/* Look at first second argument */

        if RIGHT->CXX_VALUE_NODE.TOP_TYPE.CODE ^= byte (FLOAT_BT) then
		goto EXIT;
                     
EXPAND(SQRT_VO):;                        /* One arg math intrinsics follow */
EXPAND(EXP_VO):;
EXPAND(LOG_VO):;
EXPAND(LOG10_VO):;
EXPAND(SIN_VO):;
EXPAND(COS_VO):;
EXPAND(TAN_VO):;
EXPAND(ASIN_VO):;
EXPAND(ACOS_VO):;
EXPAND(ATAN_VO):;
EXPAND(SINH_VO):;
EXPAND(COSH_VO):;
EXPAND(TANH_VO):;
EXPAND(CEIL_VO):;
EXPAND(FABS_VO):;
EXPAND(FLOOR_VO):;

	CXX_VALUE_NODE_PTR = LEFT;	/* Look at first 1st argument */
        TYPE = rank (CXX_VALUE_NODE.TOP_TYPE.CODE);                
        if TYPE = FLOAT_BT then do;
		/* Set type/size of result to FLOAT_BT */
		call GET_VALUE_TYPE (WORK_TYPE_01);
		CXX_VALUE_NODE_PTR = V;
		call SET_VALUE_TYPE (WORK_TYPE_01);
        end;
	CXX_VALUE_NODE_PTR = V;
        goto EXIT;

/* ------------------------------------------------------------------------ */
/*                                                                          */
/* Ops for String Minipulation Functions -                                  */
/*                                                                          */
/* Note: All operands originally went thru prototype checking; all operands */
/*       are ensured correct if no errors previously diagnosed.             */
/*                                                                          */

EXPAND(STRLEN_VO):;
EXPAND(STRCMP_VO):;
EXPAND(STRNCMP_VO):;
EXPAND(MEMCMP_VO):;

        goto EXIT;

EXPAND(STRCAT_VO):;
EXPAND(STRNCAT_VO):;
EXPAND(STRNCPY_VO):;
EXPAND(MEMCPY_VO):;

        /*
        /* Result of these string builtins is the first string argument. 
        /* Expand a COMMA Vop with its left being the string operation   
        /* and its right being the 1st argument to the builtin; result   
        /* of COMMA is its right.                                        
        /*
        /**/

	call SET_VALUE_SIMPLE_TYPE (VOID_BT); /* A non-value producing op */
        call COUNT_UP_VALUE (LEFT);
	V = GET_VALUE_AND_EXPAND_LR (COMMA_VO, V, LEFT); /* Expand COMMA */
        goto EXIT;

EXPAND(STRCPY_VO):;
	/*
        /* See comments above on COMMA op.
        /**/
	call SET_VALUE_SIMPLE_TYPE (VOID_BT); /* A non-value producing op */
        call COUNT_UP_VALUE (LEFT); 	      /* For the comma below */

	/*
        /* Detect strcpy with a constant string as its second arg, and
        /* an array as the 1st argument.
        /*
        /* In this case the ops are transformed into an array assign to
        /* trigger MOVER in the Back-End for more efficient code.
        /**/
        if (RIGHT->CXX_VALUE_NODE.OP = CAST_VO) |
           (RIGHT->CXX_VALUE_NODE.OP = IMPLICIT_CAST_VO) then
		CXX_VALUE_NODE_PTR = RIGHT->CXX_VALUE_NODE.LEFT;
	else	CXX_VALUE_NODE_PTR = RIGHT;
        if (CXX_VALUE_NODE.OP = ADDR_VO) &
	    CXX_VALUE_NODE.ARRAY_DESIGNATOR then do;
		KV2 = CXX_VALUE_NODE.LEFT; /* REF of the source operand */
		CXX_VALUE_NODE_PTR = KV2;
		call SET_SYM_NODE_R (CXX_VALUE_NODE.LEFT_NID);
		CXX_VALUE_NODE_PTR = LEFT;
		if  SYM_NODE.IS_DUMMY &
		   (SYM_NODE.TOP_TYPE.CODE = byte (ARRAY_DT)) &
		    CXX_VALUE_NODE.ARRAY_DESIGNATOR then do;
			/*
			/* The REF is to a string-literal
			/* and destination operand is array REF.
			/**/
			KV1 = CXX_VALUE_NODE.LEFT; /* REF */
			/* Save each REF */
			call COUNT_UP_VALUE (KV1);
			call COUNT_UP_VALUE (KV2);
			call COUNT_DOWN_VALUE (V);
			/*
			/* Deal with the source operand, 
			/* e.g. "abc", making a VALUE (REF("abc")).
			/**/
			KV2 = GET_VALUE_AND_EXPAND_L (VALUE_VO, KV2);
			/* Revert to VALUE_VO */
			CXX_VALUE_NODE.OP = VALUE_VO;
			CXX_VALUE_NODE_PTR = CXX_VALUE_NODE.LEFT; /* REF */
			call GET_VALUE_TYPE (WORK_TYPE_01); /* get size info */
			CXX_VALUE_NODE_PTR = KV2;
			call SET_VALUE_TYPE (WORK_TYPE_01);        
			/*
			/* Deal with the destination operand,
			/* eg. Addr-->ref
			/* fudging Value-->Ref(array)
			/* with size info from src
			/**/
			KV1 = GET_VALUE_AND_EXPAND_L (VALUE_VO, KV1);
			/* Revert to VALUE_VO */
			CXX_VALUE_NODE.OP = VALUE_VO;
			CXX_VALUE_NODE_PTR = CXX_VALUE_NODE.LEFT; /* REF */
			/* Fudge the source operand size */
			call SET_VALUE_TYPE (WORK_TYPE_01);
			CXX_VALUE_NODE_PTR = KV1; /* VALUE */
			/* Fudge the source operand size */
			call SET_VALUE_TYPE (WORK_TYPE_01);
			/* Assign array-->array */
			V = GET_VALUE_AND_EXPAND_LR
			    (IMPLICIT_ASSIGN_VO, KV1, KV2);
		end;
	end;

        /*
        /* Result of STRCPY is the first string argument, as above.
        /* Expand a COMMA Vop with its left being the string operation   
        /* and its right being the 1st argument to the builtin; result   
        /* of COMMA is its right.                                        
        /**/

	CXX_VALUE_NODE_PTR = V;
	/* strcpy(p1, p2) <comma> p1 */
        V = GET_VALUE_AND_EXPAND_LR (COMMA_VO, V, LEFT); 
        goto EXIT;

EXPAND(VA_STACK_VO):
	/*
	/* Target specific vops for "varargs":
	/*
	/* Varargs functionality for RISC architectures is tightly coupled
	/* between the macros defined in <stdarg.h> and the compiler itself;
	/* RISC architectures require that parameters (normally) passed in
	/* registers be saved in some architecture dependent way.  The LPI
	/* macros defined in <stdarg.h> are included below:
	/*
	/* SPARC:
	/*
	/* For SPARC, we only need one special builtin, VA_STACK_VO, which
	/* signals the back-end to dump all registers to the stack. It is
	/* currently used only on SPARC.
	/*
	/*	typedef char *va_list;
	/*	#define va_start(p,x)  (__va_stack__(), \
	/*				p = ((char *)(&x)) + sizeof(x))
	/*	#define va_arg(p,type) (((type *)(p += sizeof(type)))[-1])
	/*	#define va_end(p)
	/*
	/* N.B. pre-ANSI "varargs" functionality (i.e. va_alist, va_dcl) is
	/* not currently supported as it is in the LPI NEW-C compiler; we
	/* plan to support it soon, but in a different way -- instead of
	/* trying to work with the standard systema <varargs.h> include file,
	/* we will supply our own with equivalent functionility, then we will
	/* (hard) wire the preprocessor to never include the standard system
	/* version of <varargs.h> (or <stdarg.h>) even when compiling "-sys",
	/* but to only include our versions.
	/*
	/* 88K:
	/*
	/* For 88K, we need five special builtins VA_REG_VO, VA_MEM_VO,
	/* VA_OFFSET_VO, VA_REGTYP_VO, and VA_ALIGN_VO.
	/*
	/* N.B. Not yet implemented; see NEW-C for a full description
	/* and implementation.
	/**/

        /*
        /* Mark the symbol corresponding to the current function as having
	/* "varargs" usage.  This signals the back-end to dump all the
	/* registers.  This is gross, but the marker to the back-end
	/* for "varargs" usage is SYMBOL_NODE.SPECIFIC1.
        /**/
	call SET_SYM_NODE (CURRENT_FUNCTION);
        SYM_NODE.SPECIFIC1 = 1;
        call COUNT_DOWN_VALUE (V);
	V = INTEGER_VALUE_ZERO ();  /* Charlie MacCarthy */
        goto EXIT;

EXPAND(VA_ARG_VO):

	/*
	/* This operator is generated from the bif __va_arg__
	/* which is called to process a va_arg macro.  It is
	/* used only for SPARC, so far.
	/* The LEFT operand is a reference to va_list, i.e. 
	/* reference to char*, which has been processed as an
	/* argument and hence converted into a pointer to the
	/* va_list object.
	/* The RIGHT operand is an arbitrary expression of type
	/* pointer-to-T where T is the type of the argument.
	/* RIGHT gets counted down, not evaluated -- it is present
	/* only to provide type information.
	/*
	/* The result expression is an lvalue for the object of
	/* type T at the address originally pointed to by the va_list.
	/* A side effect of evaluating this expression is that the va_list
	/* object gets incremented so as to point to the next argument.
	/**/
	
	/* Determine the type of the argument */

	CXX_VALUE_NODE_PTR = RIGHT;
	call GET_VALUE_TYPE (WORK_TYPE_01);
	call STRIP_TOP_TYPE (WORK_TYPE_01, TRUE);
	
	call COUNT_DOWN_VALUE (RIGHT);
	CXX_VALUE_NODE_PTR = V;
	CXX_VALUE_NODE.RIGHT = NULL_CXX_VID;

	TID = DIRECT_TYPE_ID (WORK_TYPE_01);
	if BACK_END_TYPE_BY_REFERENCE (TID) then
		TYPE = STRUCT_BT;
	else	TYPE = INT_BT;

	/*
	/* First operand is expected to be an lvalue pointer object,
	/* i.e. object of type va_list which is a pointer.
	/* Argument processing changed the first operand into a pointer.
	/* Make into a reference.  Make it a reference to
	/* a pointer to either the argument type or a pointer type,
	/* depending on whether the argument type is an aggregate.
	/**/

	CXX_VALUE_NODE_PTR = LEFT;
	call GET_VALUE_TYPE (WORK_TYPE_02);

	if (CXX_VALUE_NODE.TYPE_CODE ^= byte (POINTER_DT)) |
	   WORK_TYPE_02.NOT_AN_LVALUE then do;
		call SEMANTIC_ERROR (ERR_VA_ARG_OPERAND);
		call COUNT_DOWN_VALUE (LEFT);
		/* Recover with indirect through uninitialized pointer */
		LEFT = ALLOC_CXX_VALUE_NODE (UNINITIALIZED_VO);
		CXX_VALUE_NODE.NULARY = TRUE;
		call SET_VALUE_SIMPLE_POINTER_TYPE (VOID_BT);
		call GET_VALUE_TYPE (WORK_TYPE_02);
		call ADD_POINTER_LEVEL (WORK_TYPE_02);
		call SET_VALUE_TYPE (WORK_TYPE_02);	/* (void **) */
		LEFT = GET_VALUE_AND_EXPAND_L (IMPLICIT_STAR_VO, LEFT);
	end;

	call ADD_POINTER_LEVEL (WORK_TYPE_01);
	if ^IS_SCALAR_TYPE (TYPE) then
		call ADD_POINTER_LEVEL (WORK_TYPE_01);
	LEFT = COPY_VALUE (LEFT);
	call SET_VALUE_TYPE (WORK_TYPE_01);
	CXX_VALUE_NODE.NOT_AN_LVALUE = FALSE;
	CXX_VALUE_NODE_PTR = V;
	CXX_VALUE_NODE.OP = POST_INC_VO;
	CXX_VALUE_NODE.LEFT = LEFT;
	V = EXPAND_VALUE (V);
		
	/*
	/* That bumps the pointer and returns its previous value;
	/* Dereference it; twice if type is aggregate.
	/**/
	call STRIP_TOP_TYPE (WORK_TYPE_01, TRUE);
	V = REF_WITH_LOCATOR (V, WORK_TYPE_01);
	V = PLAIN_VALUE_OF_REF (V);
	if ^IS_SCALAR_TYPE (TYPE) then do;
		call STRIP_TOP_TYPE (WORK_TYPE_01, TRUE);
		V = REF_WITH_LOCATOR (V, WORK_TYPE_01);
		V = PLAIN_VALUE_OF_REF(V);
	end;
	goto EXIT;

EXPAND(VA_START_VO):

	/*
	/* This operator is generated from the compiler built-in
	/* __va_start__ which is called to from the a va_start macro.
	/*
	/* The current function must have been declared
	/* as taking a variable number of arguments.
	/*
	/* The LEFT of V, if present, should be a REF-VALUE
	/* to the last parameter declared for the function.
	/*
	/* The result expression is a void pointer to
	/* a dummy last parameter which is added here.
	/**/

	if CURRENT_FUNCTION = NULL_NID then do;
		/*
		/* Error; the va_start macro may only be referenced
		/* from within a function which is declared to take
		/* a variable number of arguments.
		/**/
		call SEMANTIC_ERROR (ERR_VA_START_USE);
		goto RETURN_ZERO;
	end;

	/*
	/* Make sure this function was declared
	/* as taking a variable number of arguments.
	/**/

	call SET_SYM_NODE_R (CURRENT_FUNCTION);
	call SET_SIG_NODE_R (SYM_NODE.TOP_TYPE.SIGNATURE);

	if ^SIG_NODE.ELLIPSIS then do;
		/*
		/* Error; the va_start macro may only be referenced
		/* from within a function which is declared to take
		/* a variable number of arguments.
		/**/
		call SEMANTIC_ERROR (ERR_VA_START_USE);
		goto RETURN_ZERO;
	end;

	/*
        /* Mark the current function as having "varargs" usage.
	/* This signals the back-end to dump all the registers;
	/* this is really only used for SPARC but does no harm
	/* to just set it in general.  This is gross, but the
	/* mark is made by setting SYM_NODE.SPECIFIC1 to 1.
        /**/

	call SET_SYM_NODE (CURRENT_FUNCTION);

        SYM_NODE.SPECIFIC1 = 1;

	/* Mark this function as being non-inline-able */

	SYM_NODE.DO_NOT_INLINE = TRUE;

	/*
	/* Construct the back-end specific parameter link-node list
	/* and hang it off (of FIELD1 in) the function's sym-node.
	/* A dummy last parameter will also be added and ID2 will
	/* be set to its sym-node id.  ID1 will be set to the sym-node
	/* id of the last explicitly declared parameter before the
	/* ellipsis or NULL_NID if there is none.
	/*
	/* Note that in general, this back-end link-node parameter
	/* list is made in the front-end post-pass (CXXBE), but
	/* is made here for ellipsis function which use va_start.
	/**/

	call MAKE_BACK_END_PARAMETER_LIST (ID1, ID2);

	/* Determine the type of the argument */

	if LEFT ^= NULL_CXX_VID then do;
		/*
		/* Here, a second argument was given to the va_start macro.
		/* Make sure it is in fact the name of the last parameter
		/* of the function (i.e. if there is one).
		/**/
		if ID1 = NULL_NID then do;
			/*
			/* Error; there is no declared parameter
			/* before the ellipsis (e.g. f (...)).
			/**/
			call SEMANTIC_ERROR (ERR_VA_START_NO_PARAM);
			goto FINISH_VA_START_VO;
		end;
		IS_ERROR = FALSE;
		CXX_VALUE_NODE_PTR = V;
		if CXX_VALUE_NODE.LEFT ^= NULL_CXX_VID then do;
			CXX_VALUE_NODE_PTR = CXX_VALUE_NODE.LEFT;
			if (CXX_VALUE_NODE.OP = VALUE_VO) &
			   (CXX_VALUE_NODE.LEFT ^= NULL_CXX_VID) then do;
				CXX_VALUE_NODE_PTR = CXX_VALUE_NODE.LEFT;
				if (CXX_VALUE_NODE.OP ^= REF_VO) |
				   (CXX_VALUE_NODE.LEFT_NID ^= ID1) then
					IS_ERROR = TRUE;
			end;
			else if ((CXX_VALUE_NODE.OP = RANK_VO) |
				 (CXX_VALUE_NODE.OP = SRANK_VO) |
				 (CXX_VALUE_NODE.OP = CONVERT_VO)) &
				(CXX_VALUE_NODE.LEFT ^= NULL_CXX_VID) then do;
				CXX_VALUE_NODE_PTR = CXX_VALUE_NODE.LEFT;
				if (CXX_VALUE_NODE.OP = VALUE_VO) &
				   (CXX_VALUE_NODE.LEFT ^= NULL_CXX_VID)
				then do;
					CXX_VALUE_NODE_PTR =
						CXX_VALUE_NODE.LEFT;
					if (CXX_VALUE_NODE.OP ^= REF_VO) |
					   (CXX_VALUE_NODE.LEFT_NID ^= ID1)
					then IS_ERROR = TRUE;
				end;
			end;
			else if (CXX_VALUE_NODE.OP = COMMA_VO) &
				(CXX_VALUE_NODE.LEFT ^= NULL_CXX_VID) then do;
				/*
				/* Check for special case of class/struct/union
				/* type; this produces weird tree with temps.
				/**/
				CXX_VALUE_NODE_PTR = CXX_VALUE_NODE.LEFT;
				if (CXX_VALUE_NODE.OP = ASSIGN_VO) &
				   (CXX_VALUE_NODE.RIGHT ^= NULL_CXX_VID)
				then do;
				    CXX_VALUE_NODE_PTR = CXX_VALUE_NODE.RIGHT;
				    if (CXX_VALUE_NODE.OP = VALUE_VO) &
				       (CXX_VALUE_NODE.LEFT ^= NULL_CXX_VID)
				    then do;
					CXX_VALUE_NODE_PTR =
						CXX_VALUE_NODE.LEFT;
					if (CXX_VALUE_NODE.OP = REF_VO) &
					   (CXX_VALUE_NODE.THIRD ^=
					    NULL_CXX_VID) then do;
					    CXX_VALUE_NODE_PTR =
					        CXX_VALUE_NODE.THIRD;
					    if (CXX_VALUE_NODE.OP = VALUE_VO) &
					       (CXX_VALUE_NODE.LEFT ^=
						NULL_CXX_VID) then do;
						CXX_VALUE_NODE_PTR =
						    CXX_VALUE_NODE.LEFT;
						if (CXX_VALUE_NODE.OP =
						    REF_VO) &
						   (CXX_VALUE_NODE.LEFT_NID =
						    ID1)
						then do;
						    call SET_SYM_NODE_R (ID1);
						    if ^IS_AGGREGATE_TAG_TYPE
							(rank
							 (SYM_NODE.
							  TOP_TYPE.CODE))
						    then IS_ERROR = TRUE;
						end;
						else IS_ERROR = TRUE;
					    end;
					    else IS_ERROR = TRUE;
					end;
					else IS_ERROR = TRUE;
				    end;
				    else IS_ERROR = TRUE;
				end;
				else IS_ERROR = TRUE;
			end;
			else	IS_ERROR = TRUE;
		end;
		else IS_ERROR = TRUE;
		if IS_ERROR then do;
			/*
			/* Error; the second argument to va_start must be
			/* the name of the last declared parameter before
			/* the ellipsis; in addition, as an extension, the
			/* second argument to va_start need not be given.
			/**/
			call SEMANTIC_ERROR_I (ERR_VA_START_BAD_SECOND_ARG,
					       SYMBOL_NAME (ID1));
		end;
		else	call COUNT_DOWN_VALUE (V);
	end;
	else do;
		/*
		/* Here, the second argument of va_start was
		/* not given; support for this is an extension.
		/**/
		if ^SW_ALLOW_NULL_VA_START_ARG then
			call SEMANTIC_ERROR (ERR_VA_START_NULL_SECOND_ARG);
	end;

	FINISH_VA_START_VO:
	V = GET_VALUE_REF_AND_EXPAND (ID2);
	V = GET_VALUE_AND_EXPAND_L (IMPLICIT_ADDR_VO, V);
	V = CAST_TO_SIMPLE_POINTER (V, VOID_BT);
	goto EXIT;

EXPAND(SWITCH_VO):

        call COUNT_UP_VALUE (LEFT);     /* Page/ Up count for discard below */

	LEFT = VALUE_OF (LEFT);		/* DGM 081 */
	LEFT = CHECK_USER_CONVERSION (LEFT, INTONLY_TK, NULL_NID);

	if ^IS_INTEGRAL_TYPE (rank (CXX_VALUE_NODE.TOP_TYPE.CODE)) then
		call SEMANTIC_ERROR (ERR_INT_IS_REQD);

        LEFT = CHECK_INTEGER (LEFT);	/* Convert to integral type */
        call COUNT_DOWN_VALUE (V);	/* Discard the switch */
        V = LEFT;			/* Result is its operand */
	CXX_VALUE_NODE_PTR = V;
        goto EXIT;
  
EXPAND(NEW_VO):
	/*
	/* LEFT  is the symbol node of the 'new' function to be
	/* 	 invoked (scope resolved but not overloading).
	/* RIGHT is the placement argument list.
	/* V	 has its type set with the type of the new object,
	/* THIRD is the initializer.
	/**/

	call GET_VALUE_TYPE (WORK_TYPE_01);
	TYPE = rank (WORK_TYPE_01.TOP_TYPE.CODE);
	TID = DIRECT_TYPE_ID (WORK_TYPE_01);
	if (TYPE = FUNCTION_DT) | (TYPE = REFERENCE_DT) then do;
		/*
		/* Error; type with "new" must be an object type.
		/**/
		if TYPE = FUNCTION_DT then
			call SEMANTIC_ERROR (ERR_NEW_FUNCTION);
		else	call SEMANTIC_ERROR (ERR_NEW_REFERENCE);
		call COUNT_DOWN_VALUE (RIGHT);
		call COUNT_DOWN_VALUE (THIRD);
		CXX_VALUE_NODE.THIRD = NULL_CXX_VID;
		goto RETURN_ZERO;
	end;
	else begin;
		declare
			IS_ARRAY	type (BOOL_T),
			HAS_DTOR	type (BOOL_T),
			DP		pointer,
			NEW_ARGS	type (CXX_VID_T),
			NEW_SYM		type (NID_T),
			INITIALIZER	type (CXX_VID_T),
			COUNT		type (CXX_VID_T),
			DIM_VALUE	type (CXX_VID_T),
			SIZE_VAL	type (CXX_VID_T),
			SIZE_T_INFO	type (TYPE_INFO_T),
			TYPE		type (SHORT_T),
			NEW_TEMP	type (CXX_VID_T),
			NEW_TEMP_INITTER
					type (CXX_VID_T);

		/*
		/* Get information out of the value node and nullify
		/* its operands in case it gets used later.
		/**/

		TYPE = rank (WORK_TYPE_01.TOP_TYPE.CODE);
		IS_ARRAY = (TYPE = ARRAY_DT);
		HAS_DTOR = HAS_DESTRUCTOR (TID);
		NEW_ARGS = CXX_VALUE_NODE.RIGHT;
		NEW_SYM = CXX_VALUE_NODE.LEFT_NID;
		INITIALIZER = CXX_VALUE_NODE.THIRD;
		CXX_VALUE_NODE.RIGHT = NULL_CXX_VID;
		CXX_VALUE_NODE.LEFT = NULL_CXX_VID;
		CXX_VALUE_NODE.LEFT_IS_NID = FALSE;
		CXX_VALUE_NODE.LEFT_IS_NOT_VID = FALSE;
		CXX_VALUE_NODE.THIRD = NULL_CXX_VID;

		/* Find DIM_VALUE, if run-time array dimension */

		DIM_VALUE = NULL_CXX_VID;
		if IS_ARRAY then do;
			call GET_DIM_NODE_R (WORK_TYPE_01.DIMENSION, DP);
			if DP->DIM_NODE.INCOMPLETE &
			   (DP->DIM_NODE.VALUE_ID ^= NULL_CXX_VID) then do;
				DIM_VALUE = DP->DIM_NODE.VALUE_ID;
				call COUNT_UP_VALUE (DIM_VALUE);
			end;
			call RELEASE_DIM_NODE (WORK_TYPE_01.DIMENSION);
		end;

		/* Get an expression for the size of the object */

		WORK_TYPE_02 = WORK_TYPE_01;
		if DIM_VALUE ^= NULL_CXX_VID then
			call STRIP_TOP_TYPE (WORK_TYPE_02, TRUE);
		else	call DETERMINE_SIZE (WORK_TYPE_02);
		
		if (WORK_TYPE_02.SIZE_UNITS = 0) |
		   (WORK_TYPE_02.SIZE = 0) then do;
			/*
			/* Zero or unknown sized object
			/**/
			call SEMANTIC_ERROR (ERR_NEW_INCOMPLETE);
			THIS_SIZE = 1;
		end;
		else do;
			THIS_SIZE = WORK_TYPE_02.SIZE;
			if WORK_TYPE_02.SIZE_UNITS ^= ADDRESS_UNITS then
				THIS_SIZE = ROUNDU (THIS_SIZE,
						    WORK_TYPE_02.SIZE_UNITS,
						    ADDRESS_UNITS);
		end;
		SIZE_VAL = INTEGER_VALUE (THIS_SIZE, LONG_BT);
		if DIM_VALUE ^= NULL_CXX_VID then
			SIZE_VAL = GET_VALUE_AND_EXPAND_LR
				   (MUL_VO, DIM_VALUE, SIZE_VAL);

		/* Add the size of a size_t to hold the count */

		THIS_SIZE = 0;
		if IS_ARRAY & HAS_DTOR then do;
			call TYPE_SIZE (GET_SIZET_TYPE (), THIS_SIZE, 
					THIS_SIZE_UNITS, BDRY);
			if THIS_SIZE_UNITS ^= ADDRESS_UNITS then
				THIS_SIZE = ROUNDU (THIS_SIZE, 
						    THIS_SIZE_UNITS, 
						    ADDRESS_UNITS);
			SIZE_VAL = GET_VALUE_AND_EXPAND_LR
				   (ADD_VO,
				    SIZE_VAL,
				    INTEGER_VALUE (THIS_SIZE, 0));
		end;

		/* Prepend the object size to the "placement" argument list */

		NEW_ARGS = GET_VALUE_AND_EXPAND_LR
			   (ARG_VO, SIZE_VAL, NEW_ARGS);
		
		/* Overload resolution for NEW_SYM with NEW_ARGS */

		NEW_SYM = OVERLOAD (NEW_ARGS, NEW_SYM, NULL_NID, NEW_VO);

		if NEW_SYM = NULL_NID then do;
			/*
			/* Error; placement arguments don't
			/* match a declared "new".
			/**/
			call SEMANTIC_ERROR (ERR_NEW_NO_MATCH);
			call COUNT_DOWN_VALUE (NEW_ARGS);
			call COUNT_DOWN_VALUE (INITIALIZER);
			/* Result is a null pointer */
			CXX_VALUE_NODE_PTR = V;
			CXX_VALUE_NODE.TOP_TYPE.CODE = byte (NULL_BT);
			goto RETURN_ZERO;
		end;

		/* Generate KV, the expression to call "new" */

		KV = GET_VALUE_REF_AND_EXPAND (NEW_SYM);
		KV = GET_VALUE_AND_EXPAND_LR (CALL_FUNCTION_VO, KV, NEW_ARGS);
		call GET_VALUE_TYPE (WORK_TYPE_02);

		/* If it's an array with destructors, store the
		/* number of elements in the top rank into a size_t at the
		/* beginning of the allocated space, and bump the pointer by
		/* size of the size_t.  The expression for this is 
		/* KV ? (*KV = #elts), KV+sizeof (size_t)) : 0
		/**/

		if IS_ARRAY & HAS_DTOR then do;
			/*
			/* One more use of KV.
			/**/
			call COUNT_UP_VALUE (KV);
			call GET_DIM_NODE_R (WORK_TYPE_01.DIMENSION, DP);
			if DP->DIM_NODE.INCOMPLETE then do;
				COUNT = DP->DIM_NODE.VALUE_ID;
				call COUNT_UP_VALUE (COUNT);
			end;
			else	COUNT = INTEGER_VALUE (DP->DIM_NODE.VALUE, 0);
			call RELEASE_DIM_NODE (WORK_TYPE_01.DIMENSION);
			/*
			/* Express the lvalue of an object of type size_t
			/* at the location pointed to by TEMP.
			/**/
			call SET_TYPE_NODE_R (GET_SIZET_TYPE ());
			call GET_TYPE_NODE_TYPE (SIZE_T_INFO);
			call DETERMINE_SIZE (SIZE_T_INFO);
			KV1 = REF_WITH_LOCATOR (KV, SIZE_T_INFO);
			call COUNT_UP_VALUE (KV1);
			KV2 = KV1;
			KV1 = GET_VALUE_AND_EXPAND_L (VALUE_VO, KV1);
			/*
			/* Assignment of #elems to the size_t object.
			/**/
			KV1 = GET_VALUE_AND_EXPAND_LR (COPY_VO, KV1, COUNT);
			/*
			/* Non-zero case, Bumped location for the object.
			/**/
			call STRIP_TOP_TYPE (WORK_TYPE_02, FALSE); /* to void */
			KV2 = REF_PLUS_OFFSET (KV2, THIS_SIZE, ADDRESS_UNITS, 
							       WORK_TYPE_02);
			KV2 = GET_VALUE_AND_EXPAND_L (VALUE_VO, KV2);
			KV2 = GET_VALUE_AND_EXPAND_L (ADDR_VO, KV2);
			KV1 = EFFECT_BEFORE_VALUE (KV1, KV2);
			/*
			/* Form an appropriate null pointer.
			/**/
			KV2 = INTEGER_VALUE_ZERO ();
			call ADD_POINTER_LEVEL (WORK_TYPE_02);
			KV2 = CONVERT_TO_POINTER_VALUE (KV2, WORK_TYPE_02,
							IMPLICIT_CAST_VO);
			/* KV ? KV1 : KV2 */
			KV1 = GET_VALUE_AND_EXPAND_LR (COLON_VO, KV1, KV2);
			KV = GET_VALUE_AND_EXPAND_LR (CONDITIONAL_VO, KV, KV1);
		end;
					
		WORK_TYPE_02 = WORK_TYPE_01;
		if IS_ARRAY then
			call STRIP_TOP_TYPE (WORK_TYPE_02, FALSE);
		call ADD_POINTER_LEVEL (WORK_TYPE_02);
		KV = CONVERT_TO_POINTER_VALUE (KV, WORK_TYPE_02, 
					       IMPLICIT_CAST_VO);
		/*
		/* KV will get used a lot more.
		/* Make a temp, to avoid bad IL.
		/*  (1)  conditional test
		/*  (2)  true initialization
		/*  (3)  result
		/**/
		NEW_TEMP = GET_TEMP_VALUE (WORK_TYPE_02, AUTO_ST, FALSE);
		call COUNT_UP_VALUE (NEW_TEMP);
		KV1 = GET_TEMP_REF (NEW_TEMP);
		NEW_TEMP_INITTER = INITIALIZE_OBJECT (KV1, KV);

		/* Get a ref to the dynamically-allocated object */
		call COUNT_UP_VALUE (NEW_TEMP);
		KV = GET_TEMP_REF (NEW_TEMP);
		KV = GET_VALUE_AND_EXPAND_L (VALUE_VO, KV);
		call DETERMINE_SIZE (WORK_TYPE_01);
		KV2 = REF_WITH_LOCATOR (KV, WORK_TYPE_01);

		/*
		/* Result is
		/* (NEW_TEMP ? initialize KV2 : void), NEW_TEMP
		/* which would violate IL rules if it didn't employ a temp.
		/**/
		KV1 = GET_CONSTRUCTOR_VALUE (TID, INITIALIZER, NULL_NID, VOP);
		call COUNT_DOWN_VALUE (DIM_VALUE);
		KV1 = INITIALIZE_OBJECT (KV2, KV1);
		/* left of COLON must accept transmutation */
		KV1 = EFFECT_BEFORE_VALUE
		      (KV1,
		       GET_CONSTRUCTOR_VALUE (GET_VOID_TYPE (),
					      NULL_CXX_VID,
					      NULL_NID,
					      IMPLICIT_CAST_VO));

		/* Form an trivial void */
		KV2 = GET_CONSTRUCTOR_VALUE (GET_VOID_TYPE (),
					     NULL_CXX_VID,
					     NULL_NID,
					     IMPLICIT_CAST_VO);

		KV1 = GET_VALUE_AND_EXPAND_LR (COLON_VO, KV1, KV2);
		call COUNT_UP_VALUE (NEW_TEMP);
		KV = GET_TEMP_REF (NEW_TEMP);
		KV = GET_VALUE_AND_EXPAND_L (VALUE_VO, KV);
		KV1 = GET_VALUE_AND_EXPAND_LR (CONDITIONAL_VO, KV, KV1);

		KV1 = EFFECT_BEFORE_VALUE (NEW_TEMP_INITTER, KV1);
		KV = GET_TEMP_REF (NEW_TEMP);
		KV = GET_VALUE_AND_EXPAND_L (VALUE_VO, KV);

		CXX_VALUE_NODE_PTR = V;
		CXX_VALUE_NODE.OP = COMMA_VO;
		CXX_VALUE_NODE.LEFT = KV1;
		CXX_VALUE_NODE.RIGHT = KV;
		goto REEXPAND;
	end;

EXPAND(DELETE_VO): ;

	/*
	/* LEFT is the symbol node of the 'delete' function to be
	/* 	invoked (scope resolved but not overloading).
	/*	It's NULL_NID when 'delete' is to be bound at run-time,
	/*	i.e. when object is a class w/dtor.
	/* RIGHT is > 0 if there was no dimension,
	/* 	    = 0 (NULL_CXX_VID) if the dimension was '[]',
	/*	    < 0 the actual dimension expression.
	/* THIRD is the pointer expression to the object being deleted.
	/**/

	/*
	/* Nullify operands of value node because
	/* it's expected to be recycled later.
	/**/

	RIGHT_IS_VID = ^CXX_VALUE_NODE.RIGHT_IS_NOT_VID;

	CXX_VALUE_NODE.LEFT = NULL_CXX_VID;
	CXX_VALUE_NODE.LEFT_IS_NID = FALSE;
	CXX_VALUE_NODE.LEFT_IS_NOT_VID = FALSE;
	CXX_VALUE_NODE.RIGHT = NULL_CXX_VID;
	CXX_VALUE_NODE.RIGHT_IS_NID = FALSE;
	CXX_VALUE_NODE.RIGHT_IS_NOT_VID = FALSE;
	CXX_VALUE_NODE.THIRD = NULL_CXX_VID;
 
	THIRD = VALUE_OF (THIRD);
	if SW_C_PLUS_PLUS then do;
		/*
		/* Check for user conversions.
		/**/
		THIRD = CHECK_USER_CONVERSION (THIRD, POINTER_TK, NULL_NID);
	end;

	call GET_VALUE_TYPE (WORK_TYPE_01);
	TYPE = rank (WORK_TYPE_01.TOP_TYPE.CODE);
	if TYPE ^= POINTER_DT then do;
		call SEMANTIC_ERROR (ERR_DELETE_NON_POINTER);
		call COUNT_DOWN_VALUE (RIGHT);
		call COUNT_DOWN_VALUE (THIRD);
		goto RETURN_VOID;
	end;
	call STRIP_TOP_TYPE (WORK_TYPE_01, FALSE);
	TYPE = rank (WORK_TYPE_01.TOP_TYPE.CODE);
	TID = DIRECT_TYPE_ID (WORK_TYPE_01);
	if WORK_TYPE_01.TOP_TYPE.QUALIFIERS & CONST_TQ then do;
		call SEMANTIC_ERROR (ERR_DELETE_CONST);
		call COUNT_DOWN_VALUE (RIGHT);
		call COUNT_DOWN_VALUE (THIRD);
		goto RETURN_VOID;
	end;
	else if (TYPE = FUNCTION_DT) | (TYPE = REFERENCE_DT) then do;
		/*
		/* Error; type with "delete" must be an object type.
		/**/
		if TYPE = FUNCTION_DT then
			call SEMANTIC_ERROR (ERR_DELETE_FUNCTION);
		else	call SEMANTIC_ERROR (ERR_DELETE_REFERENCE);
		call COUNT_DOWN_VALUE (RIGHT);
		call COUNT_DOWN_VALUE (THIRD);
		goto RETURN_VOID;
	end;
	else begin;
		declare
			IS_ARRAY	type (BOOL_T),
			DIMENSION	type (CXX_VID_T),
			DELETE_SYM	type (NID_T),
			OBJECT_PTR	type (CXX_VID_T),
			DESTRUCTOR	type (NID_T),
			DP		pointer,
			SIZE_T_INFO	type (TYPE_INFO_T);

		/* Get information out of the value node */

		IS_ARRAY = RIGHT_IS_VID;
		if IS_ARRAY then
			DIMENSION = RIGHT;
		else	DIMENSION = NULL_CXX_VID;
		DESTRUCTOR = DESTRUCTOR_OF_TYPE (TID, 0);
		DELETE_SYM = LEFT_NID;
		OBJECT_PTR = THIRD;

		/* Bump OBJECT_PTR count for test in conditional */

		call COUNT_UP_VALUE (OBJECT_PTR);

		/* Check access to DESTRUCTOR */

		if DESTRUCTOR ^= NULL_NID then do;
			call GET_SYM_NODE_R (DESTRUCTOR, DP);
			if ^IS_ACCESSIBLE
			    (DESTRUCTOR,
			     DP->SYM_NODE.ENCLOSING_SCOPE_OWNER) then
				call SEMANTIC_ERROR_I
				     (ERR_PRIV_DTOR,
				      FULL_SYMBOL_NAME (DESTRUCTOR));
			call RELEASE_SYM_NODE (DESTRUCTOR);
		end;

		if ^IS_ARRAY | (DESTRUCTOR = NULL_NID) then do;
			KV = REF_WITH_LOCATOR (OBJECT_PTR, WORK_TYPE_01);
			KV = DESTROY_OBJECT (KV,
					     DIMENSION,
					     WORK_TYPE_01.TOP_TYPE,
					     TRUE,
					     DELETE_SYM);
		end;
		else do;
			/*
			/* An array w/destructor.  This is the tricky case,
			/* because the array is prepended in the dynamic
			/* storage with an element count.
			/*
			/* Make lvalue to beginning of
			/* dynamically-allocated storage. 
			/**/
			call COUNT_UP_VALUE (OBJECT_PTR);
			call SET_TYPE_NODE_R (GET_SIZET_TYPE ());
			call GET_TYPE_NODE_TYPE (SIZE_T_INFO);
			call DETERMINE_SIZE (SIZE_T_INFO);
			SIZE_T_INFO.NOT_AN_LVALUE = FALSE;
			KV1 = REF_PLUS_OFFSET
			      (REF_WITH_LOCATOR (OBJECT_PTR, SIZE_T_INFO),
			        -SIZE_T_INFO.SIZE,
				SIZE_T_INFO.SIZE_UNITS,
				SIZE_T_INFO);
			KV1 = GET_VALUE_AND_EXPAND_L (VALUE_VO, KV1);
			/*
			/* Destruction.
			/* Ignore the element count provided by the user,
			/* and use the count with which it was allocated.
			/**/
			if DIMENSION ^= NULL_CXX_VID then
				KV = GET_VALUE_AND_EXPAND_LR 
				     (COMMA_VO, DIMENSION, OBJECT_PTR);
			else	KV = OBJECT_PTR;
			call COUNT_UP_VALUE (KV1);
			KV = REF_WITH_LOCATOR (KV, WORK_TYPE_01);
			KV = DESTROY_OBJECT (KV,
					     KV1, 
					     WORK_TYPE_01.TOP_TYPE,
					     FALSE,
					     NULL_NID);
			/*
			/* Deletion.
			/* Form an argument that's the address of the object.
			/**/
			KV1 = GET_VALUE_AND_EXPAND_L (ADDR_VO, KV1);
			KV1 = GET_VALUE_AND_EXPAND_L (ARG_VO, KV1);
			/*
			/* Form call to the function delete.
			/**/
			KV2 = GET_VALUE_REF_AND_EXPAND (DELETE_SYM);
			KV2 = GET_VALUE_AND_EXPAND_LR
			      (CALL_FUNCTION_VO, KV2, KV1);
			/*
			/* Combine destructor with delete.
			/**/
			KV = CONCATENATE_STATEMENTS (KV, KV2);
		end;

		/* If the object pointer is an lvalue, 'zero' it out */

		CXX_VALUE_NODE_PTR = OBJECT_PTR;
		if (CXX_VALUE_NODE.OP = VALUE_VO) &
		   ^CXX_VALUE_NODE.NOT_AN_LVALUE &
		   ^CXX_VALUE_NODE.TOP_TYPE.CONST then do;
			call COUNT_UP_VALUE (OBJECT_PTR);
			KV2 = GET_VALUE_AND_EXPAND_LR
			      (ASSIGN_VO,
			       OBJECT_PTR,
			       INTEGER_VALUE_ZERO ());
			KV2 = CONVERT_TO_VOID (KV2);
			KV = EFFECT_BEFORE_VALUE (KV, KV2);
		end;

		/* Do something only if pointer is not null */

		KV = GET_VALUE_AND_EXPAND_LR
		     (COLON_VO,
		      KV,
		      GET_CONSTRUCTOR_VALUE (GET_VOID_TYPE (),
					     NULL_CXX_VID,
					     NULL_NID,
					     IMPLICIT_CAST_VO));
		CXX_VALUE_NODE_PTR = V;
		CXX_VALUE_NODE.OP = CONDITIONAL_VO;
		CXX_VALUE_NODE.LEFT = OBJECT_PTR;
		CXX_VALUE_NODE.RIGHT = KV;
		goto REEXPAND;
	end;
        
EXPAND(DBG_RANGE_VO):

	/* Generated by debugger only, e.g. EVAL x[1...3] */

	if RIGHT ^= NULL_CXX_VID then
		RIGHT = CHECK_INTEGER (RIGHT);

	if LEFT ^= NULL_CXX_VID then do;
		LEFT = CHECK_INTEGER (LEFT);
		CXX_VALUE_NODE_PTR = LEFT;
		call GET_VALUE_TYPE (WORK_TYPE_01);
		CXX_VALUE_NODE_PTR = V;
		call SET_VALUE_TYPE (WORK_TYPE_01);
	end;
	else if RIGHT ^= NULL_CXX_VID then do;
		CXX_VALUE_NODE_PTR = RIGHT;
		call GET_VALUE_TYPE (WORK_TYPE_01);
		CXX_VALUE_NODE_PTR = V;
		call SET_VALUE_TYPE (WORK_TYPE_01);
	end;
	else do;
		CXX_VALUE_NODE_PTR = V;
		call SET_VALUE_SIMPLE_TYPE (INT_BT);
	end;

	CXX_VALUE_NODE.NOT_AN_LVALUE = TRUE;
	goto EXIT;

/* ---------------------------------------------------------------------
/* CONVERT_RELATIONAL
/* ------------------------------------------------------------------- */

CONVERT_RELATIONAL: procedure internal;

	declare
		(T1, T2, T)	type (SHORT_T),
		(OP1, OP2)	type (SHORT_T);

        if AM_DEBUGGER then do;		/* no real FOLD_VALUE! */
		call CONVERT_COMMON ();
		return;
	end;

	LEFT = CONVERT_COMP (LEFT);
	T1 = rank (LEFT->CXX_VALUE_NODE.TOP_TYPE.CODE);
	OP1 = LEFT->CXX_VALUE_NODE.OP;

	RIGHT = CONVERT_COMP (RIGHT);
	T2 = rank (CXX_VALUE_NODE.TOP_TYPE.CODE);
	OP2 = RIGHT->CXX_VALUE_NODE.OP;

	if CXX_USE_LONG_OPERATIONS then do;
		if (T1 = LDOUBLE_BT) | (T2 = LDOUBLE_BT) |
		   (T1 = DOUBLE_BT)  | (T2 = DOUBLE_BT)  |
		   (T1 = FLOAT_BT)   | (T2 = FLOAT_BT)   then
			;
		else if (OP1 = INTEGER_VO) | (OP2 = INTEGER_VO) then do;
			/*
			/* Both types are "int" or smaller; FOLD_VALUE
			/* will decide on the best common type.
			/**/
			return;
		end;
		if T1 ^= T2 then
			call CONVERT_COMMON ();
	end;
	else do;
		if (T1 = LDOUBLE_BT) | (T2 = LDOUBLE_BT) then
			T = LDOUBLE_BT;
		else if (T1 = DOUBLE_BT) | (T2 = DOUBLE_BT) |
			(T1 = FLOAT_BT)  | (T2 = FLOAT_BT) then 
			T = DOUBLE_BT;
		else if (T1 = ULONG_BT) | (T2 = ULONG_BT) then
			T = ULONG_BT;
		else if (T1 = LONG_BT) | (T2 = LONG_BT) |
			(T1 = SLONG_BT) | (T2 = SLONG_BT) then
			T = LONG_BT;
		else if (T1 = UINT_BT) | (T2 = UINT_BT) then
			T = UINT_BT;
		else
			/*
			/* FOLD_VALUE will decide best common
			/* type (both types are INT or smaller).
			/**/
			return;

		if T1 ^= T then
			LEFT  = CONVERT_VALUE (LEFT, T);

		if T2 ^= T then
			RIGHT = CONVERT_VALUE (RIGHT, T);
	end;

	/*
	/* At this point, each has been converted to a common type.
	/* If "char", some architectures don't allow signed byte comparisons.
	/**/

	if ^CXX_ALLOWS_BYTE_COMPARES then do;
		if (LEFT->CXX_VALUE_NODE.TOP_TYPE.CODE = byte (CHAR_BT))  |
		   (LEFT->CXX_VALUE_NODE.TOP_TYPE.CODE = byte (SCHAR_BT))
		then do;
			LEFT  = CONVERT_VALUE (LEFT,  LONG_BT);
			RIGHT = CONVERT_VALUE (RIGHT, LONG_BT);
		end;
	end;

end CONVERT_RELATIONAL;

/* ---------------------------------------------------------------------
/* CONVERT_COMMON
/*
/* Performs the "usual arithmetic conversions".
/* See the Standard [X3J11/88-159:3.2.1.5].
/* ------------------------------------------------------------------- */

CONVERT_COMMON: procedure internal;

	declare
		(T1, T2, RT, SU, BDRY)	type (SHORT_T),
		(SZ_LONG, SZ_UINT)	type (LONG_T);

	LEFT = CONVERT_ARITH (LEFT);			/* ??? */
	T1 = rank (CXX_VALUE_NODE.TOP_TYPE.CODE);

	RIGHT = CONVERT_ARITH (RIGHT);			/* ??? */
	T2 = rank (CXX_VALUE_NODE.TOP_TYPE.CODE);

	if (T1 = LDOUBLE_BT) | (T2 = LDOUBLE_BT) then 
		RT = LDOUBLE_BT;
        else if (T1 = DOUBLE_BT) | (T2 = DOUBLE_BT) then 
		RT = DOUBLE_BT;
	else if (T1 = FLOAT_BT)  | (T2 = FLOAT_BT) then 
		RT = FLOAT_BT;
	else do;     
		T1 = INTEGRAL_PROMOTION (T1);
		T2 = INTEGRAL_PROMOTION (T2);
		if (T1 = ULONG_BT) | (T2 = ULONG_BT) then 
			RT = ULONG_BT;
		else do;
			if ((T1 = LONG_BT) & (T2 = UINT_BT)) |
			   ((T2 = LONG_BT) & (T1 = UINT_BT)) then do;
				call SIMPLE_TYPE_SIZE
				     (LONG_BT, SZ_LONG, SU, BDRY);
				SZ_LONG = ROUNDU (SZ_LONG, BDRY, BYTES);
				call SIMPLE_TYPE_SIZE
				     (UINT_BT, SZ_UINT, SU, BDRY);
				SZ_UINT = ROUNDU (SZ_UINT, BDRY, BYTES);
				if SZ_LONG > SZ_UINT then
					/*
					/* Only operand of UNIT_BT
					/* will be converted below
					/* else both will be converted.
					/**/
					RT = LONG_BT;
				else	RT = ULONG_BT;
			end;
			else if (T1 = LONG_BT) | (T2 = LONG_BT) then 
				RT = LONG_BT;
			else if (T1 = UINT_BT) | (T2 = UINT_BT) then 
				RT = UINT_BT;
			else	RT = INT_BT;
		end;
        end;

	if T1 ^= RT then LEFT  = CONVERT_VALUE (LEFT, RT);
	if T2 ^= RT then RIGHT = CONVERT_VALUE (RIGHT, RT);

	call GET_VALUE_TYPE (WORK_TYPE_01);
	CXX_VALUE_NODE_PTR = V;
	CXX_VALUE_NODE.LEFT = LEFT;
	CXX_VALUE_NODE.RIGHT = RIGHT;
	call SET_VALUE_TYPE (WORK_TYPE_01);

end CONVERT_COMMON;

/* ---------------------------------------------------------------------
/* CONVERT_ARITH
/* ------------------------------------------------------------------- */

CONVERT_ARITH: procedure (V) returns (type (CXX_VID_T)) internal;

	declare
		V		type (CXX_VID_T);
	declare
		RV        	type (CXX_VID_T),
		(IT, T)		type (SHORT_T);

	RV = CONVERT_COMP (V);

        T = rank (CXX_VALUE_NODE.TOP_TYPE.CODE);

	if SW_X_FLOAT_TO_DOUBLE & (T = FLOAT_BT) then  do;
		/*
		/* In old-style "K&R", extend all single
		/* floats extended to double precision.
		/**/
		RV = CONVERT_VALUE (RV, DOUBLE_BT);
	end;

	IT = INTEGRAL_PROMOTION (T);
	if IT ^= T then
		RV = CONVERT_VALUE (RV, IT);

        return (RV);

end CONVERT_ARITH;

/* ---------------------------------------------------------------------
/* CONVERT_COMP
/*
/* Converts the expression represented by the given value-node id V to
/* arithmetic type if it is not already of arithmetic type and returns
/* a value-node id representing the resultant expression.  This will
/* handle bit-fields and enumerators appropriately.  If the given
/* expression type is not of arithmetic type, then an attempt will
/* be made to convert it to type "int".  Trashes current-value-node.
/* ------------------------------------------------------------------- */

CONVERT_COMP: procedure (V) returns (type (CXX_VID_T)) internal;

	declare
		V	type (CXX_VID_T);
	declare
		NEW_V	type (CXX_VID_T);
 
	CXX_VALUE_NODE_PTR = V;

	if CXX_VALUE_NODE.SIZE_UNITS = byte (BITS) then
		NEW_V = GET_VALUE_AND_EXPAND_L (FIELD_VO, V);
	else	NEW_V = V;

	if CXX_VALUE_NODE.TOP_TYPE.CODE = byte (ENUM_BT) then do;
		return (CONVERT_VALUE
			(NEW_V,
			 GET_ENUM_INTEGRAL_TYPE (CXX_VALUE_NODE.TOP_TYPE)));
	end;
	else if CXX_VALUE_NODE.TOP_TYPE.CODE = byte (LOGICAL_BT) then
		return (CONVERT_VALUE (NEW_V, INT_BT));
	else if ^IS_ARITHMETIC_TYPE (rank (CXX_VALUE_NODE.TOP_TYPE.CODE)) then
		return (CONVERT_VALUE (NEW_V, INT_BT));
	else	return (NEW_V);

end CONVERT_COMP;

/* ---------------------------------------------------------------------
/* CHECK_INTEGER
/* ------------------------------------------------------------------- */

CHECK_INTEGER: procedure (V) returns (type (CXX_VID_T)) internal;

	declare
		V		type (CXX_VID_T);
	declare
		RV		type (CXX_VID_T),
		THIS_WORK_TYPE	type (TYPE_INFO_T);

        RV = CONVERT_ARITH (V);
        call GET_VALUE_TYPE (THIS_WORK_TYPE);

	if THIS_WORK_TYPE.TOP_TYPE.CODE = byte (ENUM_BT) then do;
		RV = CONVERT_VALUE
		     (RV, GET_ENUM_INTEGRAL_TYPE (THIS_WORK_TYPE.TOP_TYPE));
	end;
	else if ^IS_INTEGRAL_TYPE (rank (THIS_WORK_TYPE.TOP_TYPE.CODE)) then do;
                /*
		/* An integer value is required here.
		/**/
  		call SEMANTIC_ERROR (ERR_INT_IS_REQD);
		RV = CONVERT_VALUE (RV, INT_BT);
	end;
	return (RV);

end CHECK_INTEGER;

/* ---------------------------------------------------------------------
/* FIELD_MASK
/* ------------------------------------------------------------------- */

FIELD_MASK: procedure (K) returns (type (CXX_VID_T)) internal;

	declare
		K	type (SHORT_T);
	declare
		I	type (SHORT_T),
		M	type (LONG_T);

	if K < 32 then do;
		M = 0;
		do I = 1 to K; M = (M * 2) + 1; end;
	end;
	else	M = -1;

	return (INTEGER_VALUE (M, 0));

end FIELD_MASK;

/* ---------------------------------------------------------------------
/* NORMALIZE_BEFORE_INDEX
/* ------------------------------------------------------------------- */

NORMALIZE_BEFORE_INDEX: procedure (OPERATION) internal;

	declare OPERATION fixed binary (15);

        /*
	/* If OPERATION = ADD_VO then:
	/*
        /* LEFT or RIGHT is a pointer type,
	/* make sure the other is an integral type.
	/*
	/* If OPERATION = SUB_VO then:
	/*
	/* LEFT is a pointer type, 
	/* make sure the RIGHT is an integral type.
        /**/

	declare
		(J, K)		type (CXX_VID_T);
	declare 
		THIS_WORK_TYPE  type (TYPE_INFO_T);

	/* Get the pointer on the LEFT and the integer on the RIGHT */

	CXX_VALUE_NODE_PTR = LEFT;
	call GET_VALUE_TYPE (THIS_WORK_TYPE);

	if THIS_WORK_TYPE.TOP_TYPE.CODE ^= byte (POINTER_DT) then do;
		/* commute */
		K = LEFT;
		LEFT = RIGHT;
		RIGHT = K;
		CXX_VALUE_NODE_PTR = LEFT;
		call GET_VALUE_TYPE (THIS_WORK_TYPE);
		if THIS_WORK_TYPE.TOP_TYPE.CODE ^= byte (POINTER_DT) then do;
			/*
                        /* Error; neither of the operands
			/* of this [] is a pointer.
			/**/
			call COMPILER_ERROR (ERR_ASSERT_FAIL);
		end;
	end;

	/* Make sure that the RIGHT is an integral type */

	CXX_VALUE_NODE_PTR = RIGHT;
	call GET_VALUE_TYPE (THIS_WORK_TYPE);
	if ^IS_INTEGRAL_TYPE (rank (THIS_WORK_TYPE.TOP_TYPE.CODE)) then do;
		if OPERATION = ADD_VO then
			call SEMANTIC_ERROR (ERR_PTR_NONINT_ADD);
		else	call SEMANTIC_ERROR (ERR_PTR_NONINT_SUB);
	end;

	RIGHT = CHECK_INTEGER (RIGHT);

end NORMALIZE_BEFORE_INDEX;

/* ---------------------------------------------------------------------
/* INDEX_PTR
/* ------------------------------------------------------------------- */

INDEX_PTR: procedure internal;

	/*
	/* LEFT is a pointer type, 
	/* RIGHT is an integral type.
        /**/

	declare
		OFFSET		type (LONG_T),
		OFFU		type (SHORT_T),
		THIS_SIZE       type (LONG_T),
		(J, K)		type (CXX_VID_T),
		(VOP, VOP2)	type (SHORT_T);
	declare 
		THIS_WORK_TYPE  type (TYPE_INFO_T);

	CXX_VALUE_NODE_PTR = LEFT;
	call GET_VALUE_TYPE (THIS_WORK_TYPE);

	/* Save the LEFT for case where LEFT is ADDR below */

	K = LEFT->CXX_VALUE_NODE.LEFT;

	VOP = LEFT->CXX_VALUE_NODE.OP;

	/* Result is same type ptr as LEFT */

	CXX_VALUE_NODE_PTR = V;
	call SET_VALUE_TYPE (THIS_WORK_TYPE);

	call STRIP_TOP_TYPE (THIS_WORK_TYPE, TRUE); /* remove "*" (get size */
						    /* of thing pointed to) */
	if (THIS_WORK_TYPE.SIZE_UNITS = 0) | (THIS_WORK_TYPE.SIZE = 0) then do;
		/*
		/* Zero or unknown sized object for ptr+int or ptr-int.
		/**/
		call SEMANTIC_ERROR (ERR_BAD_PTR_INT_ARITH);
		THIS_SIZE = 1;
	end;
	else  do;
		THIS_SIZE = THIS_WORK_TYPE.SIZE;
		if THIS_WORK_TYPE.SIZE_UNITS ^= ADDRESS_UNITS then
			THIS_SIZE = ROUNDU (THIS_SIZE,
					    THIS_WORK_TYPE.SIZE_UNITS,
					    ADDRESS_UNITS);
	end;

        /* Produce an ADD [or SUB] */

	if THIS_SIZE ^= 1 then
		RIGHT = GET_VALUE_AND_EXPAND_LR
			(MUL_VO, RIGHT, INTEGER_VALUE (THIS_SIZE, 0));

	OFFSET = 0;

	CXX_VALUE_NODE_PTR = V;
	call GET_VALUE_TYPE (THIS_WORK_TYPE); /* get pointer type back */

	if VOP = ADDR_VO then do;
		CXX_VALUE_NODE_PTR = K;	/* REF */
		OFFSET = CXX_VALUE_NODE.OFFSET;
		OFFU = rank (CXX_VALUE_NODE.OFFSET_UNITS);
		if ^CXX_VALUE_NODE.THIRD_IS_NOT_VID &
		   (CXX_VALUE_NODE.THIRD ^= NULL_CXX_VID) then do;
			J = CXX_VALUE_NODE.THIRD;
			/*
			/* There must be NO Var on Locator.
			/* Also, CodeWatch might be needing the member
			/* symbol when displaying a value.
			/**/
			if CXX_VALUE_NODE.RIGHT = NULL_CXX_VID then do;
				    call COUNT_UP_VALUE (J);
				    call COUNT_DOWN_VALUE (LEFT);
				    LEFT = COPY_VALUE (J);
				    call SET_VALUE_TYPE (THIS_WORK_TYPE);
			end;
		end;
		else if OFFSET ^= 0 then do;
			call COUNT_UP_VALUE (K);	/* the REF */
			call COUNT_DOWN_VALUE (LEFT);	/* the ADDR */
			K = COPY_VALUE (K);		/* new REF */
			CXX_VALUE_NODE.OFFSET = 0;	/* w/o offset */
			LEFT = ALLOC_CXX_VALUE_NODE_L (ADDR_VO, K);
			call SET_VALUE_TYPE (THIS_WORK_TYPE);
		end;
	end;

	VOP = ADD_VO;

	CXX_VALUE_NODE_PTR = RIGHT;
	VOP2 = CXX_VALUE_NODE.OP;

	if VOP2 = MINUS_VO then do;
		K = CXX_VALUE_NODE.LEFT;
		call COUNT_UP_VALUE (K);
		call COUNT_DOWN_VALUE (RIGHT);
		RIGHT = K;
		VOP = SUB_VO;
		CXX_VALUE_NODE_PTR = RIGHT;
		VOP2 = CXX_VALUE_NODE.OP;
	end;

        if (VOP2 = ADD_VO) | (VOP2 = SUB_VO) then do;
		/*
                /* Reassociate:
                /* transform (p op (j op2 k))
                /* to        ((p op j) op2' k) 
                /* [don't expand "p op j"!]
                /**/
		J = CXX_VALUE_NODE.LEFT;
		K = CXX_VALUE_NODE.RIGHT;
		call COUNT_UP_VALUE (J);
		call COUNT_UP_VALUE (K);
		call COUNT_DOWN_VALUE (RIGHT);
		RIGHT = K;
		LEFT = ALLOC_CXX_VALUE_NODE_LR (VOP, LEFT, J);
		call SET_VALUE_TYPE (THIS_WORK_TYPE);
		if VOP2 = VOP then
			VOP = ADD_VO;
		else	VOP = SUB_VO;
	end;

	if OFFSET ^= 0 then do;
		if OFFU ^= ADDRESS_UNITS then
			OFFSET = ROUNDU (OFFSET, OFFU, ADDRESS_UNITS);
		CXX_VALUE_NODE_PTR = RIGHT;
		if CXX_VALUE_NODE.OP = INTEGER_VO then do;
			RIGHT = GET_VALUE_AND_EXPAND_LR
				(VOP, INTEGER_VALUE (OFFSET, 0), RIGHT);
		end;
		else do;
			LEFT = ALLOC_CXX_VALUE_NODE_LR (VOP, LEFT, RIGHT);
			call SET_VALUE_TYPE (THIS_WORK_TYPE);
			RIGHT = INTEGER_VALUE (OFFSET, 0);
		end;
		VOP = ADD_VO;
	end;

	CXX_VALUE_NODE_PTR = V;
	CXX_VALUE_NODE.OP = VOP;
	CXX_VALUE_NODE.LEFT = LEFT;
	CXX_VALUE_NODE.RIGHT = RIGHT;

end INDEX_PTR;

/* ---------------------------------------------------------------------
/* MUL_AND_ADD
/*
/* Transforms: (V + c1)*c2 ==> ( (V*c2) + c3 ) where c3 = c1*c2
/* ------------------------------------------------------------------- */

MUL_AND_ADD: procedure (V, SZ) returns (type (CXX_VID_T)) internal;
    
	declare
		V		type (CXX_VID_T),
        	SZ		type (LONG_T);
	declare
		VOP		type (SHORT_T),
		LEFT		type (CXX_VID_T),
		RIGHT		type (CXX_VID_T);

	if SZ = 1 then
		return (V);

	CXX_VALUE_NODE_PTR = V;
	VOP = CXX_VALUE_NODE.OP;

	if (VOP = ADD_VO) | (VOP = SUB_VO) then do;
		LEFT = CXX_VALUE_NODE.LEFT;
		RIGHT= CXX_VALUE_NODE.RIGHT;
		CXX_VALUE_NODE_PTR = RIGHT;
		if CXX_VALUE_NODE.OP = INTEGER_VO then do;
			call COUNT_UP_VALUE (RIGHT);
			RIGHT = GET_VALUE_AND_EXPAND_LR
				(MUL_VO, RIGHT, INTEGER_VALUE (SZ, 0));
			call COUNT_UP_VALUE (LEFT);
			LEFT  = GET_VALUE_AND_EXPAND_LR
				(MUL_VO, LEFT, INTEGER_VALUE (SZ, 0));
			call COUNT_DOWN_VALUE (V);
			V = GET_VALUE_AND_EXPAND_LR (VOP, LEFT, RIGHT);
		end;
	end;
	else	V = GET_VALUE_AND_EXPAND_LR
		    (MUL_VO, V, INTEGER_VALUE (SZ, 0));
	return (V);

end MUL_AND_ADD;

/* ---------------------------------------------------------------------
/* SAME_VALUE_TYPE
/* ------------------------------------------------------------------- */

SAME_VALUE_TYPE: procedure (LEFT, RIGHT) returns (type (BOOL_T)) internal;

	declare
		LEFT		type (CXX_VID_T),
		RIGHT		type (CXX_VID_T);
	declare
		LEFT_TCM	type (TCM_T),
		RIGHT_TCM	type (TCM_T);

	if (LEFT->CXX_VALUE_NODE.SIZE_UNITS = byte (BITS)) |
	   (RIGHT->CXX_VALUE_NODE.SIZE_UNITS = byte (BITS)) then
		return (FALSE);

	if LEFT->CXX_VALUE_NODE.EXTRA_PTR_LEVEL then
		LEFT_TCM = EXTRA_POINTER_TCM;
	else	LEFT_TCM = DEFAULT_TCM;
	if RIGHT->CXX_VALUE_NODE.EXTRA_PTR_LEVEL then
		RIGHT_TCM = EXTRA_POINTER_TCM;
	else	RIGHT_TCM = DEFAULT_TCM;

	return (COMPATIBLE_ANY_SPECIAL_TYPES
		(LEFT->CXX_VALUE_NODE.TYPE,
		 LEFT->CXX_VALUE_NODE.DERIVED_TYPE_SKIP,
		 LEFT_TCM,
		 RIGHT->CXX_VALUE_NODE.TYPE,
		 RIGHT->CXX_VALUE_NODE.DERIVED_TYPE_SKIP,
		 RIGHT_TCM));

end SAME_VALUE_TYPE;

/* ---------------------------------------------------------------------
/* DUMP_EXPAND_VALUE_DATA
/* ------------------------------------------------------------------- */

DUMP_EXPAND_VALUE_DATA: procedure (S) internal;
 
	declare
		S		character (*) varying;
	declare
		L		character (80) varying;

   	call WRITE_DEBUG_LINE (
'=============================================================================='
	);
	L = S ||
	    ' EXPV (' ||
	    trim (char (NESTING_LEVEL)) ||
	    '): line ' ||
	    trim (char (CURRENT_SOURCE.LINE)) ||
	    ', "' ||
	    TOKEN_NAME (CURRENT_SOURCE.FILE) ||
	    '"';
   	call WRITE_DEBUG_LINE (L);
   	call WRITE_DEBUG_LINE (
'- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -'
	);

	call DUMPVT (V);

end DUMP_EXPAND_VALUE_DATA;

/* ----------------------------------------------------------------------
/* ACTUAL_FUNREF
/*
/* Return the character representation of the actual function reference
/* to the function denoted by SYM, with the arglist denoted by the
/* tree that is rooted in ARGLIST.  The actual function reference returned 
/* of the form: "<function-name>([<arg-type>] [,<arg-type>]...)".
/* ---------------------------------------------------------------------- */

ACTUAL_FUNREF:	procedure (SYM, ARGLIST)
	       	returns (type(STRING_T))
		internal;
 
declare
	SYM			type (NID_T),	/* Function symbol */
	ARGLIST			type (CXX_VID_T);	/* Actual arglist */
declare
	S			type (STRING_T),
	THIS_ARG		type (CXX_VID_T),
	NEXT_ARG		type (CXX_VID_T),
	FIRST_ARG		type (BOOL_T);
 

	S = '';
	S = S || QUALIFIED_SYMBOL_NAME (SYM);
	S = S || '(';
 
	FIRST_ARG = TRUE;
 
	do THIS_ARG = ARGLIST repeat NEXT_ARG while (THIS_ARG ^= NULL_CXX_VID);
		CXX_VALUE_NODE_PTR = THIS_ARG;
		NEXT_ARG = CXX_VALUE_NODE.RIGHT;
		if ^FIRST_ARG then
			S = S || ',';
		else	FIRST_ARG = FALSE;
		S = S || TYPE_NAME (CXX_VALUE_NODE.TYPE, '');
	end;
 
	S = S || ')';
 
	return (S);
 
end ACTUAL_FUNREF;

end EXPAND_VALUE;

/* ---------------------------------------------------------------------
/* MAKE_BUILTIN_OPERATOR
/*
/* The value node V calls a function which has just been determined
/* to be a built-in.  Arguments have already been checked/processed
/* via CHECK_ARGUMENTS.  K1 is the VOP that should replace the
/* function.  Make the argument list into operands, in preparation
/* for expansion of the node V.  K is the number of arguments.
/*
/* On return, V is paged in.
/*
/* Oddly, this routine sets CXX_VALUE_NODE.UNARY as part of the preparation
/* for calling EXPAND, usurping the usual responsibility of EXPAND.
/* PKT wonders whether this is good.  It was the source of one bug,
/* in which EXPAND(VA_START_VO) did its usual thing of reusing V by going to
/* REEXPAND, but the case which was reexpanded assumed (as many
/* cases do) that UNARY is FALSE to begin with.
/* ------------------------------------------------------------------- */

MAKE_BUILTIN_OPERATOR: procedure (V, K1, K) internal;

	declare
		V		type (CXX_VID_T),
		K1		type (SHORT_T),
		K		type (SHORT_T);
	declare
		(LEFT, RIGHT)	type (CXX_VID_T),
		(T1, KV)	type (CXX_VID_T),
		I		type (SHORT_T),
		VOP		type (SHORT_T),
		POINTER_TYPE_INFO
				type (TYPE_INFO_T),
		TYPE_INFO	type (TYPE_INFO_T);

	/*
	/* Here, we found a "builtin" function,
	/* for which we can generate inline code.
	/**/

	CXX_VALUE_NODE_PTR = V;
	LEFT = CXX_VALUE_NODE.LEFT;
	RIGHT = CXX_VALUE_NODE.RIGHT;

	CXX_VALUE_NODE.OP = K1;		/* The builtin vop */
	CXX_VALUE_NODE.LEFT = NULL_CXX_VID;
	CXX_VALUE_NODE.RIGHT = NULL_CXX_VID;
	CXX_VALUE_NODE.THIRD = NULL_CXX_VID;

	/*
	/* Since prototype checking/conversion has
	/* been performed, the arguments of guaranteed
	/* to be of the correct type, etc.
	/**/

	T1 = RIGHT;

	/* Loop on 1, 2 or 3 arguments */

	do I = 1 to K;
		/*
		/* Get argument list
		/**/
		CXX_VALUE_NODE_PTR = T1;
		VOP = CXX_VALUE_NODE.OP;
		/*
		/* Get the next argument
		/**/
		T1 = CXX_VALUE_NODE.RIGHT;
		/*
		/* Get the argument expression.
		/**/
		KV  = CXX_VALUE_NODE.LEFT;
		call COUNT_UP_VALUE (KV);

		CXX_VALUE_NODE_PTR = V;
		if I = 1 then do;
			CXX_VALUE_NODE.UNARY = TRUE;
			CXX_VALUE_NODE.LEFT = KV;
		end;
		else if I = 2 then do;
			CXX_VALUE_NODE.UNARY = FALSE;
			CXX_VALUE_NODE.RIGHT = KV;
		end;
		else do;
			CXX_VALUE_NODE.TERNARY = TRUE;
			CXX_VALUE_NODE.THIRD = KV;
		end;
	end;
	/*
	/* Release the VAL (REF) --> function symbol.
	/**/
	call COUNT_DOWN_VALUE (LEFT);
	/*
	/* Release the original argument list.
	/**/
	call COUNT_DOWN_VALUE (RIGHT);
	/*
	/* The VICTIM expression should
	/* be 0 and should not need release.
	/**/
	CXX_VALUE_NODE_PTR = V;

end MAKE_BUILTIN_OPERATOR;

/* ---------------------------------------------------------------------
/* CONVERT_FLOATING
/*
/* Extracted from EXPAND(CONSTANT_VO) to try to get 
/* /LPI/sun4/bin/lpipl1.041603.nu working.
/* ------------------------------------------------------------------- */

CONVERT_FLOATING: procedure (TYPE, OFFSET, LEFT) internal;

	declare
		TYPE		type (SHORT_T),
		OFFSET		type (LONG_T),
		LEFT		type (CXX_VID_T);

	CXX_VALUE_NODE_PTR = LEFT;

	on error begin;
		/*
		/* E.g. float f = 10E9999;
		/**/
		revert error;
		/*
		/* Error; this constant cannot be converted to
		/* its floating pointer representation.  Adjust
		/* the magnitude of the constant appropriately.
		/**/
		call SEMANTIC_ERROR (ERR_CHAR_FLOAT_CONVERSION);
		/*
		/* Use 1.0 to avoid possible later divide by 0.
		/**/
		if TYPE = FLOAT_BT then
			CXX_VALUE_NODE.FLT23 = 1.0;
		else	CXX_VALUE_NODE.FLT52 = 1.0;
		goto END_FLOAT_CONVERSION;
	end;
	if TYPE = FLOAT_BT then do;
		CXX_VALUE_NODE.FLT23 =
			substr (CXX_VALUE_NODE.SPTR->
				TOKEN_SPELLING_POD.SPELLING,
				1, OFFSET);
	end;
	else do;
		CXX_VALUE_NODE.FLT52 =
			substr (CXX_VALUE_NODE.SPTR->
				TOKEN_SPELLING_POD.SPELLING,
				1, OFFSET);
	end;

	END_FLOAT_CONVERSION:;

end CONVERT_FLOATING;

/* ---------------------------------------------------------------------
 * RECOVER_LVALUE
 *
 * VALUE is value node id of an expression for which an lvalue is
 * required.  If the expression can be recovered to an lvalue in
 * a form which the user might expect, modify VALUE accordingly
 * and issue an error message noting the recovery.
 *
 * Returns whether recovery to an lvalue was possible,
 * and with VALUE paged in.
 * ------------------------------------------------------------------- */

RECOVER_LVALUE: procedure (VALUE) returns (type (BOOL_T)) internal;

	declare
		VALUE			type (CXX_VID_T);
	declare
		TYPE_INFO		type (TYPE_INFO_T),
		(V1, V2, KV)		type (CXX_VID_T),
		SZU			type (BYTE_T),
		P			type (POINTER_T),
		VOP			type (SHORT_T);
		

	CXX_VALUE_NODE_PTR = VALUE;
	call BYPASS_COMMA ();

	VOP = CXX_VALUE_NODE.OP;
	SZU = CXX_VALUE_NODE.SIZE_UNITS;
	if VOP = CAST_VO then do;
		KV = CXX_VALUE_NODE.LEFT;
		SZU = CXX_VALUE_NODE.SIZE_UNITS;
		CXX_VALUE_NODE_PTR = KV;
	end;

	/*
	/* To recover, it must be either a non-lvalue VALUE_VO, or
	/* a CAST of a VALUE_VO.  In the latter case, PKT guesses that
	/* the cast-to type must have the same boundary as the original.
	/**/
	
	if ^( CXX_VALUE_NODE.OP = VALUE_VO 
	    & CXX_VALUE_NODE.SIZE_UNITS = SZU) then do;
		CXX_VALUE_NODE_PTR = VALUE;
		return (FALSE);
	end;

	/* is VALUE_VO;  recoverable error */

	call DETACH_COMMA (VALUE, V1, V2);

	if VOP = CAST_VO then do;
		call GET_VALUE_TYPE (TYPE_INFO);
		call COUNT_UP_VALUE (KV);
		call COUNT_DOWN_VALUE (VALUE);
		VALUE = COPY_VALUE (KV);
		call SET_VALUE_TYPE (TYPE_INFO);
		if SW_C_PLUS_PLUS then do;
			call ADD_REFERENCE_LEVEL (TYPE_INFO);
			call GET_TYPE_NODE_R (TYPE_INFO.TYPE, P);
			call SEMANTIC_ERROR_I (ERR_CAST_NOT_AN_LVALUE,
				ANY_TYPE_NAME (P, TYPE_INFO.DERIVED_TYPE_SKIP,
					       DEFAULT_DSM, ''));
			call RELEASE_TYPE_NODE (TYPE_INFO.TYPE);
		end;
		else	call SEMANTIC_ERROR (ERR_NOT_AN_LVALUE);
	end;
	else do;
		call SEMANTIC_ERROR (ERR_NOT_AN_LVALUE);
		VALUE = COPY_VALUE (VALUE);
	end;
	CXX_VALUE_NODE.NOT_AN_LVALUE = FALSE;

	call REATTACH_COMMA (VALUE, V1, V2);

	return (TRUE);

end RECOVER_LVALUE;

/* ---------------------------------------------------------------------
/* CALL_TO_LPI_EXIT
/* ------------------------------------------------------------------- */

CALL_TO_LPI_EXIT: procedure (RETURNV) returns (type (CXX_VID_T)) internal;

	declare
		RETURNV	type (CXX_VID_T);
	declare
		NAME	type (NID_T),
		SYMBOL	type (NID_T),
		ARGV	type (CXX_VID_T),
		V	type (CXX_VID_T);

	SYMBOL = DECLARE_MAIN_EXIT_FUNCTION ();
	V = GET_VALUE_REF_AND_EXPAND (SYMBOL);
	V = GET_VALUE_AND_EXPAND_L (ADDR_VO, V);
	if RETURNV = NULL_CXX_VID then
		ARGV = INTEGER_VALUE_ZERO ();
	else	ARGV = RETURNV;
	ARGV = GET_VALUE_AND_EXPAND_L (ARG_VO, ARGV);
	V = GET_VALUE_AND_EXPAND_LR (CALL_VO, V, ARGV);
	return (V);

end CALL_TO_LPI_EXIT;


