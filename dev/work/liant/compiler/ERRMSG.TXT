# C++ errmsg.txt - C++ front-end diagnostic messages

########################################################################
#  This product is the property of Liant Software Corporation and is   #
#  licensed pursuant to a written license agreement.  No portion of    #
#  this product may be reproduced without the written permission of    #
#  Liant Software Corporation except pursuant to the license agreement.#
########################################################################

########################################################################
#
#  LPI EDIT HISTORY
#
#  10.20.92  DGM  060  Updated.
#  09.09.92  DGM  059  Updated.
#  08.19.92  DGM  058  Updated.
#  08.10.92  DGM  057  Updated.
#  06.24.92  PKT  056  Added 2 warnings.
#  06.18.92  DGM  055  Updated.
#  06.12.92  PKT  054  Updated initializing references messages.
#  05.29.92  DGM  053  Updated.
#  05.19.92  DGM  052  Updated.
#  04.27.92  PKT  051  Updated.
#  04.30.92  DGM  050  Updated.
#  04.27.92  PKT  049R Fixed messages for incompatible initialization
#		       involving pointers and non-pointers.
#  04.27.92  PKT       Fixed severity bugs relating to reference
#		       parameter and return conversion messages,
#		       introduced at 047.
#  04.17.92  PKT       Updated, changing a few more severities from 2 to 3.
#		       Support for improved GENERAL_CONVERT_VALUE.
#  04.18.92  PKT  049  Merged 046->047 with 046->048.
#  03.25.92  PKT  048  Updated from 046, changed a few severities from 2 to 3.
#  03.30.92  DGM  047  Updated.
#  03.05.92  DGM  046  Updated.
#  02.05.92  DGM  045  Updated.
#  01.30.92  PKT  044  Updated.
#  01.28.92  DGM  043  Updated.
#  01.21.92  DGM  042  Updated.
#  01.10.92  PKT  041  Updated inaccessible destructor messages.
#  01.14.92  DGM  040  Updated.
#  12.26.91  PKT  039  Updated.
#  12.16.91  PKT  038  Updated.
#  12.13.91  DGM  037  Merge.
#  11.12.91  DGM  036  Merge.
#  10.26.91  PKT  035  Updated.  Changed severity of UNKNOWN_SIZE to 2.
#  10.09.91  PKT  034  Updated.
#  10.03.91  DGM  033  Checked in again, to sync with errcod.in.
#  10.03.91  DGM  032  Updated.
#  09.25.91  PKT  031  Updated.
#  09.06.91  PKT  030  Updated; changed free store errors to severity 3.
#		       Changed linkage conflict from severity 1 to 2.
#  08.23.91  DGM  029  Updated.
#  08.19.91  DGM  028  Updated.
#  08.06.91  DGM  027  Updated.
#  07.31.91  DGM  026  Updated.
#  07.08.91  DGM  025  Updated.
#  06.17.91  PKT  024  Updated.
#  06.17.91  DGM  023  Updated.
#  06.05.91  PKT  022  Updated.
#  05.29.91  DGM  021  Updated.
#  05.22.91  PKT  020  Updated.
#  04.29.91  DGM  019  Updated.
#  04.24.91  PKT  018  Updated.
#  04.18.91  DGM  017  Updated.
#  03.27.91  TLF  016  Updated.
#  03.22.91  PKT  015  Changed a number of messages for formatting;
#                      other messages from severity 2 to 3; updated.
#  03.12.91  DGM  014  Updated.
#  03.08.91  PKT  013  Updated.
#  02.27.91  DGM  012  Updated.
#  02.21.91  PKT  011  Updated.
#  02.11.91  DGM  010  Updated.
#  01.31.91  DGM  009  Updated.
#  01.27.91  PKT  008  Updated for member pointers.
#  01.18.91  DGM  007  Updated.
#  01.11.91  PKT  006  Updated.
#  01.10.91  DGM  005  Updated.
#  12.18.90  PKT  004  Updated.
#  12.17.90  DGM  003  Updated.
#  11.29.90  DGM  002  Updated.
#  11.15.90  DGM  001  Updated.
#  11.12.90  DGM  000  Original; new format.
#
########################################################################

# ---------------------------------------------------------------------
#
# This file defines the CXXFE component messages.
#
# This component has been allocated 1750 message
# codes in the message range 20000-21749.
#
# N.B. the CPP component (ANSI-C/C++ preprocessor) has been
# allocated 250 message codes in the message range 21750-21999.
#
# ---------------------------------------------------------------------

%%ORG 20000

# ---------------------------------------------------------------------
# Parser Errors
# ---------------------------------------------------------------------

%SYNTAX 4
 Not a valid token in this context.
%EXTRA_TEXT 3
 Extraneous text follows the apparent syntactic end of program.

# ---------------------------------------------------------------------
# Front-End Lexical Errors (converting preprocessing tokens to tokens)
# ---------------------------------------------------------------------

%BIG_INTEGER 2
 The value of this integer is too large to fit into any data type.
%BIG_HEX_ESCAPE 1
 The value of this hex escape sequence is too large (larger than UCHAR_MAX).
%BIG_OCTAL_ESCAPE 1
 The value of this octal escape sequence is too large (larger than UCHAR_MAX).
%PREPROCESSOR_NUMBER 2
 Illegal token; this pp-number is not a valid constant; ignored.
%BAD_ESCAPE_SEQ 1
 Undefined escape sequence; the backslash will be ignored.
%PREPROCESSOR_OPERATOR 2
 Illegal token; unexpanded preprocessing-operator; ignored.
%PREPROCESSOR_TOKEN 2
 Illegal token; ignored.
%MULTI_BYTE_CHAR 1
 Multi-byte character constants are are machine dependent.

# ---------------------------------------------------------------------
# Generic Front-End Semantic Errors
# ---------------------------------------------------------------------

%GENERIC_SEV_1 1
 $1.
%GENERIC_SEV_2 2
 $1.
%GENERIC_SEV_3 3
 $1.
%GENERIC_SEV_4 4
 $1.

# ---------------------------------------------------------------------
# Declaration Specifiers Errors
# ---------------------------------------------------------------------

%STORAGE_PLACEMENT 1
 Placement of a storage-class specifier other than at the beginning of
 the declaration is an obsolescent feature.  Avoid this if possible.
%DUP_TYPE_KEYWORD 1
 Duplicate type keyword.
%DUP_TYPE_QUAL 2
 Duplicate type qualifier (i.e. "const" or "volatile").
%INCONSISTENT_TYPE_KEYWORDS 2
 Inconsistent type specifier keywords.
%INCONSISTENT_TYPES 3
 Inconsistent type specifiers.
%TOO_MANY_STORAGE 2
 At most, one storage-class specifier may be given in a declaration.
%REG_FUN 2
 **OBSOLETE**
%BAD_FUN_STORAGE 2
 The "auto" and "register" specifiers may not be used in function declarations.
%STATIC_LOCAL_FUN 2
 The "static" specifier may not be used in local function declarations.
%AUTO_STORAGE 3
 **OBSOLETE**
%AUTO_EXTERN_STORAGE 2
 **OBSOLETE**
%REG_EXTERN_STORAGE 2
 **OBSOLETE**
%BAD_EXTERN_STORAGE 2
 The "auto" and "register" specifiers may not be used in external declarations.
%AUTO_MEMBER_STORAGE 2
 **OBSOLETE**
%REG_MEMBER_STORAGE 2
 **OBSOLETE**
%EXTERN_MEMBER_STORAGE 2
 **OBSOLETE**
%BAD_MEMBER_STORAGE 2
 Only the "static" storage class specifier may be used in member declarations.
%BAD_C_MEMBER_STORAGE 3
 Storage class specifiers may not be used in member declarations in C.
%STATIC_PARAM_STORAGE 2
 **OBSOLETE**
%TYPEDEF_PARAM_STORAGE 2
 **OBSOLETE**
%BAD_PARAM_STORAGE 2
 Only the "auto" or "register" specifiers may be used in parameter declarations.
%PARAM_UNDEF_CLASS 2
 The parameter class type "$1" for this function definition of "$2"
 has not yet been defined.
%CLASS_DCL_SPEC 2
 A class declaration may not be decorated with any declaration specifiers.

# ---------------------------------------------------------------------
# Declarator Errors
# ---------------------------------------------------------------------

%FCT_RETURNS_FCT 2
 A function may not return a function.
%FCT_RETURNS_ARR 2
 A function may not return an array.
%ARR_OF_FCTS 2
 An array of functions is not allowed.
%TOO_MANY_PUNCTS 2
 **OBSOLETE**

# ---------------------------------------------------------------------
# Array and Dimension Declaration Errors
# ---------------------------------------------------------------------

%NEG_ARRAY_DIMENSION 1
 A negative array dimension has been given; zero has been assumed.
%ZERO_ARRAY_DIMENSION 1
 An array dimension has been given as zero.
%ARRAY_ZERO_SIZE 2
 Incomplete array definition; array "$1" is of unknown size.
%MISSING_DIM_VALUE 1
 Missing dimension value.
%BAD_EVAL_DIM 3
 The array dimension must be a compile time constant here.

# ---------------------------------------------------------------------
# Function and Parameter Declaration Errors
# ---------------------------------------------------------------------

%PROTO_TAG_DEF 2
 A class may not be defined within a function parameter list; legal in ANSI-C.
%FCT_STOR_CLASS 3
 Invalid storage class for function definition.
%FCT_BODY 3
 Function body can only follow a function declarator.
%PROMOTE_PARAM 1
 This old-style parameter "$" is of unpromoted type (float)
 and will be implicitly adjusted to its promoted type (double).
%PARAM_ADJUSTED_PTR_FCT 0
 **OBSOLETE**
%PARAM_NAME 3
 A parameter must be a a simple identifier.
%PARAM_LIST 3
 A parameter identifier list may be used only in a function definition.
%PTR_TO_FCT 1
 This class cannot be a function; adjusting to pointer-to-function.
%BAD_AUTO_DCL_NAME 3
 The parameter name "$" did not appear in
 the (old-style) function parameter list.
%HIDE_PARAM 2
 The name "$" has already been declared as a parameter;
 ignoring this declaration.
%UNNAMED_PARAM 2
 There is an unnamed parameter (#$1) in
 this function definition declarator "$2".
%DUP_PARAM_NAME 2
 The parameter name "$" has already been specified in the parameter list.
%PARAM_UNPROMOTED 3
 This function was previously declared with an old-style declaration; this
 prototyped declaration must be declared with parameters of promoted types
 only (i.e. no char, short, float).
%PARAM_UNPROMOTED_PREV 3
 This old-style function definition was illegally previously declared with a
 prototyped declaration with parameters of unpromoted types (char/short/float).
%ELLIPSIS 3
 This function was previously declared with an old-style declaration;
 thus, this prototyped declaration may not have an ellipsis terminator.
%PARAM_TYPE_MISMATCH 3
 This function declaration is incompatible with a previous
 declaration due to incompatible corresponding parameter(s).
%PARAMS_OR_ELLIPSIS 3
 This function declaration is incompatible with a previous declaration
 due to different number of arguments or use of the ellipsis terminator.
%PARAM_IDENT_MISMATCH 3
 Missing identifier(s) in parameter type list. For a function definition
 all must be included; for a declaration, all or none must be included.
%NUMBER_ARGUMENTS 3
 **OBSOLETE**
%TOO_FEW_ARGUMENTS 3
 Too few arguments specified in this function call (expecting $1, got $2).
%TOO_MANY_ARGUMENTS 3
 Too many arguments specified in this function call (expecting $1, got $2).
%BYPASS_CONSTRUCTOR 1
 Argument will be copied as a simple structure rather than using its
 copy constructor, because it does not match a formal argument.
%DUP_VOID_PARAM 3
 A function with a "void" parameter may contain no others.
%NAMED_VOID_PARAM 1
 A "void" parameter should have no associated parameter name.
%DUP_ELLIPSIS 2
 An ellipsis terminator may be specified only once, at the
 end of a parameter type list, e.g. "void f (int, ...)".

# ---------------------------------------------------------------------
# Miscellaneous Declaration Errors
# ---------------------------------------------------------------------

%TYPE_ZERO_SIZE 1
 The size of the type in this declaration is either zero or unknown.
%UNKNOWN_SIZE 3
 Unknown size (incomplete type).
%FUN_TYPEDEF 2
 A function may not be defined via a "typedef" of type function.
%NO_DECLARATOR 1
 A declaration must declare at least a declarator, a tag, or an enumerator.
%NO_MEMBER_DECLARATOR 2
 A member declaration must declare at least a declarator,
 a bit-field, a tag, or an enumerator; ignored.
%ITERATION_DECLARATION 3
 This declaration statement is the statement of a "while", "do", or "for" loop.

# ---------------------------------------------------------------------
# Class, Struct, Union, & Enum Declaration Errors
# ---------------------------------------------------------------------

%ANON_UNION_FUN_MEMBER 2
 An anonymous union may not have function members ($).
%PRIVY_ANON_UNION_MEMBER 2
 An anonymous union may not have private or protected members ($).
%ANON_UNION_MEMBER_REDCL 2
 This anonymous union member "$1" has been previously declared on line $2
 in its enclosing semantic scope.
%DUP_BIT_FIELD_MEMBER 2
 This bit-field member "$" has already been declared.
%BAD_MEMBER 2
 A member cannot be an instance of a containing class/struct/union.
%NON_CONSTANT_ENUM 2
 An enumerator initializer must specify an integral constant expression.
%ENUM_TRAILING_COMMA 1
 Extraneous comma in enumerator list; ignored.
%BIG_ENUM 2
 The value of this enumerator "$1" is too large to fit
 into its enumeration "$2", which is of type/size "$3".
%ZERO_ARRAY_MEMBER_SIZE 2
 This array member is of unknown size; the dimension must be specified.
%UNDEF_CLASS_OBJECT 3
 "$1" is an undefined class and may not be specified as the type of
 an object, or array element.
%NEST_TYPE_NAME 3
 A class/struct/union tag or "typedef" definition within a class (i.e. a
 nested type-name definition) may not define a name which is the same as
 its enclosing class.
%MEMBER_NAME 2
 A nested tag, typedef, enumerator, anonymous union member, or static data
 member may not have the same name "$" as its enclosing class or any of
 the direct base classes of its enclosing class.
%UNCONSTRUCTIBLE 2
 A constructor must be declared for this class "$" because
 one of its members or base classes needs to be initialized explicitly.
%TODO_GEN_CTOR 3
 Sorry, the compiler did not generate a needed constructor for class "$1".
%TODO_GEN_DTOR 3
 Sorry, the compiler did not generate a needed destructor for class "$1".

# ---------------------------------------------------------------------
# Bit-Field Declaration Errors
# ---------------------------------------------------------------------

%ZERO_WIDTH_BIT_FIELD 1
 A bit-field of zero width should have no declarator;
 aligning to the next field.
%BIG_BIT_FIELD 2
 The size of this bit-field exceeds the number of bits for its type.
%BAD_BIT_FIELD 2
 A bit-field may not be a derived (pointer/reference/array/function) type.
%BIT_FIELD_TYPE 3
 A bit-field must be specified as a (signed or unsigned) integral type.
%BIT_FIELD_SIZE 3
 A bit-field size must be specified as a non-negative
 integral constant expression.
%BIT_FIELD_TYPE_WARN 1
 In ANSI-C, a bit-field must be of type "int" (signed or unsigned);
 this integral type will be allowed, with appropriate maximum width.
%NO_BASE_TYPE 0
 No base type was specified, defaulting to "int".
%STORAGE_BIT_FIELD 2
 A bit-field declaration may not specify a storage class.
%FRIEND_BIT_FIELD 2
 A bit-field declaration may not be specified as a friend.
%FUN_BIT_FIELD 2
 A bit-field declaration may not specify any function specifiers.
%BIT_FIELD_PLACEMENT 2
 A bit-field specify is not allowed in this context.

# ---------------------------------------------------------------------
# Initialization Errors
# ---------------------------------------------------------------------

%DUP_INITIAL 2
 Duplicate initialization of this identifier.
%AUTO_INITIALIZER 2
 Aggregate "register" objects may not be initialized.
%CLASS_INITIALIZER 3
 Invalid storage class for an initializer.
%TOO_MANY_ARRAY 3
 Too many initial values for this array.
%ARRAY_INITIAL_ARGS 3
 An array initializer may not have arguments.
%NEEDS_DEFAULT_CTOR 3
 An array must be initialized here, but "$1" has no default constructor.
%TOO_MANY_STRUCT 3
 Too many initial values for class/struct/union.
%TOO_MANY_SCALAR 3
 More than one initial value for this scalar.
%TOO_MANY_STRINGS 3
 More than one initial constant string for this array of characters.
%TOO_MANY_CHAR_ARRAY 3
 Too many initial values for this array of characters.
%BAD_INITIAL_EXPR 3
 Invalid initial expression; must be a constant-expression.
%BAD_INITIAL_DECLARATION 4
 Invalid initializer token; an expression, "{", "}", or "," expected.
%NOT_CHAR_ARRAY 3
 The target type of a string literal initializer must be of
 type pointer-to-char (char *) or array-of-char (char []).
%BAD_INITIAL_PTR 3
 Invalid initial value for pointer type.
%BAD_INITIAL_FIELD 3
 Invalid initial expression for a bit-field.
%EXCESS_INITIAL_VALUES 3
 Excess initial value(s) ignored.
%BAD_INITIAL_PLACEMENT 3
 Illegal attempt to initialize an "extern" identifier with block scope.
%UNKNOWN_INITIAL_SIZE 3
 This is an incomplete type which cannot be initialized. Its size
 must be known prior to initialization.
%UNINITIALIZED_CONSTANT 2
 An object declared "const" must be initialized.
%PRIV_AGGREGATE_INIT 2
 A class with private or protected members may not be initialized using a
 brace-enclosed list of initial values.
%BASE_AGGREGATE_INIT 2
 A class with base classes may not be initialized using a brace-enclosed list
 of initial values.
%CTOR_AGGREGATE_INIT 2
 A class with a constructor or a virtual function may not be initialized using
 a brace-enclosed list of initial values.

# ---------------------------------------------------------------------
# Redeclared, Undeclared, and Linkage Errors
# ---------------------------------------------------------------------

%LINKAGE_CONFLICT 2
 The name "$1" was previously declared with external linkage on
 line $2, and is thus in conflict with this internal linkage
 declaration; will assume that all such declarations are intended
 to refer to the same internal linkage entity.
%DUP_ENUMERATOR 2
 The enumerator "$1" has been previously declared on line $2
 in this enumeration "$3".
%UNDECLARED_ID_INT 3
 Undeclared identifier "$"; implicitly declaring as type "int".
%IMPLICIT_OLD_PARAM_DCL 0
 "$" is an undeclared old-style function parameter;
 implicitly declaring as type "int".
%ENUMERATOR_REDCL 2
 This enumerator "$1" has been previously declared on line $2
 in its enclosing semantic scope.
%LOCAL_REDCL 2
 This local name "$1" has already been declared on line $2.
%INCOMPAT_REDCL 2
 This object "$1" has been previously declared on line $2
 with a type which is incompatible with the type of this declaration.
%REDEFINITION 3
 "$1" has been previously defined.
%TENTATIVE_DEFN_OBJ 3
 Tentative definition of object with constructor and/or destructor.
%REDEFINITION_OBJECT 3
 Redefinition of object with constructor or destructor.
%UNDEF_STATIC_FUN 1
 Function "$1" was declared with internal linkage but was never defined.
%NO_EXTERN_DEF 1
 This compilation unit contains no external definitions.
%UNDEF_FUNCTION_WARN 1
 Undeclared function; implicitly declaring as "extern int $1(...)".
%UNDEF_FUNCTION 2
 Function "$1" has not been declared.
%UNDEF_CONVERSION_FUNCTION 3
 Function "operator $1" has not been declared.
%INTERN_EXTERN_LINKAGE 2
 **OBSOLETE**
%TYPEDEF_SPEC 2
 A "typedef" declaration may not contain any "friend", "virtual",
 "inline", or "overload" specifiers.
%TYPEDEF_BIT_FIELD 2
 A "typedef" declaration may not specify a bit-field.
%NON_TYPE_TYPEDEF_REDCL 2
 This typedef "$1" was previously declared on line $2 as a non-type.
%TYPEDEF_NON_TYPE_REDCL 2
 This name "$1" was previously declared on line $2 as a typedef.
%TAG_NON_TYPE_REDCL 1
 This name "$1" was previously declared on line $2
 as a class with a constructor.
%NON_TYPE_TYPE_REDCL 1
 This class "$1" (which has a constructor) was previously declared
 on line $2 as a non-type.
%TYPEDEF_TAG_REDEF 2
 This tag "$1" has been previously declared on line $2 as a typedef.
%TAG_TYPEDEF_REDEF 2
 This typedef "$1" has been previously declared as a tag on line $2
 in this scope; this is legal only if they define the same types.
%TYPEDEF_TYPEDEF_REDEF 2
 This typedef "$1" has been previously declared on line $2 as a typedef with
 a type which is incompatible with the type of this declaration.
%TAG_TAG_REDEF 2
 This tag "$1" has been  previously declared on line $2
 as a different kind of tag (i.e. class, struct, union, enum).
%TYPE_HIDDEN_BY_NON_TYPE 1
 The type name "$" has been hidden by a previous non-type declaration of
 the same name in the same scope; qualify the name with the appropriate
 class, struct, union, or enum keyword if the type is to be referenced.
%TYPEDEF_NAME 3
 A "typedef" declaration must declare a simple name.
%UNDEF_QUAL_NAME 3
 The name "$1" was not declared as a member of "$2".
%QUAL_DATA_MEMBER_TYPE 3
 This name "$1" was declared as a data member of "$2" on line $3,
 but with a type which is incompatible with the type of this declaration.
%QUAL_NAME 3
 Qualified declarator names may only appear at global scope to define static
 data members or member functions, in friend declarations, or to (redundantly)
 qualify class member declarations.
%MEMBER_QUALIFIED_NAME 3
 Member name declarations may only be qualified (redundantly) with
 the name of enclosing class.
%GLOBAL_QUALIFIED_NAME 3
 The global scope qualifier "::" may not be used in declarations.
%BIT_FIELD_NAME 2
 A bit-field declaration must declare a simple unqualified name.

# ---------------------------------------------------------------------
# Compiler Errors
# ---------------------------------------------------------------------

%SEM_STACK_OVERFLOW 4
 Compiler inconsistency (semantic stack overflow).
%SEM_STACK_UNDERFLOW 4
 Compiler inconsistency (semantic stack underflow).

# ---------------------------------------------------------------------
# New messages
# ---------------------------------------------------------------------

%ABSTRACT_CLASS_OBJECT 3
 The class "$1" is an abstract class (it has/inherits a pure virtual function)
 and may not be specified as the type of an object, member, parameter,
 function, array element; it may be used as the type of a pointer or
 reference, or as a base class.
%UNDEF_SCOPE_QUALIFIER 3
 The name "$" is not a previously defined class; a class must
 be defined before its name may be used as a class scope qualifier.
%UNDEF_BASE_CLASS 2
 The name "$" is not a previously defined class; a class must be
 defined before it may be used as a base class (i.e. derived from).
%AMBIG_BASE_CLASS_REF 3
 This is an ambiguous reference to a base
 class ($1) from a derived class ($2).
%AMBIG_BASE_MEMBER_REF 3
 Ambiguous base class member reference;
 "$1" is a member of both classes "$2" and "$3".
%DERIVED_UNION 3
 A union may not specify base class (i.e. a union may not be derived).
%BASE_CLASS_UNION 3
 A union may not be specified as a base class
 (i.e. a union may not be derived from).
%STATIC_UNION_MEMBER 2
 A union may not have static data members.
%VIRTUAL_UNION_MEMBER 2
 A union may not have virtual members.
%VIRTUAL_STATIC 2
 A virtual member function may not be declared "static".
%PURE_SPEC 2
 A pure specifier may only be applied to "virtual" member functions.
%NON_ZERO_PURE_SPEC 2
 A pure specifier for a virtual member function must specify a
 zero-valued constant expression; ignored.
%REDEF_CLASS 3
 This class "$1" has been previously defined on line $2.
%REDEF_FUN_MEMBER 2
 This member function "$1" has been previously declared on line $2 with
 a type which is neither compatible with, nor sufficiently distinct from
 the type of this declaration.
%REDCL_FUN 2
 This function "$1" has been previously declared on line $2
 with a type which is neither compatible with, nor sufficiently
 distinct from, the type of this declaration.
%REDEF_DATA_MEMBER 2
 This data member "$1" has been previously declared on line $2.
%DUP_MEMBER_FUN_DEF 2
 The member function "$1" has been previously defined on line $2.
%REDEF_CTOR_MEMBER 2
 This member (which has the same name as the containing class name)
 has been previously declared as a constructor; ignored.
%REDEF_MEMBER_CTOR 2
 This constructor name has been previously declared as a (non-function)
 member; ignored.
%DTOR_BUT_NO_CTOR 1
 This class "$" defined a destructor but no constructor.
%OBJECT_UNION_MEMBER 3
 An object of a class with a destructor, constructor, or user-defined
 assignment operator may not be a member of a union.
%REDEF_FUN 2
 This function "$1" has been previously defined on line $2.
%OLD_PAR_DCL_PLACEMENT 3
 An old-style parameter declaration list must follow a function
 declaration and must precede a function body definition.
%FUN_BODY_PLACEMENT 3
 A function body must be preceded by a function type declaration.
%MAX_DERIVED_TYPE_LEVEL 3
 Too many derived types (e.g. pointer-to, reference-to, array-of,
 or function-returning) in one declarator; a maximum total of 16
 is currently supported (including any/all expanded typedefs).
%LINKAGE_PLACEMENT 2
 A linkage specifier may only occur at file scope.
%UNKNOWN_LINKAGE 2
 This is an unknown linkage specification; only "C" and "C++" are currently
 implemented.
%LINKAGE_KIND_CONFLICT 2
 The name "$1" has been previously declared with a conflicting linkage
 specification on line $2.

# ---------------------------------------------------------------------
# Base and Member Initialization Errors
# ---------------------------------------------------------------------

%MEMBER_INIT_LIST_PLACEMENT 3
 A member initialization list is permitted only for a constructor.
%NOT_BASE_OR_MEMBER 2
 "$1" is not a member or base class of "$2".
%OMITTED_BASE_NAME 1
 Omission of the base class name ($1) is an anachronism.
%BASE_NAME_REQUIRED 2
 "$1" has more than one base class; name of base class to
 initialize is required.
%NO_BASE_TO_INIT 2
 "$1" has no base class; name of member to initialize is required.
%NOT_DIRECT_MEMBER 2
 "$1" is an inherited member of "$2"; it is initialized via the base class.
%NOT_IMMEDIATE_OR_VIRTUAL 2
 "$1" is neither an immediate nor a virtual base class of "$2".
%BAD_MEMBER_FUNC_INIT 2
 A member function must be initialized in a declaration, not in the member
 initializer of a constructor.
%BAD_STATIC_MEMBER_INIT 2
 A static data member must be initialized in a declaration, not in the member
 initializer of a constructor.
%NO_DEFAULT_CTOR 2
 Every constructor for "$1" requires one or more arguments,
 but no initializer or argument is provided here.
%NEED_INIT_FOR_MEMBER 2
 An explicit initial value is required for member "$1".
%NEED_INIT_FOR_BASE 2
 An explicit base initializer is required here
 in order to construct base class "$1".
%DUPLICATE_MEMBER_INIT 2
 "$1" has been initialized more than once in this base/member
 initializer list.

# ---------------------------------------------------------------------
# Class Derivation Errors
# ---------------------------------------------------------------------

%DUP_BASE_CLASS 2
 Duplicate base class for this derived class definition; ignored.
%DUP_VIRTUAL_BASE_CLASS_SPEC 2
 Duplicate "virtual" base class specifier; ignored.
%INCONSISTENT_BASE_CLASS_SPEC 2
 Conflicting or duplicate base class specifiers; ignored.
%DEFAULT_PRIVATE_DERIVATION 0
 No base class access specifier given for this class; defaulting to "private".
%DEFAULT_PUBLIC_DERIVATION 0
 No base class access specifier given for this class; defaulting to "public".
%SELF_REF_BASE_CLASS 2
 A class may not be derived from itself.
%CTOR_RETURN_TYPE 3
 Constructor functions should specify no return value.
%DTOR_RETURN_TYPE 3
 Destructor functions should specify no return value.
%DTOR_NOT_FUN 3
 A destructor name must declare a function type.
%DTOR_PARAM_TYPE 3
 Destructor functions may specify no parameters.
%WRONG_DTOR 3
 This destructor is not of (doesn't have the same name as) this class.
%NON_MEMBER_DTOR 3
 A destructor must be a member function.
%QUALIFIED_CDTOR 2
 A constructor or destructor may not be declared as "const" or "volatile".
%STATIC_CDTOR 3
 A constructor or destructor may not be declared as "static".
%VIRTUAL_CTOR 3
 A constructor may not be declared as "virtual".
%OP_FUN_PLACEMENT 3
 This operator function must be declared as a non-static member function.
%NON_MEMBER_CONV 3
 A conversion function must be a member function.
%CONV_NOT_FUN 2
 A conversion name must refer to a function (with no return value and no
 parameters).
%CONV_RETURN_TYPE 3
 Conversion functions should specify no return value.
%CONV_PARAM_TYPE 3
 Conversion functions should specify no parameters.
%OPERATOR_FUN 2
 An operator name must refer to a function.
%VIRTUAL_NEW_DELETE_OP 3
 The "new" and "delete" operators may not be "virtual" member functions.
%STATIC_NEW_DELETE_OP 0
 Operators "new" and "delete" as member functions are implicitly static.
%NEW_OP_PARAM_TYPE 3
 The "new" operator must specify a first parameter of type "size_t".
%NEW_OP_RETURN_TYPE 3
 The "new" operator must specify a "void *" return type.
%DELETE_OP_RETURN_TYPE 3
 The "delete" operator must specify a "void" return type.
%MEMBER_DELETE_OP_PARAM_TYPE 3
 The "delete" operator member function must specify a first parameter
 of type "void *", and an optional second parameter of type "size_t".
%DELETE_OP_PARAM_TYPE 3
 The "delete" operator non-member function must specify one parameter
 of type "void *".
%OVERLOAD_DELETE 3
 The "delete" operator may not be overloaded.
%EOF_MEMBER_FUN 3
 End-of-file encountered while collecting a member function body within a class
 declaration.
%MEMBER_FUN_NO_RETURN 1
 This member function specifies no return value; assuming "int".
%FRIEND_FUN_NO_RETURN 1
 This friend function specifies no return value; assuming "int".
%ONLY_MEMBER_FRIENDS 2
 Friend declarations may only be specified within a class definition.
%UNDEF_QUAL_FRIEND 2
 **OBSOLETE**
%BAD_FRIEND 2
 This "friend" specifier may only be used within a class definition.
%BAD_VIRTUAL 3
 The "virtual" specifier may only be used within a class definition for a
 member function declaration.
%BAD_INLINE 2
 The "inline" specifier may only be used for a non-extern function declaration.
%FUN_SPEC_PARAM 2
 A parameter declaration may not specify any function specifiers; ignored.
%WARN_OVERLOAD 1
 The "overload" specifier is an obsolescent feature; it is not portable and
 may not be supported in future implementations.  Avoid its use if possible.

# ---------------------------------------------------------------------
# Friend Declaration Errors
# ---------------------------------------------------------------------

%BEFRIEND_MEMBER 2
 A class may not befriend one of its own members.
%FRIEND_TYPE 2
 Only function or named class types may be declared as friends.
%DUP_FRIEND 1
 This class "$1" already declared "$2" as a friend.
%FRIEND_MEMBER 2
 This friend was previously declared as a member of this class.
%FRIEND_STRUCTOR 2
 Constructors/destructors are *member* functions and therefore
 may not be declared as friends of the containing class.
%FRIEND_STORAGE 3
 A friend declaration may not specify a storage class.
%FRIEND_SPEC 2
 A friend declaration may not specify any function specifiers; ignored.

# ---------------------------------------------------------------------
# Member Access Adjustment Declaration Errors
# ---------------------------------------------------------------------

%NULL_ACCESS_DCL 2
 A member access declaration must specify a base class member name.
%TYPE_ACCESS_DCL 2
 A member access declaration may not specify a type.
%STORAGE_ACCESS_DCL 2
 A member access declaration may not specify any storage class specifiers.
%FUN_ACCESS_DCL 2
 A member access declaration may not specify any function specifiers.
%FRIEND_ACCESS_DCL 2
 A member access declaration may not specify a friend specifier.
%ACCESS_DCL 2
 A member access declaration is not allowed within "private" sections, only
 within "public" or "protected" sections.
%DERIVED_ACCESS_DCL 2
 A member access declaration may be used only in a derived class.
%BASE_ACCESS_DCL 2
 The class qualifier for this member access declaration is not a
 base class of this derived class.
%ACCESS_DERIVED 2
 Access to a base class member may not be adjusted in a derived class which
 also defines a member of that name.
%ACCESS_ENABLE 2
 Access to member "$1" cannot be enabled,
 because "$1" is not accessible from the present class.
%ACCESS_RESTRICTION 2
 Access to member "$1" cannot be restricted,
 because "$1" is accessible from the present class.

# ---------------------------------------------------------------------
# Compiler Errors
# ---------------------------------------------------------------------

%DCL_STATE_STACK_OVERFLOW 4
 Compiler inconsistency; declaration state stack overflow.
%DCL_STATE_STACK_UNDERFLOW 4
 Compiler inconsistency; declaration state stack underflow.
%NAME_STATE_STACK_OVERFLOW 4
 Compiler inconsistency; name state stack overflow.
%NAME_STATE_STACK_UNDERFLOW 4
 Compiler inconsistency; name state stack underflow.
%CLASS_STATE_STACK_OVERFLOW 4
 Compiler inconsistency; class state stack overflow.
%CLASS_STATE_STACK_UNDERFLOW 4
 Compiler inconsistency; class state stack underflow.
%SIG_STATE_STACK_OVERFLOW 4
 Compiler inconsistency; signature state stack overflow.
%SIG_STATE_STACK_UNDERFLOW 4
 Compiler inconsistency; signature state stack underflow.
%LINK_STATE_STACK_OVERFLOW 4
 Compiler inconsistency; linkage state stack overflow.
%LINK_STATE_STACK_UNDERFLOW 4
 Compiler inconsistency; linkage state stack underflow.
%SCOPE_STATE_STACK_OVERFLOW 4
 Compiler inconsistency; scope state stack overflow.
%SCOPE_STATE_STACK_UNDERFLOW 4
 Compiler inconsistency; scope state stack underflow.
%TYPE_STATE_STACK_OVERFLOW 4
 Compiler inconsistency; type state stack overflow.
%TYPE_STATE_STACK_UNDERFLOW 4
 Compiler inconsistency; type state stack underflow.
 Compiler inconsistency; function signature stack underflow.
%CLASS_STACK_OVERFLOW 4
 Compiler inconsistency; member-pointer class stack overflow.
%CLASS_STACK_UNDERFLOW 4
 Compiler inconsistency; member-pointer class stack underflow.
%DERIVED_TYPE_STACK_OVERFLOW 4
 Compiler inconsistency; derived type stack overflow.
%DERIVED_TYPE_STACK_UNDERFLOW 4
 Compiler inconsistency; derived type stack underflow.
%TYPEQ_STACK_OVERFLOW 4
 Compiler inconsistency; derived type qualifier stack overflow.
%TYPEQ_STACK_UNDERFLOW 4
 Compiler inconsistency; derived type qualifier stack underflow.
%FUN_TYPEQ_STACK_OVERFLOW 4
 Compiler inconsistency; function type qualifier stack overflow.
%FUN_TYPEQ_STACK_UNDERFLOW 4
 Compiler inconsistency; function type qualifier stack underflow.
%NODE_STACK_OVERFLOW 4
 Compiler inconsistency; node stack overflow.
%NODE_STACK_UNDERFLOW 4
 Compiler inconsistency; node stack underflow.
%LOOP_STK_OVER 4
 Compiler inconsistency; loop stack overflow.
%LOOP_STK_UNDER 4
 Compiler inconsistency; loop stack underflow.
%ASSERT_FAIL 4
 Compiler inconsistency.

# ---------------------------------------------------------------------
# Statement Control Errors
# ---------------------------------------------------------------------

%DUP_LABEL_NAME 2
 Label duplicates another declaration of "$1" in this function.
%DUP_CASE 3
 Duplicate case label.
%DUP_DEFAULT 3
 A "default" for this switch has already been seen.
%BAD_CASE_NUMBER 3
 Invalid case number.
%BAD_CASE_OR_DEFAULT 3
 This "case" or "default" is not within any switch block.
%BAD_BREAK 3
 This "break" is not within any loop or switch block.
%BAD_CONTINUE 3
 This "continue" is not within any loop.
%NO_RET_VALUE 2
 This function "$" may not return a value.
%NEEDS_RET_VALUE 1
 This function "$" should specify a return value.
%REQUIRES_RET_VALUE 3
 Return without expression from a function with a non-void return type.
%BYPASS_INIT 2
 A jump to this label bypasses the initializing statement for "$1" on line $2.
%SWITCH_BYPASS_INIT 2
 Entering switch at this case bypasses the initializing statement for "$1"
 on line $2.
%DESTRUCT_LABEL 3
 This label is preceded in this block by objects which require destruction.

# ---------------------------------------------------------------------
# Expression Errors
# ---------------------------------------------------------------------

%INT_CONST_EXPR_REQ 2
 An integral constant expression is required here.
%INT_IS_REQD 2
 An integer value is required here.
%SUBSCRIPT_OPERAND 3
 Neither of the operands of this subscript operator ([]) is a pointer type.
%NONARITH_PLUS 2
 The operand of the unary plus operator (+) must be arithmetic type.
%NONARITH_MINUS 2
 The operand of the unary minus operator (-) must be arithmetic type.
%NONARITH_ADD 2
 The left and right operands of the addition operator (+) must both be
 arithmetic type, or pointer and integral type.
%PTR_NONINT_ADD 2
 An integral type is required for array subscripting and pointer addition.
%NONARITH_SUB 2
 The left and right operands of the subtraction operator (-) must both
 be of arithmetic type, pointer and integral type, or both pointer types.
%PTR_NONINT_SUB 2
 Only an integral or a pointer type may be subtracted from a pointer.
%NONARITH_MUL 2
 The operands of the multiplication operator (*) must be arithmetic type.
%NONARITH_DIV 2
 The operands of the division operator (/) must be arithmetic types.
%NONINT_MOD 2
 The operands of the remainder operator (%) must be integral type.
%NONINT_BITOP 2
 The operands of the bitwise operators (|,&,^,<<,>>) must be integral type.
%BAD_PTR_INT_ARITH 2
 Zero or unknown sized object for pointer+int or pointer-int.
%BAD_CONVERSION_VALUE 3
 Invalid conversion; this is not a value.
%CONVERSION_ARR_FCT 3
 Invalid conversion of an array or function.
%CONVERSION_STRUCT 3
 Illegal attempt to convert a class, struct, or union to an incompatible type.
%CONVERT_FROM_VOID 3
 A "void" expression is evaluated for its side effects only. Explicit
 or implicit conversions may not be applied (except to "void").
%USE_OF_LABEL 3
 A label name can be used only in a "goto" statement.
%BAD_CONVERSION 3
 Invalid conversion; cannot convert to this result type.
%NO_CONSTRUCTOR 3
 The type being initialized has no constructor, but its initializer has
 2 or more constructor arguments.
%NON_LVALUE_ARRAY 2
 An lvalue is required to convert "array of type" to "pointer to type".
%UNARY_ADDR_LVALUE 3
 The argument of the address-of operator (&) must be an lvalue.
%NOT_AN_LVALUE 2
 An lvalue is required here.
%UNARY_ADDR_FIELD 3
 The address-of operator (&) may not be applied to a bit-field.
%UNARY_ADDR_LABEL 2
 Unary "&" cannot be applied to a label name.
%UNARY_ADDR_REG 2
 Unary "&" cannot be applied to a "register" variable.
%DISSIMILAR_ENUM_TYPES 1
 Comparison of different enumeration types; "$1" and "$2".
%REQ_VOID_IN_CONDITIONAL 2
 Incompatible types as second and third operands of conditional. The
 "0" operand is being implicitly cast to "void"; try explicit casting.
%BAD_VOID_IN_CONDITIONAL 3
 Incompatible types as second and third operands of conditional. If
 one operand has type "void", then both operands must have type "void";
 try explicit casting.
%NOT_CONST_PTR_EXPR 3
 This pointer valued initial expression is not a constant.
%BAD_DEREFERNCE 3
 An array subscript "[]" or a unary indirection "*"
 can be applied only to an array or pointer type.
%NOT_CLASS_STRUCT_UNION 3
 The name of the left of this member access operator ".", "->", ".*", or "->*"
 does not refer to a class, struct, or union.
%NOT_A_MEMBER 3
 The name to the right of this member access operator is not a member
 of the class, struct, or union referenced on the left.
%NOT_MEMBER_NAME 3
 The name on right is not a class/struct/union member name.
%SIZEOF_UNKNOWN 2
 Operand of "sizeof" is of unknown size; zero value being used.
%SIZEOF_BIT_FIELD 1
 Operand of "sizeof" cannot designate a bit-field.
%SIZEOF_FUNCT 3
 Operand of "sizeof" cannot designate a function.
%SIZEOF_RET_ZERO 1
 Sizeof returns a zero value.
%BAD_LVALUE_ASSIGN 3
 Left side of assignment is not an lvalue as required.
%NOT_STRUCT_UNION 3
 Name on left of "." or "->" does not refer to a class/struct/union.
%EVAL_FCT_DOT_MEMBER 2
 Cannot do "function().member" from debugger.
%NOT_A_FCT 3
 This is not a function.
%NOT_PRIMARY_EXPR 3
 Left of "()" is not a primary expression.
%BAD_CAST 3
 Illegal cast to an array or function type; cast only to scalar types.
 Try casting instead to the array element type, the function return type,
 or to a reference type.
%CAST_STRUCT_UNION 3
 Illegal cast to a class, struct, or union type; cast only to scalar types.
 To get this effect, cast to the pointer-to type, then dereference it.
%CONVERT_FUNCTION 3
 Illegal assignment to or initialization of a function.  A function may get
a value only in a function definition.
%ILLEGAL_CONST_ACCESS 3
 Illegal attempt to modify a "const" object.
%UNKNOWN_PTR_SUBTR_SIZE 2
 Illegal pointer subtraction; pointer(s) may not point to function types or
 types of unknown size (incomplete types).
%ZERO_DIVIDE 1
 Division by zero is not defined.
%TOO_MANY_ARGS 2
 Number of arguments exceeds implementation limit.
%PASS_AS_PTR_TO 2
 An array must be passed as a pointer-to type.
%MUST_BE_INTEGRAL 2
 Operand(s) must be of integral type.
%ILLEGAL_MEMBER_FUN 3
 A member function that is bound to an object does not have an address.
%MISSING_OBJECT 3
 Object missing in call of non-static member "$1".
%NEW_FUNCTION 3
 Type of new object must not be function.
%NEW_REFERENCE 3
 Type of new object must not be reference.
%NEW_INCOMPLETE 3
 Type of new object is incomplete; its size cannot be calculated.
%NEW_NO_MATCH 3
 No declaration of operator "new" matches the "placement" arguments used here.
%DELETE_FUNCTION 3
 "Delete" expression must not point to function.
%DELETE_REFERENCE 3
 "Delete" expression must not point to reference.
%DELETE_NON_POINTER 3
 Type of "delete" expression must be pointer.
%DELETE_CONST 3
 Attempt to "delete" const object.
%DELETE_UNDEFINED_CLASS 1
 The class ($1) of the object being deleted has not been defined.
%CTOR_NO_MATCH 3
 No declaration of a constructor for "$1" matches the
 argument list or initializer used here.

%MBR_PTR_OVERFLOW 3
 A pointer to member cannot be created here, because the referenced class is
 too big.
%BAD_MBR_PTR_CAST 3
 Illegal conversion of non member-pointer to member-pointer.
%VIRT_DERIVED_BASE_PTR_CNV 2
 A member pointer to a derived class ($1) may not be converted
 to a member pointer to a virtual base class ($2).
%AMBIG_BASE_DERIVED_MP_CNV 3
 A pointer to a member of an ambiguous base class ($1) may not
 be converted to a pointer to a member of a derived class ($2).
%VIRT_BASE_DERIVED_MP_CNV 2
 A pointer to a member of a virtual base class ($1) may not
 be converted to a pointer to a member of a derived class ($2).
%PRIV_BASE_DERIVED_MP_CNV 2
 A pointer to a member of an inaccessible base class ($1) may not
 be converted to a pointer to a member of a derived class ($2).
%UNRELATED_MP_CNV 2
 A pointer to a member of class "$1" may not be converted to
 a pointer to a member of class "$2" because neither class is
 a base of the other.
%DERIVED_BASE_MP_CNV 2
 A pointer to a member of a derived class ($1) may not be converted to
 a pointer to a member of a base class ($2) without an appropriate cast.
%AMBIG_DERIVED_BASE_MP_CNV 3
 A pointer to a member of a derived class ($1) may not be converted to
 a pointer to a member of an ambiguous base class ($2).
%VIRT_DERIVED_BASE_MP_CNV 2
 A pointer to a member of a derived class ($1) may not be converted to
 a pointer to a member of a virtual base class ($2).
%CONVERSION_MEMBER_POINTER 3
 A pointer to member may not be converted to $1.
%MBR_PTR_COMPARE_PTR 3
 A pointer to member may not be compared with an ordinary pointer.
%MBR_PTR_COMPARE 3
 Neither class "$1" nor "$2" is derived from the other;
 consequently pointers to members of these classes may not be compared.
%MBR_PTR_COMPARE_OP 3
 Pointers to members may only be compared using the equality and inequality
 operators.
%MBR_PTR_CAST_TO_PTR 3
 A pointer to member may not be converted to a pointer.
%ILLEGAL_MEMBER_COMPARISON 3
 Illegal comparison of member pointer with incompatible type.

# ---------------------------------------------------------------------
# Overloaded function resolution/unresolution
# ---------------------------------------------------------------------

%CAST_VOID_OVLD_FUN 3
 "$1" is overloaded.  An overloaded function may not be converted to void.

%OVLD_FUN_PTR 3
 Illegal use of a pointer to an overloaded function; only allowed as the right
 hand side of an initialization/assignment, an argument, or a return value.

%NO_OVERLOAD_MATCH 3
 No match could be found for this overloaded function reference: "$".
%DEREF_OVLD_FUN 3
 "$1" is overloaded.  The operator "*" may not be used to
dereference an overloaded member function.
%DEREF_OVLD_FUN_PTR 3
 "$1" is overloaded.  The operator "*" may not be used to
dereference the address of an overloaded member function.
%CAST_OVLD_FUN_PTR 3
 "$1" is overloaded.  The address of an overloaded function may not be
 explicitly converted to another type.
%SIZEOF_OVLD_FUN_PTR 2
 "$1" is overloaded.  Sizeof is not a legal operation on the address
of an overloaded function.

%PTR_CAST_TO_MBR_PTR 3
 The address of "$1" is a regular pointer because once overloading
is resolved, it is a static member.
A regular pointer may not be converted to a pointer to member.
%OVLD_MBR_PTR_CAST_TO_PTR 3
 The address of "$1" is a pointer to member because once overloading
is resolved, it is not a static member.
A pointer to member may not be converted to a pointer.

%DEREF_OVLD_FUN_MBR_PTR 3
 "$1" is overloaded.  The operators ".*" and "->*" may not be used to
dereference the address of an overloaded function.

# ---------------------------------------------------------------------
# Pointer incompatibilities
# ---------------------------------------------------------------------

%PTR_PTR_ASSIGNMENT 2
 Incompatible pointer types in assignment; "$1" vs. "$2".
%PTR_PTR_QUAL_ASSIGNMENT 2
 Incompatible pointer types in assignment; "$1" vs. "$2".
 The types pointed to contain incompatible type qualifiers.
%PTR_PTR_TOP_QUAL_ASSIGNMENT 2
 Incompatible qualified pointer types in assignment; "$1" vs. "$2".
 The type pointed to by the destination operand must have all the
 qualifiers of the type pointed to by the source operand.
%PTR_PTR_ARRAY_ASSIGNMENT 2
 Incompatible pointer types in assignment; "$1" vs. "$2".
 The size specifiers of any arrays pointed to must have the same value.
%PTR_PTR_FUN_ASSIGNMENT 2
 Incompatible pointer types in assignment; "$1" vs. "$2".
 The number and types of parameters of any functions pointed to
 must have compatible types.
%NON_PTR_PTR_ASSIGNMENT 2
 Illegal assignment of a non-pointer type ($2) to a pointer type ($1).
%PTR_NON_PTR_ASSIGNMENT 2
 Illegal assignment of a pointer type ($2) to a non-pointer type ($1).

%PTR_PTR_INITIAL 2
 Incompatible pointer types in initialization; "$1" vs. "$2".
%PTR_PTR_QUAL_INITIAL 2
 Incompatible pointer types in initialization; "$1" vs. "$2".
 The types  pointed to contain incompatible type qualifiers.
%PTR_PTR_TOP_QUAL_INITIAL 2
 Incompatible qualified pointer types in initialization; "$1" vs. "$2".
 The type pointed to by the declared variable must have all the qualifiers
 of the type pointed to by the initializer.
%PTR_PTR_ARRAY_INITIAL 2
 Incompatible pointer types in initialization; "$1" vs. "$2".
 The size specifiers of any arrays pointed to must have the same value.
%PTR_PTR_FUN_INITIAL 2
 Incompatible pointer types in initialization; "$1" vs. "$2".
 The number and types of parameters of any functions pointed to
 must have compatible types.
%NON_PTR_PTR_INITIAL 2
 Illegal initialization of a pointer object ($1) with a non-pointer type ($2).
%PTR_NON_PTR_INITIAL 2
 Illegal initialization of a non-pointer object ($1) with a pointer type ($2).

%PTR_PTR_ARGUMENT 2
 The type of argument $1 ($3) and the corresponding parameter ($2) are
 incompatible pointer types.
%PTR_PTR_QUAL_ARGUMENT 2
 The type of argument $1 ($3) and the corresponding parameter ($2) are
 incompatible pointer types.  The types pointed to contain incompatible
 type qualifiers.
%PTR_PTR_TOP_QUAL_ARGUMENT 2
 The type of argument $1 ($3) and the corresponding parameter ($2) are
 incompatible pointer types.  The type pointed to by the parameter
 must have all the qualifiers of the type pointed to by the argument.
%PTR_PTR_ARRAY_ARGUMENT 2
 The type of argument $1 ($3) and the corresponding parameter ($2) are
 incompatible pointer types.  The size specifiers of any arrays pointed
 to must have the same value.
%PTR_PTR_FUN_ARGUMENT 2
 The type of argument $1 ($3) and the corresponding parameter ($2) are
 incompatible pointer types.  The number and types of parameters of any
 functions pointed to must have compatible types.
%NON_PTR_PTR_ARGUMENT 2
 The non-pointer type of argument $1 ($3) may not be converted to the pointer
 type ($2) of the corresponding parameter.
%PTR_NON_PTR_ARGUMENT 2
 The pointer type of argument $1 ($3) may not be converted to the non-pointer
 type ($2) of the corresponding parameter.

%PTR_PTR_RETURN 2
 The type of this return value ($2) and the declared function return type ($1)
 are incompatible pointer types.
%PTR_PTR_QUAL_RETURN 2
 The type of this return value ($2) and the declared function return type ($1)
 are incompatible pointer types.  The types pointed to contain incompatible
 type qualifiers.
%PTR_PTR_TOP_QUAL_RETURN 2
 The type of this return value ($2) and the declared function return ($1)
 are incompatible pointer types.  The type pointed to by the declared return
 type must have all the qualifiers of the type pointed to by the return value.
%PTR_PTR_ARRAY_RETURN 2
 The type of this return value ($2) and the declared function return ($1)
 are incompatible pointer types.  The size specifiers of any arrays pointed
 to must have the same value.
%PTR_PTR_FUN_RETURN 2
 The type of this return value ($2) and the declared function return ($1)
 are incompatible pointer types.  The number and types of parameters of
 any functions pointed to must have compatible types.
%NON_PTR_PTR_RETURN 2
 This non-pointer return value type ($2) may not be converted to the declared
 pointer return type ($1).
%PTR_NON_PTR_RETURN 2
 This pointer return value type ($2) may not be converted to the declared
 non-pointer return type ($1).

%PTR_PTR_RELATIONAL 2
 Incompatible pointer types in comparison; "$1" vs. "$2".
%PTR_PTR_QUAL_RELATIONAL 2
 Incompatible pointer types in comparison; "$1" vs. "$2".
 The types pointed to contain incompatible type qualifiers.
%PTR_PTR_ARRAY_RELATIONAL 2
 Incompatible pointer types in comparison; "$1" vs. "$2".
 The size specifiers of any arrays pointed to must have the same value.
%PTR_PTR_FUN_RELATIONAL 2
 Incompatible pointer types in comparison; "$1" vs. "$2".
 The number and types of parameters of any functions pointed to
 must have compatible types.
%NON_PTR_PTR_RELATIONAL 2
 Illegal comparison of a pointer type ($1) to a non-pointer type ($2).

%PTR_PTR_CONDITIONAL 2
 Incompatible pointer types as second and third operands of conditional;
 "$1" vs. "$2".
%PTR_PTR_QUAL_CONDITIONAL 2
 Incompatible pointer types as second and third operands of conditional;
 "$1" vs. "$2".  The types pointed to contain incompatible type qualifiers.
%PTR_PTR_ARRAY_CONDITIONAL 2
 Incompatible pointer types as second and third operands of conditional;
 "$1" vs. "$2" .  The size specifiers of any arrays pointed to must have
 the same value.
%PTR_PTR_FUN_CONDITIONAL 2
 Incompatible pointer types as second and third operands of conditional;
 "$1" vs. "$2".  The number and types of parameters of any functions pointed
 to must have compatible types.
%NON_PTR_PTR_CONDITIONAL 2
 Incompatible pointer and non-pointer type as second and third operands
 of conditional; "$1" vs. "$2".

%PTR_PTR_SUBTRACTION 2
 Incompatible pointer types in subtraction; "$1" vs. "$2".
%PTR_PTR_QUAL_SUBTRACTION 2
 Incompatible pointer types in subtraction; "$1" vs. "$2".
 The types pointed to contain incompatible type qualifiers.
%PTR_PTR_ARRAY_SUBTRACTION 2
 Incompatible pointer types in subtraction; "$1" vs. "$2".
 The size specifiers of any arrays pointed to must have the same value.
%PTR_PTR_FUN_SUBTRACTION 2
 Incompatible pointer types in subtraction; "$1" vs. "$2".
 The number and types of parameters of any functions pointed to
 must have compatible types.

%PTR_PTR_EXPRESSION 2
 Incompatible pointer types in expression; "$1" vs. "$2".
%PTR_PTR_QUAL_EXPRESSION 2
 Incompatible pointer types in expression; "$1" vs. "$2".
 The types pointed to contain incompatible type qualifiers.
%PTR_PTR_ARRAY_EXPRESSION 2
 Incompatible pointer types in expression; "$1" vs. "$2".
 The size specifiers of any arrays pointed to must have the same value.
%PTR_PTR_FUN_EXPRESSION 2
 Incompatible pointer types in expression; "$1" vs. "$2".
 The number and types of parameters of any functions pointed to
 must have compatible types.
%NON_PTR_PTR_EXPRESSION 2
 Incompatible pointer and non-pointer types in expression; "$1" vs. "$2".

# ---------------------------------------------------------------------
# End of pointer incompatibilities diagnostics
# ---------------------------------------------------------------------

%ILLEGAL_STRUCT_COND 3
 Incompatible class types as second and third operands of conditional.
%BAD_CONSTANT_EXPR 2
 This constant expression does not evaluate to a constant that is in
 the range of representable values for its type.
%QUAL_VOID_PARAM 1
 A "void" parameter should not be "const" or "volatile" qualified.
%OLD_STYLE_VOID_PARAM 3
 An old-style function parameter may not be of type "void".
%VOID_OBJECT 3
 An object may not be declared as type "void".
%VIRT_FUN_RETURN_TYPE 3
 Function "$1" differs only in return type from a virtual
 function of the same name in the base class "$2".
%DIRECT_INDIRECT_BASE 2
 Class "$1" has been specified as both a direct
 and an indirect base class of class "$2".
%ARRAY_OF_INCOMPLETE 2
 An array of incomplete type may not be specified.
%REF_TO_REF 3
 A reference to a reference type may not be specified.
%MPTR_TO_REF 3
 A pointer-to-member to a reference type may not be specified.
%PTR_TO_REF 3
 A pointer to a reference type may not be specified.
%ARRAY_OF_FUN 3
 An array of function type may not be specified.
%FUN_RET_ARRAY 3
 A function returning array type may not be specified.
%FUN_RET_FUN 3
 A function returning function type may not be specified.
%BASE_DERIVED_PTR_CNV 2
 A pointer to a base class ($1) may not be converted to
 a pointer to a derived class ($2) without an appropriate cast.
%VBASE_DERIVED_PTR_CNV 2
 A pointer to a virtual base class ($1) may not be
 converted to a pointer to a derived class ($2).
%REF_CONSTANT_NEEDED 2
 Type of $1 is not compatible with the destination reference type.
 An incompatible initializer for a reference is valid
 only if the reference is to a const.
%REF_INVALID_INIT 2
 Expression of $ is not an lvalue.  It is a valid initializer
 for a reference only if the reference is to a "const".
%REF_BOUND_MBR_FUN_INIT 3
 Expression of "$1" is a member function bound to an object.
A bound member function may not initialize a reference.
%REF_RET_LOCAL 3
 A reference to a local name (automatic or passed-by-value argument)
 cannot be returned.
%PRIV_BASE_CLASS_REF 2
 This is an illegal reference to a base class ($1) from
 a derived class ($2) due to insufficient access privileges.
%AMBIG_BASE_DERIVED_PTR_CNV 3
 A pointer to an ambiguous base class ($1) may not
 be converted to a pointer to an derived class ($2).
%PRIV_BASE_DERIVED_PTR_CNV 2
 A pointer to an inaccessible base class ($1) may not
 be converted to a pointer to a derived class ($2).
%AMBIG_DERIVED_BASE_PTR_CNV 3
 A pointer to a derived class ($1) may not be converted
 to a pointer to an ambiguous base class ($2).
%PRIV_DERIVED_BASE_PTR_CNV 2
 A pointer to a derived class ($1) may not be converted
 to a pointer to an inaccessible base class ($2).
%TYPE_HIDES_NON_TYPE 1
 The type name "$" hides a previous non-type declaration of the same name
 in an enclosing scope.  A Classic C compatibility switch is available
 to alter this behavior; see your User's Guide for more information.
%PRIV_BASE_MEMBER_REF 2
 "$1" is not accessible from the current scope.
%PRIV_REF_VIA_OBJ 2
 "$1" is not accessible through an object of class "$2",
 from the current scope.
%NOT_BASE_CLASS_OF 2
 The class "$1" is not a base of the class "$2".
%NO_MULTIPLE_INHERITANCE 1
 No multiple inheritance is disabled; this base class will be ignored.
%AMBIGUOUS_USER_CONVERSION 3
 Ambiguous user conversions for this class object: "$1" and "$2".
%AMBIGUOUS_OVERLOAD 3
 Ambiguous overload resolution: "$1" and "$2".
%PRIV_ARRAY_CTOR 2
 Initialization of this array requires the default constructor
 for class "$1", but the constructor is not accessible.
%PRIV_CTOR 2
 The constructor "$1" is required here, but is not accessible.
%PRIV_COPY_CTOR 2
 The copy constructor "$1" must be accessible here.
%PRIV_DTOR 2
 The destructor "$1" is required here, but is not accessible.
%PRIV_BASE 2
 "$1" may not be initialized explicitly, because it is
 an inaccessible virtual base of the class being constructed.

# ---------------------------------------------------------------------

%UNOP_PARAM 3
 A unary operator member function must specify no parameters; a
 unary operator non-member function must specify one parameter.
%BINOP_PARAM 3
 A binary operator member function must specify one parameter; a
 binary operator non-member function must specify two parameters.
%MEMBER_OP_PARAM 3
 A unary operator member function must specify no parameters; a
 binary operator member function must specify two parameters.
%NON_MEMBER_OP_PARAM 3
 A unary operator non-member function must specify one parameter; a
 binary operator non-member function must specify two parameters.
%MEMBER_UNOP_PARAM 3
 A unary operator member function must specify no parameters.
%MEMBER_BINOP_PARAM 3
 A binary operator member function must specify one parameter.
%NON_MEMBER_UNOP_PARAM 3
 A unary operator non-member function must specify one parameter.
%NON_MEMBER_BINOP_PARAM 3
 A binary operator non-member function must specify two parameters.
%NON_STATIC_OP 3
 This operator function must be declared as a non-static member function
 or as non-member function.
%NON_STATIC_MEMBER_OP 3
 This operator function must be declared as a non-static member function.
%MEMBER_INCDEC_OP_PARAM 3
 An increment/decrement operator member function may specify no
 parameters, or one parameter of type "int".
%INCDEC_OP_PARAM 3
 An increment/decrement operator non-member function must specify a
 first parameter, and optionally a second parameter of type "int".
%COPY_CTOR_PARAM 3
 A copy constructor for a class X may not be declared with a parameter
 of class type X, only a reference to class type X.
%NO_VFTP 4
 Cannot find virtual function table pointer for "$1".
%OVERLOAD_NON_FUN 2
 The "overload" keyword may only be applied to function types.
%NO_MEMBER_DCL_SPEC 1
 No declaration specifiers (assuming "int"); declaration specifiers for
 a member declaration may be entirely omitted only for member functions.
%ZERO_MEMBER_SIZE 2
 This member is of unknown size (incomplete type).

# ---------------------------------------------------------------------
# Reference incompatibilities
# ---------------------------------------------------------------------

%REF_REF_CAST 1
 Incompatible types in cast to reference; "$1" vs. "$2".
 The operand is converted to a temporary of the type of the reference.
%REF_REF_QUAL_CAST 1
 Incompatible types in cast to reference; "$1" vs. "$2".
 The types contain incompatible type qualifiers.
 The operand is converted to a temporary of the type of the reference.
%REF_REF_TOP_QUAL_CAST 1
 Incompatible type qualifiers in cast to reference; "$1" vs. "$2".
 The type referenced by the destination does not have all the qualifiers
 of the type of the source operand.
 The operand is converted to a temporary of the type of the reference.
%REF_REF_ARRAY_CAST 1
 Incompatible types in cast to reference; "$1" vs. "$2".
 The size specifiers of any arrays referenced must have the same value.
 The operand is converted to a temporary of the type of the reference.
%REF_REF_FUN_CAST 1
 Incompatible types in cast to reference; "$1" vs. "$2".
 The number and types of parameters of any functions referenced,
 must have compatible types.
 The operand is converted to a temporary of the type of the reference.
%NON_REF_REF_CAST 3
 The operand of this cast is not an lvalue.   An lvalue is required when
 the type of the cast is a reference type ($1).

%REF_REF_INITIAL 1
 Incompatible types in initialization of reference; "$1" vs. "$2".
 This initializer is converted to a temporary of the type of the
 reference being initialized.
%REF_REF_QUAL_INITIAL 1
 Incompatible types in initialization of reference; "$1" vs. "$2".
 The types contain incompatible type qualifiers.
 This initializer is converted to a temporary of the type
 of the reference being initialized.
%REF_REF_TOP_QUAL_INITIAL 1
 Incompatible type qualifiers in initialization of reference; "$1" vs. "$2".
 The type referenced by the declared variable does not have all the qualifiers
 of the initializer.
 This initializer is converted to a temporary of the type
 of the reference being initialized.
%REF_REF_ARRAY_INITIAL 1
 Incompatible types in initialization of reference; "$1" vs. "$2".
 The size specifiers of any arrays referenced must have the same value.
 This initializer is converted to a temporary of the type of the reference
 being initialized.
%REF_REF_FUN_INITIAL 1
 Incompatible types in initialization of reference; "$1" vs. "$2".
 The number and types of parameters of any functions referenced,
 must have compatible types.  This initializer is converted to a
 temporary of the type of the reference being initialized.

%REF_REF_ARGUMENT 1
 The type of argument $1 ($3) is incompatible with the corresponding
 parameter ($2).  The argument is converted to a temporary of the type
 referenced by the parameter.
%REF_REF_QUAL_ARGUMENT 1
 The type of argument $1 ($3) is incompatible with the corresponding
 parameter ($2).  The types referenced contain incompatible
 type qualifiers.  The argument is converted to a temporary of the type
 referenced by the parameter.
%REF_REF_TOP_QUAL_ARGUMENT 1
 The type of argument $1 ($3) is incompatible with the corresponding
 parameter ($2).  The type referenced by the parameter
 does not have all the qualifiers of the type of the argument.
 The argument is converted to a temporary of the type
 referenced by the parameter.
%REF_REF_ARRAY_ARGUMENT 1
 The type of argument $1 ($3) is incompatible with the corresponding
 parameter ($2).  The arrays do not match in size.
 The argument is converted to a temporary of the type referenced
 by the parameter.
%REF_REF_FUN_ARGUMENT 1
 The type of argument $1 ($3) is incompatible with the corresponding
 parameter ($2), because the function parameter lists do not match.
 The argument is converted to a temporary of the type referenced
 by the parameter.

%REF_REF_RETURN 3
 The type of this return value ($2) is incompatible with the reference
 type declared for the function return ($1).
%REF_REF_QUAL_RETURN 3
 The type of this return value ($2) is incompatible with the reference
 type declared for the function return ($1);
 the types contain incompatible type qualifiers.
%REF_REF_TOP_QUAL_RETURN 3
 The type of this return value ($2) and the declared function return ($1)
 are incompatible;  the type referenced by the declared return
 type must have all the qualifiers of the type of the return value.
%REF_REF_ARRAY_RETURN 3
 The type of this return value ($2) is incompatible with the reference
 type declared for the function return ($1);
 the size specifiers of any arrays referenced must have the same value.
%REF_REF_FUN_RETURN 3
 The type of this return value ($2) and the declared function return ($1)
 are incompatible reference types.  The number and types of parameters of
 any functions referenced must have compatible types.
%NON_REF_REF_RETURN 3
 The return expression is not an lvalue.  An lvalue is required when the
 return type is a reference type ($1).

# ---------------------------------------------------------------------
# End of pointer and reference incompatibilities diagnostics
# ---------------------------------------------------------------------

%VOID_CONVERSION 2
 A conversion to type "void" is not allowed.
%DFTGEN_CTOR_CLASS_INACCESS 2
 In generating the default constructor for class "$2",
 the constructor "$1" is not accessible for constructing the base class "$3".
%DFTGEN_CTOR_MEMBER_INACCESS 2
 In generating the default constructor for class "$3",
 the constructor "$1" for member "$2" is required, but is not accessible.
%DFT_DTOR_CLASS_INACCESS 2
 In generating the destructor for class "$3",
 the destructor "$1" is not accessible for destroying the base class "$2".
%DFT_DTOR_MEMBER_INACCESS 2
 In generating the destructor for class "$3",
 the destructor "$1" is not accessible for destroying the member "$2".
%DFT_COPY_CLASS_INACCESS 2
 In generating the copy constructor for class "$2",
 the copy constructor "$1" exists,
 but is not accessible for copying the base class "$3".
%DFT_COPY_MEMBER_INACCESS 2
 In generating the copy constructor for class "$3",
 the copy constructor "$1" exists, but is not accessible for copying member "$2".
%DFT_ASSIGN_CLASS_INACCESS 2
 In generating the assignment operator for class "$2",
 the assignment operator "$1"
 is not accessible for the assignment of the base class "$3".
%DFT_ASSIGN_MEMBER_INACCESS 2
 In generating an assignment operator for class "$3",
 the assignment operator "$1" exists, but is not accessible for the assignment of
 member "$2".
%DFT_ASSIGN_SEMERR 2
 Cannot generate a default assignment operator for class "$1" because the
 class has a "$2" member.
%DFT_CTOR_CLASS_INACCESS 2
 Constructor "$1" exists, but is not accessible for the construction of base
 class "$2".
%DFT_CTOR_MEMBER_INACCESS 2
 Constructor "$1" exists, but is not accessible for the construction of member
 "$2".
%DFTGEN_CTOR_CLASS_ABSENT 2
 In generating the default constructor for class "$2",
 the base class constructor "$1()" is required, but does not exist.
%DFTGEN_CTOR_MEMBER_ABSENT 2
 In generating the default constructor for this class,
 the constructor "$1()" for member "$2" is required, but does not exist.
 One remedy for this error would be to define a constructor for
 the present class.
%DUP_DEFAULT_ARG 2
 A default argument for this parameter has already been given.
%DEFAULT_ARG_PLACEMENT 2
 A default argument may only be specified for a parameter after the last
 parameter without a default argument (or for the first parameter).
%VIRT_FUN_INCOMPLETE_BASE 1
 Function "$1" is more complete than the virtual function
 it overrides in the base class "$2".
%VIRT_FUN_INCOMPLETE_DERIVED 0
 Function "$1" is less complete than the virtual function
 it overrides in the base class "$2".
%PURE_FUN_CALL 2
 This is an illegal call to a pure virtual function "$1".
%AMBIG_VBC_VFO 2
 Ambiguous overriding of a virtual function in a virtual base class;
 "$1" both override the same virtual base class virtual function "$2".
%NO_DCL_SPEC 1
 No declaration specifiers (assuming "int"); declaration specifiers for
 a declaration may be entirely omitted only for function declarations.
%NO_MEMBER_DCL_SPEC_ANSI_C 1
 No declaration specifiers (assuming "int"); declaration specifiers for
 a member declaration may not be omitted.
%NO_DCL_SPEC_ANSI_C 1
 No declaration specifiers (assuming "int"); declaration specifiers for
 a declaration may be entirely omitted only for function definitions.
%ABSTRACT_CLASS_CAST 3
 "$1" is an abstract class (it has/inherits a pure virtual function)
 and may not be specified as the type of an explicit cast.
%UNDEF_CLASS_CAST 3
 "$1" is an undefined class and may not be specified as the type of an
 explicit cast.
%FUN_RET_UNDEF_CLASS 2
 The class return type "$1" for this function definition of "$2"
 has not yet been defined.

# ---------------------------------------------------------------------

%UNDEF_IDENTIFIER 2
 Undefined identifier "$".

%TYPELESS_SYM_NODE 1
 Type-less sym-node encountered; id $1, "$2".

%NESTED_FUN_REF_AUTO 2
 A nested function (i.e. a member function defined within a local class) may
 not reference automatic data in an enclosing local scope.

%MEM_FUN_REDCL 2
 A member function may not be redeclared without being defined.

%STATIC_DATA_MEM_REDCL 2
 A static data member may not be redeclared without being initialized.

%STATIC_DATA_MEM_REDEF 2
 This static data member "$" has already been initialized.

%DATA_MEM_REDCL 2
 Data members may not be redeclared (except to initialize static data members).

%NO_COMMA_BEFORE_ELLIPSIS 2
 This parameter list is missing a comma before the ellipsis; legal only in C++.

%LOCAL_STATIC_DATA_MEM 2
 Local classes may not have static data members.

%INIT_DATA_MEM 3
 Static members must be defined/initialized at global scope.  Other data
members must be initialized in the initialization list of a constructor.

%PRIV_TYPE_NAME 2
 This nested type "$" is inaccessible.

%PRIV_CLASS_NAME 2
 This nested class "$" is inaccessible.

%DEFAULT_ARG_USES_PARAM 3
 A formal argument "$" of a function may not be used in a default argument.

%DEFAULT_ARG_USES_MEM 3
 A non-static data member "$" may not be used in a default argument
 expression except through an object.

%BAD_TYPE_REF 3
 This identifier "$" was previously declared as a type
 and may not be used in this context.

%BAD_LABEL_REF 3
 This identifier "$" was previously declared as a label
 and may not be used in this context.

%GLOBAL_ANON_UNION 2
 A global anonymous union must be declared as "static".

%UNINITIALIZED_REFERENCE 2
 A reference must be initialized.

%INCOMPAT_ANY_ENUM 2
 Incompatible conversion of type "$1" to an enumeration type "$2".

%INCOMPAT_ENUM_ENUM 2
 Incompatible enumeration type conversion; "$1" to "$2".

%LOOK_AHEAD_LEVEL 4
 Parser exceeded look-ahead nesting level ($); simplify ambiguous construct.

%LOOK_AHEAD_SCOPE_LEVEL 1
 Parser exceeded look-ahead scope nesting level ($);
 simplify ambiguous construct.

%DUP_FUN_DEF 2
 The function "$1" has been previously defined on line $2.

%NON_STATIC_MEM_REF 3
 A non-static member "$" must be referenced through an object.

%THIS_REF 3
 The "this" pointer may only be referenced within a non-static member function.

%STATIC_MEM_DEF_STORAGE 2
 A member definition may not be specified as "static" or "extern".

%TOO_MANY_CHAR_ARRAY_ANSIC 2
 This string is too long (by one character, i.e. the implicit terminating null
 character) for the array of of characters being initialized; legal in ANSI-C.

%DEF_TAG_IN_RETURN_TYPE 2
 A tag may not be defined in a function return type; legal in ANSI-C.

%NOT_MEMBER_PTR 2
 The right operand of ".*" or "->*" is not pointer-to-member as required.

%DEFAULT_ARG_USES_THIS 3
 The implicit "this" parameter may not be used in a default argument.

%DEFAULT_ARG_USES_LOCAL 2
 A local variable "$" may not be used in a default argument.

%CALL_MAIN 2
 The function "main" may not be called from within a program.

%OVERLOAD_MAIN 2
 The function "main" may not be overloaded.

%STATIC_MAIN 2
 The function "main" may not be declared as "static" or "inline".

%ADDR_OF_MAIN 2
 The address of function "main" may not be taken.

%CONST_FUN_DCL 2
 Only non-static member functions may be declared as "const".

%CALL_CONST_THRU_NON_CONST 2
 A non-const function may not be called through a const object.

%CALL_VOL_THRU_NON_VOL 2
 A non-volatile function may not be called through a volatile object.

%VOID_ARRAY 3
 An array may not be declared as type "void".

%VOID_REFERENCE 2
 A reference may not be declared as type "void".

%NO_ASM 1
 The "asm" construct is not supported; ignored.

%MAIN_RET_VAL 1
 The return type of "main" should be "int".

%OPERATOR_NON_CLASS_PARAM 2
 A non-member operator function must specify at least one parameter of class
 type or reference to class type.

%OLD_STYLE_FUN 1
 Old-style function definitions are an anachronism in C++; old-style functions
 with external linkage will implicitly be declared with extern "C" linkage.

%NESTED_FUN 2
 **OBSOLETE**

%ANON_UNION_STORAGE 2
 An anonymous union may only have the storage class "static" (for
 a member or local declaration) or "auto" (for a local declaration).

%ANON_UNION_REGISTER 1
 Warning; ignoring "register" for local anonymous union declaration.

%ANON_UNION_SPEC 2
 Type-qualifiers and function specifiers may not be applied to anonymous unions.

%RET_TAG_DEF 2
 A tag may not be defined in the return type of a function declaration.

%HIDDEN_EXTERN_LINKAGE_REDCL 1
 The name "$1" was previously declared on line $2 with external linkage
 in a non-visible scope, and a type incompatible with this declaration.

%HIDDEN_LINKAGE_KIND_CONFLICT 1
 **OBSOLETE**

%HIDDEN_LINKAGE_CONFLICT 1
 The name "$1" was previously declared on line $2 with external linkage
 in a non-visible scope, and is thus in conflict with this internal linkage
 declaration; will assume that all such declarations are intended to refer
 to the same internal linkage entity.

%MULTIPLE_C_LINKAGE_OVERLOAD 2
 This "C" linkage name "$1" was previously declared with "C" linkage on line
 $2 with a type which is incompatible with the type of this declaration.  At
 most, one of a set of overloaded functions can be specified with "C" linkage.

%TAG_STORAGE_CLASS 2
 A storage class specifier may not be specified after a tag keyword;
 the "extern" specifier is allowed in this context as an extension.

%BAD_QUAL_TYPE_NAME 2
 This type-name was qualified with a class name in which it was not declared;
 use "$".

%NONVIS_TYPE 1
 This nested type name "$1" is not visible in this scope,
 use the qualified name "$2".

%DUP_NONVIS_TYPE 2
 This name "$1" is not visible as a type name and is defined as a type within
 (at least) two classes, "$2" and "3".

%ARRAY_OF_REF 3
 An array of reference type may not be specified.

%NO_CTOR_FOR_CONST_CLASS 2
 This class "$1" contains a non-static "const" member "$2" and must
 declare a constructor.

%AMBIGUOUS_OVERLOAD_BUILTIN 3
 Ambiguous overload resolution: "$1" and built-in "$2".

%TYPE_NON_TYPE_REDCL 2
 This name "$1" was previously declared on line $2 as a type.

%ARROW_OP_RET_TYPE 2
 The return type of operator-> must be a pointer to a class,
 a reference to a class, or a class.

%REDCL_OLD_FUN 2
 This old-style function "$1" was previously declared on line $2 with an
 incompatible type; the type of each prototype parameter must be compatible
 with the promoted type of the corresponding old-style parameter.

%REDCL_NEW_FUN 2
 This function "$1" was previously declared on line $2 as an old-style function
 with an incompatible type; the type of each prototype parameter must be
 compatible with the promoted type of the corresponding old-style parameter.

%SIMPLE_REDCL_OLD_FUN 2
 This old-style function "$1" was previously declared on line $2 with an
 incompatible type.

%SIMPLE_REDCL_NEW_FUN 2
 This function "$1" was previously declared on line $2 as an old-style function
 with an incompatible type.

%SIMPLE_REDCL_FUN 2
 This function "$1" has been previously declared on line $2
 with a type which is not compatible with the type of this declaration.

%MEMBER_REDCL 2
 This member "$1" has been previously declared on line $2 in this class "$3".

%MEMBER_REDCL_UNNAMED 2
 This member "$1" has been previously declared on line $2 in this class.

%EXTRA_SEMI_COLON 1
 Extraneous semi-colon; ignored.

%TYPE_DESTRUCTOR_DECLARATOR 3
 "~$1" is not a valid declarator name.

%INHERIT_DESTRUCTOR 2
 Destructors are not inherited.

%CAST_NOT_AN_LVALUE 2
 An lvalue is required here.  Use a cast to reference type ($1) instead.

%TOUGH_DESTRUCTION 3
 Sorry, a temporary variable is created here to initialize a reference, but
 the compiler is unable to call the temporary's destructor at the proper time.

%OBSOLETE_INC_DEC 2
 "$1" is defined, but without the extra formal argument
 required when overloading the postfix operator ++ or --.

%REDEF_MEMBER 2
 This member function name "$1" has been previously declared on line $2 as
 a non-function.

%QUAL_MEMBER_FUN_TYPE 3
 This name "$1" was declared as a member function of "$2" on line $3,
 but with a type which is incompatible with the type of this declaration.

%UNDEF_QUAL_CTOR_NAME 3
 No constructors were declared for "$1".

%UNDEF_QUAL_DTOR_NAME 3
 No destructors were declared for "$1".

%UNDEF_QUAL_CNV_NAME 3
 No conversion functions were declared for "$1".

%INCOMPAT_FUN_NON_FUN_REDCL 2
 This non-function name "$1" has been previously declared on line $2
 as a function.

%INCOMPAT_NON_FUN_FUN_REDCL 2
 This function name "$1" has been previously declared on line $2
 as a non-function.

%PROTO_TAG_DCL 1
 This tag name "$" is being declared at prototype scope; this is a dubious
 construct since the tag is visible only within this prototype scope, and this
 function won't be callable with the correct parameter type.

%PROTO_UNNAMED_TAG_DCL 2
 An unnamed tag name should not be declared at prototype scope.

%ENUM_DCL_TYPEDEF 1
 This enum "$" is declared with an extraneous "typedef" keyword.

%CLASS_DCL_TYPEDEF 1
 This class "$" is declared with an extraneous "typedef" keyword.

%SWITCH_BYPASS_NEEDS_INIT 3
 Entering switch at this case bypasses the non-trivial initializing
 statement for "$1" on line $2.

%BYPASS_NEEDS_INIT 3
 A jump to this label bypasses the non-trivial initializing statement
 for "$1" on line $2.

%UNION_DCL_SPEC 2
 A union declaration may not be decorated with any declaration specifiers,
 except for global anonymous unions which must be declared as "static".

%OPTIONS_HELP_MESSAGE 0
 LPI-C++ -- Major Command-Line Options
 -----------------------------------------------------------------------------
 -cfront2.1     AT&T C++ (cfront) 2.1 compatibility mode
 -cfront2.0     AT&T C++ (cfront) 2.0 compatibility mode
 -cfront1.2     AT&T C++ (cfront) 1.2 compatibility mode
 -ansic         ANSI C mode (does not imply -ansiclib; implies -nosysdef)
 -fullansic     Full ANSI C mode (same as -ansic -ansiclib)
 -classicc      Classic C mode (implies -classiccpp)
 -classiccpp    Classic C preprocessor mode
 -cppx          Enable common preprocessor extensions
 -nowarn        Suppress all compiler warnings
 -visw          Zero exit status if most severe diagnostic is a violation
 -vise          No object file if most severe diagnostic is a violation
 -noobj         Do not produce object file
 -lint          Turn on extra "lint-like" semantic checking
 -nodefer       Do not defer processing of inline function defined in headers
 -----------------------------------------------------------------------------
 -ipath         Specify include search path (colon separated list)
 -ipathc        Specify C-header include search path (colon separated list)
 -define name   Define a specified preprocessor name; or -define name=text
 -undef name    Undefine a specified predefined preprocessor name
 -stdc          Predefine __STDC__ as 1 (implied by -ansic)
 -nostdc        Do not predefine __STDC__ (default)
 -sysdef        Predefine standard system preprocessor macros (default)
 -nosysdef      Do not predefine standard system preprocessor macros
 -ansiclib      Favor the LPI ANSI C headers/library (use in linking too)
 -oldstream     Use cfront 1.2 stream.h/library (use in linking too)
 -include file  Include specified file before compilation
 -----------------------------------------------------------------------------
 -deb           Produce debugging data for CodeWatch (in file.stb)
 -noopt         Turn off all optimization (default)
 -opt           Turn on all optimizations
 -noinline      Turn off all function inlining
 -imath         Inline common standard C math.h functions
 -istring       Inline common standard C string.h functions
 -defextvft     Force external definitions of all virtual function tables
 -undefvft      Suppress definitions of any/all virtual function tables
 -----------------------------------------------------------------------------
 -cpp           Run only the preprocessor (to standard output)
 -files         Run preprocessor; print include file map
 -macros        Run preprocessor; print list of macros defined
 -makedepend    Print a makefile dependency list
 -----------------------------------------------------------------------------
 -stat          Print compiler statistics
 -headers       Print name of each header as it is opened for processing
 -predef        Print list of pre-define macros
 -exp           Generate an expanded listing file
 -map           Generate symbol table map in listing file
 -list file     Generate listing in specified file
 -nolist        Do not include listing of file in listing file
 -noincludes    Do not include listing of include file(s) in listing file
 -----------------------------------------------------------------------------
 --> Liant Software Corporation -- (508) 875-2294 -- support@lpi.liant.com <--
 -----------------------------------------------------------------------------

%MISSING_SOURCE_FILE_NAME 0
 Missing source file name (use -help for help).

%UNDEF_LABEL 3
 Undefined label "$".

%DEF_DUMMY_MEMBER 2
 The name "$1" was not explicitly declared as a member of "$2".

%MISSING_PREV_LINKAGE_KIND 2
 The function "$1" was previously declared on line $2 without a linkage
 specifier; both are "C++" linkage, but this is dubious and technically illegal.

%CONVERSION_EXCEPTION 2
 A floating point exception occurred while performing an arithmetic conversion.
 The conversion cannot be performed during compilation; it will be deferred to
 execution-time (if possible).

%CHAR_FLOAT_CONVERSION 2
 This constant cannot be converted to its floating point representation;
 adjust the magnitude of the constant appropriately.

%ARITHMETIC_EXCEPTION 2
 A floating point exception occurred while performing an arithmetic operation.
 This expression cannot be evaluated during compilation; it will be deferred
 to execution-time (if possible).

%USED_BEFORE_SET 1
 "$1" is being used but has not yet been set; it was declared on line $2.

%NEVER_USED 1
 "$1" was never used.

%MIGHT_RET_NO_VALUE 1
 This function "$" may reach the end of its body,
 and return with no value to a caller which requires a value.

%ARRAY_INITIALIZER 3
 Attempt to construct an array from a value of incompatible type.
%ARRAY_RESTORED 2
 An array expression may not be used as an array in this context, because
 it is implicitly converted to a pointer to the array's first element.

%ILLEGAL_CLASS_ASSIGN 3
 The class "$1" cannot be assigned because it has a const member, has a
 reference member, or has a base class or member with a private assignment
 operator.

%NO_CTOR_FOR_REF_CLASS 2
 This class "$1" contains a non-static reference member "$2" and must
 declare a constructor.

%ARRAY_CAST 2
 Cast to an array type is illegal.

%ARRAY_CONVERSION 3
 Illegal conversion to an array type from an incompatible type.

%ARRAY_ASSIGN 2
 An array is not a legal target for assignment, because it is implicitly
 converted to a pointer to the array's first element.

%NO_REF_TYPES_ALLOWED 2
 Illegal construct; reference types are allowed only in C++.

%NO_INHERITANCE_ALLOWED 2
 Illegal construct; inheritance is allowed only in C++.

%TYPEDEF_BASE_CLASS 2
 A base class name should specify the name of a class directly ($1),
 not the name of a typedef referring to the class ($2).

%DIRECT_NON_PROTO_FUN_CALL 2
 Call to a non-prototyped function "$".

%NON_PROTO_FUN_CALL 2
 Indirect call to a non-prototyped function.

%ENUM_BASE_TYPE 3
 An integral type (if any) must be specified after an "enum" keyword;
 note that this functionality is an LPI-C++ extension.

%WARN_ENUM_BASE_TYPE 2
 An integral type, if any, must be specified after the "enum" keyword.

%MULTI_BYTE_CHAR_OVERFLOW 1
 This multi-byte character constant is too large to fit into type "$".

%DIFF_ENUM_INT_TYPE 2
 This enum "$1" has a different integral type ($2) than the integral type
 ($3) of a previous declaration of the same enum on line $4.

%NO_MEMBER_FUN 2
 Member functions are not allowed in C (legal in C++).

%NO_TYPEDEF_MEMBER 2
 A typedef may not be declared within a struct or union in C (legal in C++).

%NO_MPTR_TYPES_ALLOWED 2
 Member pointer types are not allowed in C (legal in C++).

%NO_ENUM_INTEGRAL_TYPE 2
 Specifying an (integral) type after the "enum" keyword is an LPI-C++ extension;
 use the -enumspec, -fex, or -extensions switches to properly enable this.

%UNDEF_ENUM_VALUE 1
 This enumerator "$" does not yet have a defined value; assuming zero.

%WCHAR_OVERFLOW 1
 This wide character L'$' contains more than one multibyte character.
 Only the first will be processed; the rest will be ignored.

%WCHAR 2
 This wide character constant L'$' is not valid.

%WSTRING 2
 This wide string literal is not valid.

%ADJACENT_WIDE_AND_THIN 2
 Adjacent string literals and wide string literals are not allowed.
 
%UNQUAL_NESTED_TYPE 1
 Use "$" to access this nested type.

%VA_START_CLASS 3
 Sorry, LPI-C++ does not allow the parameter preceding "..." to
be a class, an aggregate, or a pointer to member function.
%VA_ARG_OPERAND 3
 The first argument to the "va_arg" macro must be the name of an object
declared with type "va_list".

%BIG_UNNAMED_ENUM 2
 The value of this enumerator "$1" is too large to fit
 into its enumeration, which is of type/size "$2".

%DUP_ENUM_VALUE 1
 The value ($1) of this enumerator "$2" is the same as the value of the
 enumerator "$3" defined on line $4.

%VOID_ARGUMENT 3
 A "void" expression may not be passed as an argument.

%PRIV_BASE_TYPE_NAME 2
 The base type "$" for this declarator is inaccessible.

%HIDE_PARAM_WARN 1
 The name "$" has already been declared as a parameter;
 this declaration will hide the parameter declaration.

%PARAM_USED_IN_PROTO 1
 Using a formal argument "$" of a function within its parameter list may
 be considered a dubious construct.

%EXTRA_ARG_COMMA 2
 Extraneous comma in argument list; ignored.

%MEMBER_FUN_REF 2
 This member-function-reference type "$1" may only be used to
 declare a pointer type, thereby creating member-pointer type.
 N.B. member-function-reference types are a non-portable cfront extension.

%DCL_MEMBER_FUN_REF 2
 Member-function-reference types are a non-portable cfront extension.
 Use the -xmfrt, -cfront1.2, -cfront2.0, or -cfront2.1 switches to
 properly enable this functionality.

%WARN_MEMBER_FUN_REF 1
 Member-function-reference types are a non-portable cfront extension.

%MEMPTR_CLASS_UNDEF_AT_USE 2
 The class "$1" must be defined before a reference to it,
 through a pointer to member, can be made.

%MEMPTR_CLASS_UNDEF_AT_DCL 2
 The name "$1" is not a previously defined class; a class should
 be defined before its name is used in a member pointer declarator.

%VA_START_USE 3
 The "va_start" macro may only be referenced from within a function which
 is declared to take a variable number of arguments.

%VA_START_NULL_SECOND_ARG 1
 Omitting the second argument to the "va_start" macro is undefined and
 therefore non-portable.  It is supported only as an extension.

%VA_START_BAD_SECOND_ARG 2
 The second argument to the "va_start" macro must be the name of the last
 declared parameter ($1) before the ellipsis.  As an extension, the second
 argument to "va_start" need not be given at all.

%VA_START_NO_PARAM 2
 The second argument to the "va_start" macro must be the name of the last
 declared parameter before the ellipsis, but there is none for this function.
 As an extension, the second argument to "va_start" need not be given at all.
 
%ANSI_C_LONE_ELLIPSIS 2
 This parameter list contains an ellipsis which is not preceded
 by any parameter declaration; legal (but dubious) only in C++.

%LONE_ELLIPSIS 1
 This parameter list contains an ellipsis which is not preceded by any
 non-void parameter declaration; this is dubious since there is no standard
 way to reference any arguments passed to such a function.  As an extension
 however, the the second argument to the "va_start" macro may be omitted
 thereby facilitating this.

%MAIN_NO_RET_VALUE 1
 "main" may return to its environment with a garbage value.

%LPICXX_OPTIONS_HELP_MESSAGE 0
 Common "lpicxx" Options (see your LPI-C++ User's Guide for a complete listing)
 -----------------------------------------------------------------------------
 -cfront2.1     AT&T (cfront) 2.1 compatibility mode
 -cfront2.0     AT&T (cfront) 2.0 compatibility mode
 -cfront1.2     AT&T (cfront) 1.2 compatibility mode
 -ansic         ANSI C mode (does not imply -ansiclib; implies -nosysdef)
 -fullansic     Full ANSI C mode (same as -ansic -ansiclib; use in linking too)
 -classicc      Classic C mode (implies -classiccpp)
 -classiccpp    Classic C preprocessor mode
 -cppx          Enable common preprocessor extensions
 -nodefer       Do not defer processing of inline function defined in headers
 -----------------------------------------------------------------------------
 -nowarn        Suppress all compiler warnings
 -lint          Turn on extra "lint-like" semantic checking
 -visw          Zero exit status if most severe diagnostic is a violation
 -vise          No object file if most severe diagnostic is a violation
 -----------------------------------------------------------------------------
 -o objectfile  Specify resultant object file name
 -c             Do not invoke the linker
 -noobj         Suppress object file generation
 -dryrun        Show but do not execute commands which would be executed
 -----------------------------------------------------------------------------
 -Ipathname     Specify include search path
 -Vpathname     Specify C-header include search path
 -Dname[=text]  Define a specified preprocessor name
 -Uname         Undefine a specified predefined preprocessor name
 -stdc          Predefine __STDC__ as 1 (implied by -ansic)
 -nostdc        Do not predefine __STDC__ (default)
 -sysdef        Predefine standard system preprocessor macros (default)
 -nosysdef      Do not predefine standard system preprocessor macros
 -ansiclib      Favor the LPI ANSI C headers/library (use in linking too)
 -oldstream     Use cfront 1.2 stream.h/library (use in linking too)
 -include file  Include specified file before compilation
 -----------------------------------------------------------------------------
 -E             Run only the preprocessor and print output to standard output
 -files         Run only the preprocessor and print include file map
 -macros        Run only the preprocessor and print list of macros defined
 -predef        Print the predefined preprocessor macros
 -M             Print a makefile dependency list
 -----------------------------------------------------------------------------
 -O             Turn on optimizations
 -deb           Produce debugging data for CodeWatch (in file.stb)
 -noinline      Turn off all function inlining
 -imath         Inline common standard C <math.h> functions
 -istring       Inline common standard C <string.h> functions
 -defextvft     Force external definitions of all virtual function tables
 -undefvft      Suppress definitions of any/all virtual function tables
 -----------------------------------------------------------------------------
 -stat          Print compiler statistics
 -H             Print pathnames of each header as it is opened for processing
 -predef        Print list of pre-define macros
 -exp           Generate an expanded listing file
 -map           Generate symbol table map in listing file
 -list file     Generate listing in specified file
 -nolist        Do not include listing of file in listing file
 -noincludes    Do not include listing of include file(s) in listing file
 -----------------------------------------------------------------------------
 --> Liant Software Corporation -- (508) 875-2294 -- support@lpi.liant.com <--
 -----------------------------------------------------------------------------

%NONINT_COMPLEMENT 2
 The operand of the unary complement operator (~) must be integral type.

%NONINT_SHIFT 2
 The operands of the shift operators (>>,<<) must be integral type.

%NONINT_SWITCH 2
 The controlling expression of a switch statement must be integral type.

%VALUE_NODE_STACK_OVERFLOW 4
 Compiler inconsistency; value-node stack overflow.
%VALUE_NODE_STACK_UNDERFLOW 4
 Compiler inconsistency; value-node stack underflow.

%LPIC_OPTIONS_HELP_MESSAGE 0
 Common "lpicc" Options (see your LPI-C User's Guide for a complete listing)
 -----------------------------------------------------------------------------
 -ansic         ANSI C mode (default; does not imply -ansiclib)
 -fullansic     Full ANSI C mode (same as -ansic -ansiclib; use in linking too)
 -classicc      Classic C mode (implies -classiccpp)
 -classiccpp    Classic C preprocessor mode
 -cppx          Enable common preprocessor extensions
 -----------------------------------------------------------------------------
 -nowarn        Suppress all compiler warnings
 -lint          Turn on extra "lint-like" semantic checking
 -visw          Zero exit status if most severe diagnostic is a violation
 -vise          No object file if most severe diagnostic is a violation
 -----------------------------------------------------------------------------
 -o objectfile  Specify resultant object file name
 -c             Do not invoke the linker
 -noobj         Suppress object file generation
 -dryrun        Show but do not execute commands which would be executed
 -----------------------------------------------------------------------------
 -Ipathname     Specify include search path
 -Dname[=text]  Define a specified preprocessor name
 -Uname         Undefine a specified predefined preprocessor name
 -stdc          Predefine __STDC__ as 1 (implied by -ansic)
 -nostdc        Do not predefine __STDC__ (default)
 -sysdef        Predefine standard system preprocessor macros
 -nosysdef      Do not predefine standard system preprocessor macros (default)
 -ansiclib      Favor the LPI ANSI C headers/library (use in linking too)
 -include file  Include specified file before compilation
 -----------------------------------------------------------------------------
 -E             Run only the preprocessor and print output to standard output
 -files         Run only the preprocessor and print include file map
 -macros        Run only the preprocessor and print list of macros defined
 -predef        Print the predefined preprocessor macros
 -M             Print a makefile dependency list
 -----------------------------------------------------------------------------
 -O             Turn on optimizations
 -noinline      Turn off all function inlining
 -deb           Produce debugging data for CodeWatch (in file.stb)
 -imath         Inline common standard C <math.h> functions
 -istring       Inline common standard C <string.h> functions
 -----------------------------------------------------------------------------
 -stat          Print compiler statistics
 -H             Print pathnames of each header as it is opened for processing
 -predef        Print list of pre-define macros
 -exp           Generate an expanded listing file
 -map           Generate symbol table map in listing file
 -list file     Generate listing in specified file
 -nolist        Do not include listing of file in listing file
 -noincludes    Do not include listing of include file(s) in listing file
 -----------------------------------------------------------------------------
 --> Liant Software Corporation -- (508) 875-2294 -- support@lpi.liant.com <--
 -----------------------------------------------------------------------------

%NON_CONST_INIT 2
 Non-constant initialization is not allowed in C (legal in C++).

%BAD_C_PARAM_STORAGE 2
 Only the "register" specifier may be used in parameter declarations.

%EMPTY_STRUCT 2
 A struct or union member declaration list may not be empty in C (legal in C++).

%EMPTY_ENUM 2
 An enum enumerator-list may not be empty in C (legal in C++).

%STMNT_PRECEEDS_DCL 2
 Declarations must precede all statements in a block in C (legal in C++).

%FOR_STMNT_INIT_DCL 2
 Declarations are not allowed in a "for" statement initializer (legal in C++).

%UNNAMED_DEFAULT_CTOR 2
 This class needs a default constructor, but it is unnamed, and therefore
 may not have a constructor.

%UNNAMED_COPY_CTOR 2
 This class needs a default copy constructor, but it is unnamed, and therefore
 may not have a constructor.

%UNNAMED_DEFAULT_DTOR 2
 This class needs a default destructor, but it is unnamed, and therefore
 may not have a destructor.

%PTR_PTR_FUN_ARG 2
 The type of argument $1 ($3) and the corresponding parameter ($2) for
 "$4" are incompatible pointer types.
%PTR_PTR_QUAL_FUN_ARG 2
 The type of argument $1 ($3) and the corresponding parameter ($2) for
 "$4" are incompatible pointer types.  The types pointed to contain
 incompatible type qualifiers.
%PTR_PTR_TOP_QUAL_FUN_ARG 2
 The type of argument $1 ($3) and the corresponding parameter ($2) for
 "$4" are incompatible pointer types.  The type pointed to by the parameter
 must have all the qualifiers of the type pointed to by the argument.
%PTR_PTR_ARRAY_FUN_ARG 2
 The type of argument $1 ($3) and the corresponding parameter ($2) for
 "$4" are incompatible pointer types.  The size specifiers of any arrays
 pointed to must have the same value.
%PTR_PTR_FUN_FUN_ARG 2
 The type of argument $1 ($3) and the corresponding parameter ($2) for
 "$4" are incompatible pointer types.  The number and types of parameters
 of any functions pointed to must have compatible types.
%NON_PTR_PTR_FUN_ARG 2
 The non-pointer type of argument $1 ($3) may not be converted to the pointer
 type ($2) of the corresponding parameter for "$4".
%PTR_NON_PTR_FUN_ARG 2
 The pointer type of argument $1 ($3) may not be converted to the non-pointer
 type ($2) of the corresponding parameter for "$4".

%REF_REF_FUN_ARG 1
 The type of argument $1 ($3) is incompatible with the corresponding
 parameter ($2) for "$4".  The argument is converted to a temporary of the type
 referenced by the parameter.
%REF_REF_QUAL_FUN_ARG 1
 The type of argument $1 ($3) is incompatible with the corresponding
 parameter ($2) for "$4".  The types referenced contain incompatible
 type qualifiers.  The argument is converted to a temporary of the type
 referenced by the parameter.
%REF_REF_TOP_QUAL_FUN_ARG 1
 The type of argument $1 ($3) is incompatible with the corresponding
 parameter ($2) for "$4".  The type referenced by the parameter
 does not have all the qualifiers of the type of the argument.
 The argument is converted to a temporary of the type
 referenced by the parameter.
%REF_REF_ARRAY_FUN_ARG 1
 The type of argument $1 ($3) is incompatible with the corresponding
 parameter ($2) for "$4".  The arrays do not match in size.
 The argument is converted to a temporary of the type referenced
 by the parameter.
%REF_REF_FUN_FUN_ARG 1
 The type of argument $1 ($3) is incompatible with the corresponding
 parameter ($2) for "$4", because the function parameter lists do not match.
 The argument is converted to a temporary of the type referenced
 by the parameter.

%TOO_FEW_FUN_ARGS 3
 Too few arguments specified in this call to "$1" (expecting $2, got $3).
%TOO_MANY_FUN_ARGS 3
 Too many arguments specified in this call to "$1" (expecting $2, got $3).

%ENUM_ARG 2
 The type of argument $1 ($2) and the corresponding parameter ($3)
 are incompatible enumeration types.
%ENUM_FUN_ARG 2
 The type of argument $1 ($2) and the corresponding parameter ($3)
 for "$4" are incompatible enumeration types.

%ANY_ENUM_ARG 2
 The type of argument $1 ($2) may not be converted to the
 corresponding enumeration parameter type ($3).
%ANY_ENUM_FUN_ARG 2
 The type of argument $1 ($2) may not be converted to the
 corresponding enumeration parameter type ($3) for "$4".

%CONVERT_CLASS 3
 Illegal attempt to convert a "$1" to a "$2".
%CLASS_ARG 3
 The type of argument $1 ($3) and the corresponding parameter ($2)
 "$4" are incompatible class, struct, or union types.
%CLASS_FUN_ARG 3
 The type of argument $1 ($3) and the corresponding parameter ($2) for
 the "$4" are incompatible class, struct, or union types.

%VOID_ELLIPSIS_PARAM 3
 A function with a "void" parameter may not have an ellipsis (...) parameter.
%WARN_VOID_ELLIPSIS_PARAM 1
 A function with a "void" parameter should not have an ellipsis (...)
parameter.
%VOID_PARAMETER 3
 Argument $1 attempts to pass an expression to a void parameter.
%PARAMETER_VOID 3
 A parameter in the definition of "$1" has type void.
%NEW_TYPE_QUAL 2
 Type qualifiers (i.e. "const" or "volatile") may not appear the type
 specifier list of a "new" expression; any type qualifiers will ignored.

%NEW_TAG_DEF 2
 A class, struct, union, or enum may not be defined in a "new" expression.

%SIZEOF_TAG_DEF 2
 A class, struct, union, or enum may not be defined in a "sizeof" expression.

%CAST_TAG_DEF 2
 A class, struct, union, or enum may not be defined in a cast expression.

%OP_WITH_DEFAULT_ARG 2
 An overloaded operator may not have default arguments.

%LOCAL_MEMBER_FUN_UNDEF 2
 Member functions of a local class must be defined ($1).

%NEW_ENUM_DCL 2
 An enumeration may not be declared in a "new" expression.

%CNVFUN_ENUM_DCL 2
 An enumeration may not be declared in a conversion operator.

%CNVFUN_TAG_DEF 2
 A class, struct, union, or enum may not be defined in a conversion function.

%UNDEF_ENUM_OBJECT 2
 "$1" is an undefined enumeration and may not be specified as the type of
 an object, or array element; assuming an "int" type/size enumeration.

%FUN_RET_UNDEF_ENUM 2
 The enumeration return type "$1" for this function definition of "$2"
 has not yet been defined; assuming an "int" type/size enumeration.

%PARAM_UNDEF_ENUM 2
 The parameter enumeration type "$1" for this function definition of "$2"
 has not yet been defined; assuming an "int" type/size enumeration.

%DUP_TYPEDEF_DCL 2
 This typedef "$1" declaration is a duplicate of one previously declared on
 line $2; this is harmless, and is legal in C++.

%FUN_CAST 2
 Cast to a function type is illegal.

%INCOMPAT_ENUM 2
 Incompatible conversion from "$1" to an enumeration type "$2".

%ASSIGNMENT_CONVERSION 3
 Expression type "$1" cannot be converted for assignment to type "$2".
%EXPLICIT_CONVERSION 3
 Expression type "$1" cannot be cast or converted to type "$2".
%INITIAL_CONVERSION 3
 Expression type "$1" cannot be converted to initialize type "$2".
%ARGUMENT_CONVERSION 3
 The type "$1" (of argument number $3)
cannot be converted to parameter type "$2".
%RETURN_CONVERSION 3
 Expression type "$1" cannot be converted to type "$2" for return.
%CONVERSION 3
 Expression type "$1" cannot be cast or converted to type "$2".

%OVLD_ASSIGNMENT 3
 The overloaded function "$1" cannot be converted for assignment to type "$2".
%OVLD_CAST 3
 "$1" is overloaded.  An overloaded function
cannot be cast or converted to type "$2".
%OVLD_INITIAL 3
 The overloaded function "$1" cannot be converted to initialize type "$2".
%OVLD_ARGUMENT 3
 The overloaded function "$1" in argument number $3
cannot be converted to parameter type "$2".
%OVLD_RETURN 3
 The overloaded function "$1" cannot be converted to type "$1" for return.
%OVLD_CONVERSION 3
 The overloaded function "$1" cannot be cast or converted to type "$2".

%POINTER_WONT_FIT 1
 The converted type "$1" cannot hold all of the bits in a pointer.

%DFT_CTOR_ELEMENT_INACCESS 2
 Constructor "$1" exists, but is not accessible for implicit
construction of an element of array "$2".

%NEED_INIT_FOR_ELEMENT 2
 Elements of the array "$1" require explicit initialization,
but not enough values are provided.

%DUP_UNION_MEMBER_INIT 3
 The member initializer for "$1" conflicts with another member
initializer in the same union.

%QUALIFIED_FUN_DCL 2
 Only non-static member functions may be declared as "volatile".

%CALL_UNINITIALIZED 3
 Call of undefined function.

%TYPE_NAME_QUALIFIER 3
 The name "$" is a non-class type name rather than a class name
 which is required for this scope qualifier name; this is legal
 only if a destructor name is being qualified (e.g. p->T::~T).

%PRAGMA_WEAK_SELF_REF 2
 The name ($) in this #pragma weak is being defined to refer to itself.

%PRAGMA_WEAK_DUP 2
 This #pragma weak ($1) is an exact duplicate of one which appeared on line $2.

%PRAGMA_WEAK_REDEF 2
 A #pragma weak for this name ($1) has already been specified on line $2.

%PRAGMA_WEAK_CYCLE 2
 This #pragma weak "$" produces a cyclic definition.

%PRAGMA_WEAK_DEFINED_WEAK 2
 This #pragma weak specifies a name ($1) which has already been defined
 on line $2.

%PRAGMA_WEAK_UNDCL_WEAK 2
 This #pragma weak specifies a name ($1) which has not been declared as an
 external "C" linkage function or data object.

%PRAGMA_WEAK_UNDCL_STRONG 2
 This #pragma weak specifies a strong name ($1) which has neither been declared
 as an external "C" linkage or non-overloaded function, nor as a data object.

%EXTERN_LINKAGE_HEADER_FUN 1
 The function "$" with which is being defined in a header file,
 has external linkage.  This is rather dubious; perhaps it was
 meant to be "inline" or "static".

%WARN_ZERO_ARRAY_MEMBER_SIZE 1
 This array member is of unknown size; the dimension should be specified;
 the size of this member is assumed to be zero.

%MEMPTR_MEMPTR_CONDITIONAL 2
 Incompatible pointer to member types as second and third operands of
 conditional; "$1" vs. "$2".

%PRAGMA_WEAK_STRONG_REDEF 2
 This #pragma weak specifies a strong name ($1) which has been previously
 been specified as the strong name of a #pragma weak on line $2.

%REFERENCE_TEMP_SIZE 3
 A temporary object is needed because $2 is not an lvalue
 compatible with the type it initializes.
 The storage size for an object of type "$1" is unknown.

%PRAGMA_DATASEC_ATTRIBUTES 2
 This data section "$1" has been previously defined
 with different attributes on line $2.

%PRAGMA_DATASEC_ALIGNMENT 2
 This data section "$1" has been previously defined
 with different alignment constraints on line $2.

%PRAGMA_DATASEC_ADDRESS 2
 This data section "$1" has been previously defined
 with a different address on line $2.

%PRAGMA_DATASEC_DEFAULT 2
 The default data section may not be specified with attributes, alignment
 constraints, or an address.

%INCOMPAT_REDCL_DATASEC 2
 This object "$1" has been previously declared on line $2 as a part of the
 data section "$3"; the current data section is "$4".

%CALL_MBR_FUNC_RVALUE 1
 The member function "$1" is not "const"; because its object is
 a temporary, any changes it makes will be discarded.

%UNDEFINED_NESTED_CLASS 1
 The nested class "$2::$1" declared on line $3 was never defined.
 If "$1" should be a global class, declare it at global scope
 prior to using it in class "$2".

%AUTHORS 0
 +-----------------------------------------------------------------------------+
 | The LPI-C++ compiler and debugger was developed entirely by Liant Software  |
 | Corporation using its existing compiler/debugger technology.  Development   |
 | commenced in the autumn of 1989 and was "finished" in the summer of 1991.   |
 | Significant contributions were made by:                                     |
 |                                                                             |
 |         MJ Franzago               // debugger                               |
 |         Thomas Friedman           // front-end, project-leader              |
 |         Mark Greeley              // code-generator                         |
 |         Kevin Grimes              // code-generator                         |
 |         John Kaminski             // utilities, optimizer, front-end        |
 |         Ellie Lowell              // documentation                          |
 |         Chuck McComas             // project-manager                        |
 |         David Michaels            // front-end, preprocessor, debugger      |
 |         Fima Rabin                // optimizer                              |
 |         Prescott K. Turner, Jr.   // front-end, technical-leader            |
 |                                                                             |
 +-----------------------------------------------------------------------------+

%NEW_ABSTRACT_CLASS_OBJECT 3
 The class "$1" is an abstract class and therefore may not be instantiated.

%VIRTUAL_FUN_HIDDEN 1
 The member function "$1" hides rather than overrides a virtual member
 function "$2" of base class "$3" due to its differing type.

%NOT_A_MEMBER_NAME 3
 The name "$1" to the right of this member access operator is not a member
 of the class, struct, or union "$2" referenced on the left.

%NOT_A_MEMBER_QUAL_NAME 3
 The qualified name "$1" to the right of this member access operator is not
 a member of the class, struct, or union "$2" referred to by its qualifier.

%SUPPORT_MESSAGE 0
 ++----------------------------------------+------------++
 ||  Liant Software Corporation            |            ||
 ||  959 Concord Street                    |     o o    ||
 ||  Framingham, Massachusetts 01701-4613  |   o   _o   ||
 ||  Tel: (508) 872-8700                   |   o 0/     ||
 ||  Fax: (508) 626-2221                   |   _/*      ||
 ||                                        |     *      ||
 ||  Support: (508) 875-2294               |   _/ )_    ||
 ||  Email:    support@lpi.liant.com       |            ||
 ++----------------------------------------+------------++
 
%EXTERN_LOCAL_REDCL 2
 This local external linkage name "$1" has already been declared on line $2
 with no linkage.


