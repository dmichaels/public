/* C++ errors.asc - Error messages
/*
/***********************************************************************
/* This product is the property of Language Processors, Inc. and is    *
/* licensed pursuant to a written license agreement.  No portion of    *
/* this product may be reproduced without the written permission of    *
/* Language Processors, Inc. except pursuant to the license agreement. *
/***********************************************************************
/*
/***********************************************************************
/*
/*  LPI EDIT HISTORY
/*
/*  11.06.90  DGM  049  Updated.
/*  10.24.90  PKT  048  Updated.
/*  10.22.90  DGM  047  Updated.
/*  10.18.90  TLF  046  Updated.
/*  10.16.90  PKT  045  Updated.
/*  10.12.90  DGM  044  Updated.
/*  10.10.90  DGM  043  Updated.
/*  09.28.90  PKT  042  Updated.
/*  09.12.90  DGM  040  Updated.
/*  09.06.90  TLF  039  Updated.
/*  09.05.90  PKT  038  Updated.
/*  08.17.90  TLF  036  Updated.
/*  08.08.90  DGM  035  Updated.
/*  08.07.90  PKT  034  Updated.
/*  07.20.90  PKT  033  Updated.
/*  07.18.90  DGM  032  Updated.
/*  07.05.90  PKT  031  Updated.
/*  06.29.90  DGM  030  Updated.
/*  06.25.90  DGM  029  Updated.
/*  06.18.90  TLF  028  Updated.
/*  05.31.90  PKT  027  Updated.
/*  05.17.90  DGM  024  Updated.
/*  05.15.90  DGM  023  Updated.
/*  05.04.90  DGM  022  Updated.
/*  04.25.90  DGM  021  Updated.
/*  04.23.90  DGM  020  Updated.
/*  04.19.90  DGM  019  Updated.
/*  04.17.90  PKT  018  Updated.
/*  04.04.90  DGM  017  Updated.
/*  03.27.90  DGM  016  Updated.
/*  03.16.90  TLF  015  Updated.
/*  03.14.90  PKT  014  Updated.
/*  03.02.90  DGM  012  Updated.
/*  02.22.90  DGM  011  Updated.
/*  02.22.90  TLF  010  Updated.
/*  02.21.90  PKT  009  Updated.
/*  02.15.90  DGM  008  Updated.
/*  02.09.90  DGM  007  Updated.
/*  02.05.90  DGM  006  Updated.
/*  11.21.89  DGM  000  Original.
/*
/***********************************************************************
/*
/*
*ORG 0
/*
/* ---------------------------------------------------------------------
/* Scanner and Preprocessor Errors
/* ---------------------------------------------------------------------
/*
#PP_OPEN
4       Cannot open main source file "$".!
#PP_READ
3       Read error; panic.!
#PP_EOF_IN_TOKEN
2       End-of-file encountered within a token.!
#PP_EOF_IN_LINE
2       End-of-file encountered within a line.!
#PP_EOF_IN_COMMENT
2       End-of-file encountered within a comment.!
#PP_EOF_IN_DIRECTIVE
3       End-of-file encountered within a preprocessing directive.!
#PP_EOF_IN_MACRO_CALL
3       End-of-file encountered within an invocation of a
        function-like macro.  Incomplete macro expansion of "$".!
#PP_EOF_IN_EXCLUDED_GROUP
2       End-of-file encountered while skipping a conditionally excluded
        group (e.g. after a #if 0) $.!
#PP_ILLEGAL_DIRECTIVE_CHAR
2       An illegal character (vertical-tab or form-feed) was
        encountered within a preprocessing directive; ignored.!
#PP_UNKNOWN_DIRECTIVE
2       Unknown preprocessing directive "#$"; directive ignored.!
#PP_EMPTY_DIRECTIVE
2       Empty "#$" directive; directive ignored.!
#PP_EXTRA_TEXT_DIRECTIVE
1       Extraneous text at end of a "#$" directive; ignored.!
#PP_NO_DIRECTIVE_IDENTIFIER
2       Missing identifier in "#$" directive; directive ignored.!
#PP_ILLEGAL_UNDEF_IDENTIFIER
2       Illegal attempt to #undef the predefined macro name "$"; ignored.!
#PP_ILLEGAL_DEFINE_IDENTIFIER
2       Illegal attempt to #define the predefined macro name "$"; ignored.!
#PP_DUP_DEFINE
1       Pernicious (destructive) redefinition of a macro.
        This definition will *not* replace the previous definition; ignored.
        $.!
#PP_DUP_DEFINE_OK
1       Pernicious (destructive) redefinition of a macro.
        This definition will replace the previous definition.
        $.!
#PP_ERROR
2       Preprocessing #error directive encountered; text follows:
        $!
#PP_NOTE
1       Preprocessing #note directive encountered; text follows:
        $!
#PP_ILLEGAL_INCLUDE
2       Illegal #include directive; directive ignored.!
#PP_LONG_INCLUDE_NAME
2       Long #include header name "$"; will be truncated.!
#PP_OPEN_INCLUDE
2       Cannot open #include file "$";
        directive ignored.!
#PP_ILLEGAL_LINE
2       Illegal #line directive; ignored.!
#PP_UNKNOWN_PRAGMA
1       Unknown #pragma directive; directive ignored.!
#PP_EXTRA_DIRECTIVE
2       Extraneous "#$" encountered; ignored.!
#PP_NO_ENDIF
2       Terminating #endif expected for conditionally
        included group (e.g. after a #if 1); assumed.!
#PP_EXPRESSION
2       Illegal expression in #if/#elif directive; zero result assumed.!
#PP_BIG_INTEGER
1       The value of an integer in a #if/#elif expression is too large.!
#PP_ILLEGAL_ESCAPE
1       Unknown escape sequence within a character constant in
        a #if/#elif expressoin ; the backslash will be ignored.!
#PP_BIG_ESCAPE
1       The value of an escape sequence within a character constant in
        a #if/#elif expression is too large (larger than UCHAR_MAX).!
#PP_ZERO_DIVIDE
2       Divide-by-zero in #if/#elif directive; zero result assumed.!
#PP_LONG_TOKEN
2       Token too long "$"; will be truncated to 512 characters.!
#PP_NEWLINE_IN_CHAR
2       Newline within character constant; close quote assumed.!
#PP_NEWLINE_IN_STRING
2       Newline within string literal; close quote assumed.!
#PP_NEWLINE_IN_FILE_NAME
2       Newline within source file name; close delimiter assumed.!
#PP_MULTI_BYTE_CHAR
1       Error within multi-byte character constant.!
#PP_ILLEGAL_PARAMETERS
2       Illegal parameter list format in the definition of
        the function-like macro "$".  Definition ignored.!
#PP_DUP_PARAMETERS
2       Duplicate parameter name(s) in the definition of
        the function-like macro "$".  Definition ignored.!
#PP_TOO_MANY_PARAMETERS
2       Too many parameters in the definition of the function-like
        macro "$".  This implementation imposes a limit of 256.
        Definition ignored.!
#PP_HARMLESS_DUP_DEFINE
1       Harmless redefinition of the macro (different parameter names).
        $.!
#PP_ILLEGAL_STRINGIZE
2       Illegal stringize operator (#) in the definition of the
        function-like macro "$".  Note that this operator must precede
        a parameter in the replacement list.  Operator will be ignored.!
#PCC_WARN_STRINGIZE
1       Macro "$" contains a parameter within a string literal;
        parameter substitution therein would not be ANSI conforming.
        If this behavior is desired, use the "-xs" command-line option.!
#PCC_WARN_CHARIZE
1       Macro "$" contains a parameter within a character constant;
        parameter substitution therein would not be ANSI conforming.
        If this behavior is desired, use the "-xc" command-line option.!
#PCC_DO_STRINGIZE
1       The replacement list for the function-like macro "$"
        contains a parameter within a string literal; as requested,
        will perform non-ANSI conforming parameter substitution therein.!
#PCC_DO_CHARIZE
1       The replacement list for the function-like macro "$"
        contains a parameter within a character constant; as requested,
        will perform non-ANSI conforming parameter substitution therein.!
#PP_TOKEN_PASTE_RESULT
3       Illegal token-paste (##) result "$".  Note that the result of
        a token-paste operation must be ONE legal preprocessing token.
        Result will be ignored; incomplete macro expansion.!
#PP_LONG_STRINGIZE_TOKEN
3       Stringize (#) result too long "$".
        Resultant string literal will be shortened to 256 characters.!
#PP_ILLEGAL_TOKEN_PASTE
2       Illegal token-paste operator (##) in the definition of the macro
        "$".  Note that this operator may NOT occur at the beginning
        or the end of the replacement list.  Operator will be ignored.!
#PP_LONG_TOKEN_PASTE
3       Token-paste (##) result too long "$".
        Resultant token will be truncated to 256 characters.!
#PP_TOO_FEW_MACRO_ARGS
2       Too few arguments given in the invocation of the macro
        function "$"; null argument(s) will be supplied.!
#PP_TOO_MANY_MACRO_ARGS
2       Too many arguments given in the invocation of the macro
        function "$"; excess argument(s) will be discarded.!
#PP_NULL_MACRO_ARG
2       Null argument(s) given in the invocation
        of the function-like macro "$"; ignored.!
#PP_PARTIAL_MACRO_CALL
3       Partial invocation of the function-like macro "$" within an
        argument of an outer macro function invocation.  Note that
        each function-like macro argument is completely expanded AS IF
        it formed the rest of the source file.  Invocation terminated.!
#PP_MACRO_STACK_OVERFLOW
3       Macro expansion stack overflow due to too many nested macro
        invocations.  Incomplete macro expansion of "$".!
#PP_MACRO_ARG_STACK_OVERFLOW
3       Macro expansion stack overflow due to too many nested function-like
        macro arguments.  Incomplete macro expansion of "$".!
/*
/* ---------------------------------------------------------------------
/* Parser Errors
/* ---------------------------------------------------------------------
/*
#SYNTAX
4       Not a valid token in this context; correct any previous errors.!
#EXTRA_TEXT
3       Extraneous text follows the apparent syntactic end of program.!
/*
/* ---------------------------------------------------------------------
/* Front-End Lexical Errors (converting preprocessing tokens to tokens)
/* ---------------------------------------------------------------------
/*
#BIG_INTEGER
2       The value of this integer is too large to fit into any data type.!
#BIG_HEX_ESCAPE
1       The value of this hex escape sequence is too large (larger than UCHAR_MAX).! 
#BIG_OCTAL_ESCAPE
1       The value of this octal escape sequence is too large (larger than UCHAR_MAX).! 
#PREPROCESSOR_NUMBER
2       Illegal token; this pp-number is not a valid constant; ignored.!
#BAD_ESCAPE_SEQ
1       Undefined escape sequence; the backslash will be ignored.!
#PREPROCESSOR_OPERATOR
2       Illegal token; unexpanded preprocessing-operator; ignored.!
#PREPROCESSOR_TOKEN
2       Illegal token; ignored.!
#MULTI_BYTE_CHAR
1       Multi-byte character constants are machine dependent.!
/*
/* ---------------------------------------------------------------------
/* Generic Front-End Semantic Errors
/* ---------------------------------------------------------------------
/*
#GENERIC_SEV_1
1        $.!
#GENERIC_SEV_2
2        $.!
#GENERIC_SEV_3
3        $.!
#GENERIC_SEV_4
4        $.!
/*
/* ---------------------------------------------------------------------
/* Declaration Specifiers Errors
/* ---------------------------------------------------------------------
/*
#STORAGE_PLACEMENT
1       Placement of a storage-class specifier other than a the beginning of
        the declaration is an obsolescence feature.  Avoid this if possible.!
#DUP_TYPE_KEYWORD
1       Duplicate type keyword.!
#DUP_TYPE_QUAL
2       Duplicate type qualifier (i.e. "const" or "volatile").!
#INCONSISTENT_TYPE_KEYWORDS
2       Inconsistent type specifier keywords.!
#INCONSISTENT_TYPES
3       Inconsistent type specifiers.!
#TOO_MANY_STORAGE
2       At most, one storage-class specifier may be given in a declaration.!
#REG_FUN
2       The "register" storage class may not be used for function declarations.!
#AUTO_FUN
2       The "auto" storage class may not be used for function declarations.!
#STATIC_LOCAL_FUN
2       The "static" storage class may not be used for local scope
        function declarations.!
#AUTO_STORAGE
3       Automatic storage class may not be used outside a function block.!
#AUTO_EXTERN_STORAGE
2       The "auto" storage class may not be used for external declarations.!
#REG_EXTERN_STORAGE
2       The "register" storage class may not be used for external declarations.!
#BAD_EXTERN_STORAGE
2       Illegal storage class for this external declaration.!
#AUTO_MEMBER_STORAGE
2       The "auto" storage class may not be used for member declarations.!
#REG_MEMBER_STORAGE
2       The "register" storage class may not be used for member declarations.!
#EXTERN_MEMBER_STORAGE
2       The "extern" storage class may not be used for member declarations.!
#BAD_MEMBER_STORAGE
2       Illegal storage class for this member declaration.!
#EXTERN_PARAM_STORAGE
2       The "extern" storage class may not be used for parameter declarations.!
#STATIC_PARAM_STORAGE
2       The "static" storage class may not be used for parameter declarations.!
#TYPEDEF_PARAM_STORAGE
2       The "typedef" storage class may not be used for parameter declarations.!
#BAD_PARAM_STORAGE
2       Illegal storage class for this parameter declaration.!
#PARAM_UNDEF_CLASS
2       The parameter class type "$" for this function definition of "$"
        has not yet been defined.!
#CLASS_DCL_SPEC
2       A class declaration may not be decorated with any declaration specifiers.!
/*
/* ---------------------------------------------------------------------
/* Declarator Errors
/* ---------------------------------------------------------------------
/*
#FCT_RETURNS_FCT
2       A function may not return a function.!
#FCT_RETURNS_ARR
2       A function may not return an array.!
#ARR_OF_FCTS
2       An array of functions is not allowed.!
#TOO_MANY_PUNCTS
2       Too many *'s, ()'s, and/or []'s in this declarator (15 maximum).!
/*
/* ---------------------------------------------------------------------
/* Array and Dimension Declaration Errors
/* ---------------------------------------------------------------------
/*
#NEG_ARRAY_DIMENSION
1       A negative array dimension has been given; zero has been assumed.!
#ZERO_ARRAY_DIMENSION
1       An array dimension has been given as zero.!
#ARRAY_ZERO_SIZE
2       Incomplete array definition; array "$" is of unknown size.!
#MISSING_DIM_VALUE
1       Missing dimension value.!
#BAD_EVAL_DIM
2       The array dimension must be a compile time constant here;
        zero dimension has been assumed.!
/*
/* ---------------------------------------------------------------------
/* Function and Parameter Declaration Errors
/* ---------------------------------------------------------------------
/*
#PROTO_SCOPE_TAG
1        This tag is declared within a prototype scope; this is a dubious
         construct since the tag is visable only within this prototype scope,
         and this function won't be callable with the correct parameter type.!
#FCT_STOR_CLASS
3       Invalid storage class for function definition.!
#FCT_BODY
3       Function body can only follow a function declarator.!
#PROMOTE_PARAM
1       Note: This old-style parameter declaration is of unpromoted type
        (i.e. "char", "short", or "float") and will be implicitly adjusted
        (promoted) to a promoted type (i.e. "int" or "double").!
#PARAM_ADJUSTED_PTR_FCT
1       Parameter declaration adjusted to pointer-to-function.!
#PARAM_NAME
3       A parameter must be a a simple identifer.!
#PARAM_LIST
3       A parameter identifier list may be used only in a function definition.!
#PTR_TO_FCT
1       This class cannot be a function; adjusting to pointer-to-function.!
#BAD_AUTO_DCL_NAME
3       Declared name did not appear in the function parameter list.!
#HIDE_PARAM
3       This name has already been declared as a parameter.!
#UNNAMED_PARAM
1       There is an unnamed parameter in this function definition declarator.!
#DUP_PARAM_NAME
2       This parameter name has already been specified in the parameter list.!
#PARAM_REDCL
3       This is a redeclaration of this parameter.!
#PARAM_UNPROMOTED
3       This function was previously declared with an old-style declaration;
        thus, this prototyped declaration must be declared with paramaters
        of promoted types only (no "char", short" or "float" types).!
#PARAM_UNPROMOTED_PREV
3       This old-style function definition was illegally previously declared
        with a prototyped declaration with parameters of unpromoted types
        ("char", "short", or "float" types).!
#ELLIPSIS
3       This function was previously declared with an old-style declaration;
        thus, this prototyped declaration may not have an ellipsis terminator.!
#PARAM_TYPE_MISMATCH
3       This function declaration is incompatible with a previous
        declaration due to incompatible corresponding parameter(s).!
#PARAMS_OR_ELLIPSIS
3       This function declaration is incompatible with a previous declaration
        due to different number of arguments or use of the ellipsis terminator.!
#PARAM_IDENT_MISMATCH
3       Missing identifier(s) in parameter type list. For a function definition
        all must be included; for a declaration, all or none must be included.!
#ARG_TYPE_CONVERSION
1       Argument type of argument $ does not agree with the corresponding 
        parameter type of a prototyped function. Arguments to prototyped 
        functions are converted as-if-by-assignment, to the type of the
        corresponding parameters.!
#NUMBER_ARGUMENTS
3       The number of arguments specified in this function call
        is inconsistent with the declaration of this function.!
#TOO_FEW_ARGUMENTS
3       Too few arguments specified in this (prototyped) function call.!
#TOO_MANY_ARGUMENTS
3       Too many arguments specified in this (prototyped) function call.!
#PREV_CALL_OSFDEF
1       This function was called previously with a number of arguments
        or argument type(s) inconsistent with this old-style definition.!
#PREV_CALL_PROTOF
1       This function was called previously with a number of arguments or
        argument type(s) inconsistent with this prototyped declaration.!
#PREV_CALL_ARG_OSFDEF
1       This function was called previously with argument type(s) incompatible
        with corresponding parameter type(s) in this old-style definition.!
#PREV_CALL_ARG_PROTOF
1       This function was called previously with argument type(s) incompatible
        with corresponding parameter type(s) in this prototyped declaration.!
#PREV_CALL_NARG_OSFDEF
1       This function was called previously with a number of
        arguments inconsistent with this old-style definition.!
#PREV_CALL_NARG_PROTOF
1       This function was called previously with a number of
        arguments inconsistent with this prototyped declaration.!
#PROTOF_DCL_LIST
2       A prototyped function definition may not contain
        an old-style parameter declaration list.!
#BYPASS_CONSTRUCTOR
1       Argument will be copied as a data structure rather
        than using its copy constructor, because it does not match
        a formal argument.!
/*
/* ---------------------------------------------------------------------
/* Prototyped function decaration vs. Prototyped function declaration.
/* ---------------------------------------------------------------------
/*
#PROTOF_ELLIPSIS
2       This prototyped function declaration is incompatible with a previous
        prototyped declaration due to the use of the ellipsis terminator.!
#PROTOF_LESS_PARAMS
2       This prototyped function declaration is incompatible with a previous
        prototyped declaration due to fewer parameters being specified.!
#PROTOF_MORE_PARAMS
2       This prototyped function declaration is incompatible with a previous
        prototyped declaration due to more parameters being specified.!
#PROTOF_PARAM_TYPES
2       This prototyped function declaration is incompatible with a previous
        prototyped declaration due to incompatible corresponding parameter types.!
/*
/* ---------------------------------------------------------------------
/* Old-style function decaration vs. Prototyped function declaration.
/* ---------------------------------------------------------------------
/*
#OSFDCL_PROTOF_ELLIPSIS
2       This function was previously declared with an old-style declaration;
        thus, this prototyped declaration may not use an ellipsis terminator.!
#OSFDCL_PROTOF_UNPROMOTED
2       This function was previously declared with an old-style function
        declaration; thus, this prototyped declaration must be declared with
        parameters of promoted types only (no "char", short", or "float" types).!
/*
/* ---------------------------------------------------------------------
/* Old-style function definition vs. Prototyped function declaration.
/* ---------------------------------------------------------------------
/*
#OSFDEF_PROTOF_ELLIPSIS
2       This function was previously defined with an old-style definition;
        thus, this prototyped declaration may not use an ellipsis terminator.!
#OSFDEF_PROTOF_UNPROMOTED
2       This function was previously defined with an old-style function
        definition; thus, this prototyped declaration must be declared with
        paramaters of promoted types only (no "char", short", or "float" types).!
#OSFDEF_PROTOF_LESS_PARAMS
2       This prototyped function is incompatible with a previous old-style
        function definition due to fewer parameters being specified.!
#OSFDEF_PROTOF_MORE_PARAMS
2       This prototyped function is incompatible with a previous old-style
        function definition due to a more parameters being specified.!
#OSFDEF_PROTOF_PARAM_TYPES
2       This prototyped function is incompatible with a previous old-style
        function definition due to incompatible corresponding parameter types.!
/*
/* ---------------------------------------------------------------------
/* Prototyped function declaration vs. Old-style function declaration.
/* ---------------------------------------------------------------------
/*
#PROTOF_OSFDCL_ELLIPSIS
2       This old-style function declaration is incompatible with a previous
        prototyped declaration due to the use of the ellipsis terminator.!
#PROTOF_OSFDCL_UNPROMOTED
2       This old-style function declaration is incompatible with a previous
        prototyped declaration due to use of unpromoted parameter types
        ("char", "short", or "float") in the prototyped parameter type list.!
/*
/* ---------------------------------------------------------------------
/* Prototyped function definition vs. Old-style function definition.
/* ---------------------------------------------------------------------
/*
#PROTOF_OSFDEF_ELLIPSIS
2       This old-style function definition is incompatible with a previous
        prototyped declaration due to the use of the ellipsis terminator.!
#PROTOF_OSFDEF_UNPROMOTED
2       This old-style function definition is incompatible with a previous
        prototyped declaration due to use of unpromoted parameter types
        ("char", "short", or "float") in the prototyped parameter type list.!
#PROTOF_OSFDEF_LESS_PARAMS
2       This old-style function definition is incompatible with a previous
        prototyped declaration due to fewer parameters being specified.!
#PROTOF_OSFDEF_MORE_PARAMS
2       This old-style function definition is incompatible with a previous
        prototyped declaration due to more parameters being specified.!
#PROTOF_OSFDEF_PARAM_TYPES
2       This old-style function definition is incompatible with a previous
        prototyped declaration due to incompatible corresponding parameter types.!
#DUP_VOID_PARAM
2       A function with a "void" parameter may contain no others.!
#NAMED_VOID_PARAM
1       A "void" parameter should have no associated parameter name.!
#DUP_ELLIPSIS
2       An ellipsis terminator may be specified only once, at the end
        of a parameter type list, e.g. "void f (int, ...)"; ignored.!
#PROTOF_PARAM_DCL
2       A prototyped function definition may not contain
        an old-style function parameter declaration list.!
/*
/* ---------------------------------------------------------------------
/* Miscellaneous Declaration Errors
/* ---------------------------------------------------------------------
/*
#TYPE_ZERO_SIZE
1       The size of the type in this declaration is either zero or unknown.!
#UNKNOWN_SIZE
1       Unknown size (incomplete type).!
#FUN_TYPEDEF
1       A function may not be defined via a "typedef" of type function.!
#NO_DECLARATOR
1       A declaration must declare at least a declarator, a tag, or an enumerator.!
#NO_MEMBER_DECLARATOR
2       A member declaration must declare at least a declarator,
        a bit-field, a tag, or an enumerator; ignored.!
#NULL_MEMBER
2       **OBSOLETE**!
#ITERATION_DECLARATION
3       This declaration statement is the statement of a "while",
        "do", or "for" loop.!
/*
/* ---------------------------------------------------------------------
/* Class, Struct, Union, & Enum Declaration Errors
/* ---------------------------------------------------------------------
/*
#ANON_UNION_FUN_MEMBER
2       An anonymous union may not have function members.!
#PRIVY_ANON_UNION_MEMBER
2       An anonymous union may not have private or protected members.!
#ANON_UNION_MEMBER_REDCL
2       A member of this anonymous union has been previously declared in this
        scope. N.B. anonymous union members reside in the same scope in which
        the unnamed union is declared (similar to the scoping of enumerators).!
#DUP_MEMBER_NAME
3       A member with this name has already been declared.!
#NON_UNIQUE_MEMBER
2       **OBSOLETE**!
#STRUCT_UNION_SIZE
2       **OBSOLETE**!
#BAD_MEMBER
2       A member cannot be an instance of a containing structure or union.!
#NON_CONSTANT_ENUM
2       An enumerator initializer must specify an integral constant expression.!
#ENUM_TRAILING_COMMA
1       Extraneous comma in enumerator list; ignored.!
#BIG_ENUM
2       The value of this enumeration constant is too large to fit into an "int".!
#ZERO_ARRAY_MEMBER_SIZE
2       This array member is of unknown size; the dimension must be specified.!
#UNDEF_CLASS_OBJECT
3       "$" is an undefined class and may not be specified as the type of
        an object, or array element.!
#NEST_TYPE_NAME
3       A class/struct/union tag or "typedef" definition within a class
        (i.e. a nested type-name definition) may not define a name which
        is the same as its enclosing class.!
#MEMBER_NAME
3       A nested tag, typedef, enumerator, anonymous union member, or
        static data member may not have the same name as its enclosing
        class or any of the direct base classes of its enclosing class.!
#UNCONSTRUCTIBLE
3       A constructor must be declared for this class because one of its
        members needs to be initialized explicitly.!
#TODO_GEN_CTOR
3       Sorry, the compiler did not generate a needed constructor
        for class "$".!
#TODO_GEN_DTOR
3       Sorry, the compiler did not generate a needed destructor
        for class "$".!
/*
/* ---------------------------------------------------------------------
/* Bit-Field Declaration Errors
/* ---------------------------------------------------------------------
/*
#ZERO_WIDTH_BIT_FIELD
1       A bit-field of zero width should have no declarator;
        aligning to the next field.!
#BIG_BIT_FIELD
2       The size of this bit-field exceeds the number of bits for its type.!
#BAD_BIT_FIELD
2       A bit-field may not be a derived (pointer/reference/array/function) type.!
#BIT_FIELD_TYPE
3       A bit-field must be specified as a (signed or unsigned) integral type.!
#BIT_FIELD_SIZE
3       A bit-field size must be specified as a non-negative
        integral constant expression.!
#BIT_FIELD_TYPE_WARN
1       In ANSI-C, a bit-field must be of type "int" (signed or unsigned);
        this integral type will be allowed, with appropriate maximum width.!
#NO_BASE_TYPE
1       Note: No base type was specified, defaulting to "int".!
#STORAGE_BIT_FIELD
2       A bit-field declaration may not specify a storage class.!
#FRIEND_BIT_FIELD
2       A bit-field declaration may not be specified as a friend.!
#FUN_BIT_FIELD
2       A bit-field declaration may not specify any function specifiers.!
#BIT_FIELD_PLACEMENT
2       A bit-field specify is not allowed in this context.!
/*
/* ---------------------------------------------------------------------
/* Initialization Errors
/* ---------------------------------------------------------------------
/*
#DUP_INITIAL
2       Duplicate initialization of this identifier.!
#AUTO_INITIALIZER
2       Aggregate "register" objects may not be initialized.!
#CLASS_INITIALIZER
3       Invalid storage class for an initializer.!
#TOO_MANY_ARRAY
2       Too many initial values for this array.!
#ARRAY_INITIAL_ARGS
2       An array initializer may not have arguments.!
#NEEDS_DEFAULT_CTOR
3       An array must be initialized here,
        but "$" has no default constructor.!
#TOO_MANY_STRUCT
2       Too many initial values for structure/union.!
#TOO_MANY_SCALAR
2       More than one initial value for this scalar.!
#TOO_MANY_STRINGS
2       More than one initial constant string for this array of characters.!
#TOO_MANY_CHAR_ARRAY
2       Too many initial values for this array of characters.!
#BAD_INITIAL_EXPR
3       Invalid initial expression; must be a constant-expression.!
#BAD_INITIAL_DECLARATION
4       Invalid initializer token; an expression, "{", "}", or "," expected.!
#NOT_CHAR_ARRAY
3       The target type of a string literal initializer must be of
        type pointer-to-char (char *) or array-of-char (char []).!
#BAD_INITIAL_PTR
3       Invalid initial value for pointer type.!
#BAD_INITIAL_FIELD
3       Invalid initial expression for a bit-field.!
#EXCESS_INITIAL_VALUES
3       Excess initial value(s) ignored.!
#BAD_INITIAL_PLACEMENT
2       Illegal attempt to initialize an "extern" identifier
        with block scope.  Initializer will be ignored.!
#UNKNOWN_INITIAL_SIZE
3       This is an incomplete type which cannot be initialized. Its size
        must be known prior to initialization.!
#UNINITIALIZED_CONSTANT
2       An object declared "const" must be initialized.!
/*
/* ---------------------------------------------------------------------
/* Redeclared, Undeclared, and Linkage Errors
/* ---------------------------------------------------------------------
/*
#NAME_REDCL
3       This is a redeclaration of this name, or this name has been previously
        declared with a type incompatible with the type of this declaration.!
#EXTERN_NAME_REDCL
1       This identifier was previously declared in a different scope, with
        external linkage, and a type incompatible with this declaration.!
#UNDECLARED_ID_EXTERN
2       Undeclared identifier; was previously declared in a different scope with
        external linkage, will assume this identifier is a reference to that one.!
#EXTERN_INTERN_LINKAGE
1       This identifier was previously declared with external linkage, and is thus
        in conflict with this internal linkage declaration; will assume that all
        such declarations are intended to refer to the same internal linkage entity.!
#EXTERN_VS_STATIC
1       This matches a previous declaration except for "extern" vs. "static".!
#FCT_REDEF
3       This is a redefinition of this function.!
#UNDECLARED_ID_INT
3       Undeclared identifier; implicitly declaring as type "int".!
#IMPLICIT_OLD_PARAM_DCL
1       Undeclared old-style parameter; implicitly declaring as type "int".!
#COMPAT_REDCL
2       This identifer has been previously declared.!
#LOCAL_REDCL
2       This identifer has already been declared in this (local) scope.!
#INCOMPAT_REDCL
3       This identifier has been previously declared with a type
        which is incompatible with the type of this declaration.!
#REDEFINITION
3       "$" has been previously defined.!
#TENTATIVE_DEFN_OBJ
3       Tentative definition of object with constructor
        and/or destructor.!
#REDEFINITION_OBJECT
3       Redefinition of object with constructor or destructor.!
#UNDEF_STATIC_FUN
1       Function "$" was declared with internal linkage but was never defined.!
#NO_EXTERN_DEF
1       This compilation unit contains no external definitions.!
#UNDEF_FUNCTION_WARN
1       Undeclared function; implicitly declaring as "extern int $()".!
#UNDEF_FUNCTION
2       Function "$" has not been declared.!
#INTERN_EXTERN_LINKAGE
2       This external linkage identifier was previously declared in this
        scope with internal or no linkage; will ignore this declaration.!
#TYPEDEF_SPEC
2       A "typedef" declaration may not contain any "friend", "virtual",
        "inline", or "overload" specifiers.!
#TYPEDEF_BIT_FIELD
2       A "typedef" declaration may not specify a bit-field.!
#NON_TYPE_TYPEDEF_REDCL
3       This "typedef" name was previously declared as a non-type in this scope.!
#TYPEDEF_NON_TYPE_REDCL
3       This name was previously declared as a "typedef" in this scope.!
#TYPE_NON_TYPE_REDCL
1       This identifier was previously declared as a class with a constructor in this scope.!
#NON_TYPE_TYPE_REDCL
1       The name of this class (which has a constructor) was
        previously declared as a non-type in this scope.!
#TYPEDEF_TAG_REDEF
3       Illegal attempt to redefine a type name; this tag name has been
        previously defined as a "typedef" name in this scope.!
#TAG_TYPEDEF_REDEF
3       Illegal attempt to redefine a type name; this "typedef" name has been
        previously defined as a tag name in this scope.  This is legal only
        if they define the same types, for example "struct s; typedef s s;".!
#TYPEDEF_TYPEDEF_REDEF
3       Illegal attempt to redefine a type name; this "typedef" name has been
        previously defined as a "typedef" name in this scope.  This is legal
        only if they define exactly same types.!
#TAG_TAG_REDEF
2       This tag name has been  previously defined as a different kind
        of tag (i.e. class, struct, union, enum) in this scope.!
#TYPE_HIDDEN_BY_NON_TYPE
1       This type name has been hidden by a previous non-type declaration of
        the same name in the same scope; qualify the name with the appropriate
        class, struct, union, or enum keyword if the type is to be referenced.!
#TYPEDEF_NAME
2       A "typedef" declaration must declare a plain old-fashioned unqualified name.!
#UNDEF_QUAL_NAME
3       This qualified name has not been previously declared within
        the named class.!
#QUAL_NAME_TYPE
3       This qualified name is not compatible with any member of the
        of the same name of the named class.!
#QUAL_NAME
3       Qualified declarator names may only appear at global scope to define
        static data members or member functions, or in friend declarations,
        or to (redundantly) qualify class member declarations.!
#MEMBER_QUALIFIED_NAME
3       Member name declarations may only be qualified (redundantly)
        with the name of enclosing class.!
#GLOBAL_QUALIFIED_NAME
3       The global scope qualifier may not be used in declarations.!
#BIT_FIELD_NAME
2       A bit-field declaration must declare a plain old-fashioned unqualified name.!
/*
/* ---------------------------------------------------------------------
/* Compiler Errors
/* ---------------------------------------------------------------------
/*
#SEM_STACK_OVERFLOW
4       Compiler inconsistency (semantic stack overflow).
        Contact compiler support personnel.!
#SEM_STACK_UNDERFLOW
4       Compiler inconsistency (semantic stack underflow).
        Contact compiler support personnel.!
/*
/* ---------------------------------------------------------------------
/* New messages
/* ---------------------------------------------------------------------
/*
#ABSTRACT_CLASS_OBJECT
3       "$" is an abstract class (it has/inherits a pure virtual function)
        and may not be specified as the type of an object, member, parameter,
        function, array element; it may be used as the type of a pointer or
        reference, or as a base class.!
#ABSTRACT_CLASS_FUN
3       **OBSOLETE**!
#UNDEF_SCOPE_QUALIFIER
3       This class has not been previously defined; a class (scope) must
        be defined before its name may be used as a class scope qualifier.!
#UNDEF_BASE_CLASS
3       This identifier is not a previously defined class; a class must be
        defined before it may be used as a base class (i.e. derived from).!
#AMBIG_BASE_CLASS_REF
2       This is an ambiguous reference to a base
        class ($) from a derived class ($).!
#AMBIG_BASE_MEMBER_REF
2       This is an ambiguous member reference; it is a member
        of both class "$" and class "$".!
#DERIVED_UNION
3       A union may not specify base class (i.e. a union may not be derived).!
#BASE_CLASS_UNION
3       A union may not be specified as a base class
        (i.e. a union may not be derived from).!
#STATIC_UNION_MEMBER
2       A union may not have static members.!
#VIRTUAL_UNION_MEMBER
2       A union may not have virtual members.!
#VIRTUAL_STATIC
2       A virtual member function may not be declared "static".!
#PURE_SPEC
2       A pure specifier may only be applied to "virtual" member functions.!
#NON_ZERO_PURE_SPEC
2       A pure specifier for a virtual member function must specify a
        zero-valued constant expression; ignored.!
#REDEF_CLASS
3       This class has been previously defined.!
#REDEF_FUN_MEMBER
2       This member function has been previously declared in this class;
        it is not sufficiently different from any previous declaration
        to allow for overloading.!
#REDCL_FUN
2       This function has been previously declared with a type that is neither
        compatible with, nor sufficiently distinct (to overload) from, this type.!
#REDEF_MEMBER
2       This member has been previously declared; ignored.!
#DUP_FUN_MEMBER_DEF
2       This member function has been previously defined.!
#REDEF_CTOR_MEMBER
2       This member (which has the same name as the containing class name)
        has been previously declared as a constructor; ignored.!
#REDEF_MEMBER_CTOR
2       This constructor name has been previously declared as a (non-function)
        member; ignored.!
#DTOR_BUT_NO_CTOR
1       This class defined a destructor but no constructor.!
#OBJECT_UNION_MEMBER
3       An object of a class with a destructor, constructor, or user-defined
        assignment operator may not be a member of a union.!
#REDEF_FUN
2       This function has been previously defined.!
#OLD_PAR_DCL_PLACEMENT
3       An old-style parameter declaration list must follow a function
        declaration and must preceed a function body definition.!
#FUN_BODY_PLACEMENT
3       A function body must be preceeded by a function type declaration.!
#MAX_DERIVED_TYPE_LEVEL
3       Too many derived types (e.g. pointer-to, reference-to, array-of,
        or function-returning) in one declarator; a maximum total of 16
        is currently supported (including any/all expanded typedefs).!
#LINKAGE_PLACEMENT
2       A linkage specifier may only occur at file scope.!
#UNKNOWN_LINKAGE
2       This is an unknown linkage specification;
        only "C" and "C++" are currently implemented.!
#CONFLICT_LINKAGE
2       This name has been previously declared with a conflicting or absent
        linkage specification; ignored.!
/*
/* ---------------------------------------------------------------------
/* Base and Member Initialization Errors
/* ---------------------------------------------------------------------
/*
#MEMBER_INIT_LIST_PLACEMENT
3       A member initialization list is permitted only for a constructor.!
#NOT_BASE_OR_MEMBER
2       "$" is not a member or base class of "$".!
#OMITTED_BASE_NAME
1       Omission of the base class name $ is an anachronism.!
#BASE_NAME_REQUIRED
2       "$" has more than one base class; name of base class to
        initialize is required.!
#NO_BASE_TO_INIT
2       "$" has no base class; name of member to initialize is required.!
#NOT_DIRECT_MEMBER
2       "$" is an inherited member of "$"; it is initialized via the base class.!
#NOT_IMMEDIATE_OR_VIRTUAL
2       "$" is neither an immediate nor a virtual base class of "$".!
#BAD_MEMBER_FUNC_INIT
2       A member function must be initialized in a declaration,
        not in the member initializer of a constructor.!
#BAD_STATIC_MEMBER_INIT
2       A static data member must be initialized in a declaration,
        not in the member initializer of a constructor.!
#NO_DEFAULT_CTOR
2       Every constructor for "$" requires one or more arguments,
        but no initializer or argument is provided here.!
#NEED_INIT_FOR_MEMBER
2       An explicit member initializer is required here
        in order to construct member $.!
#NEED_INIT_FOR_BASE
2       An explicit base initializer is required here
        in order to construct base class $.!
#DUPLICATE_MEMBER_INIT
2       "$" has been initialized more than once in this base/member
        initializer list.!
/*
/* ---------------------------------------------------------------------
/* Class Derivation Errors
/* ---------------------------------------------------------------------
/*
#DUP_BASE_CLASS
2       Duplicate base class for this derived class definition; ignored.!
#DUP_VIRTUAL_BASE_CLASS_SPEC
2       Duplicate "virtual" base class specifier; ignored.!
#INCONSISTENT_BASE_CLASS_SPEC
2       Confilicting or duplicate base class specifiers; ignored.!
#DEFAULT_PRIVATE_DERIVATION
1       Note: No base class access specifier given; default to "private".!
#SELF_REF_BASE_CLASS
2       A class may not be derived from itself.!
#CTOR_RETURN_TYPE
2       Constructor functions should specify no return value.!
#DTOR_RETURN_TYPE
2       Destructor functions should specify no return value.!
#DTOR_NOT_FUN
2       A destructor name must declare a function type.!
#DTOR_PARAM_TYPE
2       Destructor functions may specify no parameters.!
#WRONG_DTOR
3       This destructor is not of (doesn't have the same name as) this class.!
#NON_MEMBER_DTOR
3       A destructor must be a member function.!
#QUALIFIED_CDTOR
2       A constructor or destructor may not be declared as "const" or "volatile".!
#STATIC_CDTOR
2       A constructor or destructor may not be declared as "static".!
#VIRTUAL_CTOR
2       A constructor may not be declared as "virtual".!
#OP_FUN_PLACEMENT
3       This operator function must be declared as a non-static member function.!
#NON_MEMBER_CONV
3       A conversion function must be a member function.!
#CONV_NOT_FUN
2       A conversion name must refer to a function
        (with no return value and no  parameters).!
#CONV_RETURN_TYPE
2       Conversion functions should specify no return value.!
#CONV_PARAM_TYPE
2       Conversion functions should specify no parameters.!
#OPERATOR_FUN
2       An operator name must refer to a function.!
#VIRTUAL_NEW_DELETE_OP
2       The "new" and "delete" operators may not be "virtual" member functions.!
#STATIC_NEW_DELETE_OP
1       Note: operators "new" and "delete" as member function are implicitly static.!
#NEW_OP_PARAM_TYPE
2       The "new" operator must specify a first parameter of type "size_t".!
#NEW_OP_RETURN_TYPE
2       The "new" operator must specify a "void *" return type.!
#DELETE_OP_RETURN_TYPE
2       The "delete" operator must specify a "void" return type.!
#MEMBER_DELETE_OP_PARAM_TYPE
2       The "delete" operator member function must specify a first parameter
        of type "void *", and an optional second parameter of type "size_t".!
#DELETE_OP_PARAM_TYPE
2       The "delete" operator non-member function must specify one parameter
        of type "void *".!
#OVERLOAD_DELETE
3       The "delete" operator may not be overloaded.!
#EOF_MEMBER_FUN
3       End-of-file encountered while collecting a member function
        body within a class declaration.!
#MEMBER_FUN_NO_RETURN
1       This member function specifies no return value; assuming "int".!
#FRIEND_FUN_NO_RETURN
1       This friend function specifies no return value; assuming "int".!
#ONLY_MEMBER_FRIENDS
2       Friend declarations may only be specified within a class definition.!
#UNDEF_QUAL_FRIEND
2       The qualified name specified in this friend declaration is not a
        member of the specified class.!
#BAD_FRIEND
2       This "friend" specifier may only be used within a class definition.!
#BAD_VIRTUAL
2       The "virtual" specifier may only be used within a
        class definition for a member function declaration.!
#BAD_INLINE
2       The "inline" specifier may only be used for a non-extern function declaration.!
#FUN_SPEC_PARAM
2       A parameter declaration may not specify any
        function specifiers; ignored.!
#WARN_OVERLOAD
1       The "overload" specifier is an obsolescence feature; it is not
        portable and may not be supported in future implementations.
        Avoid its use if possible.!
/*
/* ---------------------------------------------------------------------
/* Friend Declaration Errors
/* ---------------------------------------------------------------------
/*
#BEFRIEND_MEMBER
2        A class may not befriend one of its own members.!
#FRIEND_TYPE
2        Only function or class types may be declared as friends.!
#DUP_FRIEND
2        This identifier was already declared to be a friend of this class.!
#FRIEND_MEMBER
2        This friend was previously declared as a member of this class.!
#FRIEND_STRUCTOR
2       Constructors/destructors are *member* functions and therefore
        may not be declared as friends of the containing class.!
#FRIEND_STORAGE
2       A friend declaration may not specify a storage class; ignored.!
#FRIEND_SPEC
2       A friend declaration may not specify any function specifiers; ignored.!
/*
/* ---------------------------------------------------------------------
/* Member Access Adjustment Declaration Errors
/* ---------------------------------------------------------------------
/*
#NULL_ACCESS_DCL
2       A member access declaration must specify a base class member name.!
#TYPE_ACCESS_DCL
2       A member access declaration may not specify a type.!
#STORAGE_ACCESS_DCL
2       A member access declaration may not specify any storage class
        specifiers.!
#FUN_ACCESS_DCL
2       A member access declaration may not specify any function specifiers.!
#FRIEND_ACCESS_DCL
2       A member access declaration may not specify a friend specifier.!
#ACCESS_DCL
2       A member access declaration is not allowed within "private"
        sections, only within "public" or "protected" sections.!
#DERIVED_ACCESS_DCL
2       A member access declaration may be used only in a derived class.!
#BASE_ACCESS_DCL
2       The class qualifier for this member access declaration is not a
        base class of this derived class.!
#ACCESS_DERIVED
2       Access to a base class member may not be adjusted in a
        derived class which also defines a member of that name.!
/*
/* ---------------------------------------------------------------------
/* Compiler Errors
/* ---------------------------------------------------------------------
/*
#DCL_STATE_STACK_OVERFLOW
4       Compiler inconsistency; declaration state stack overflow.!
#DCL_STATE_STACK_UNDERFLOW
4       Compiler inconsistency; declaration state stack underflow.!
#NAME_STATE_STACK_OVERFLOW
4       Compiler inconsistency; name state stack overflow.!
#NAME_STATE_STACK_UNDERFLOW
4       Compiler inconsistency; name state stack underflow.!
#CLASS_STATE_STACK_OVERFLOW
4       Compiler inconsistency; class state stack overflow.!
#CLASS_STATE_STACK_UNDERFLOW
4       Compiler inconsistency; class state stack underflow.!
#SIG_STATE_STACK_OVERFLOW
4       Compiler inconsistency; signature state stack overflow.!
#SIG_STATE_STACK_UNDERFLOW
4       Compiler inconsistency; signature state stack underflow.!
#LINK_STATE_STACK_OVERFLOW
4       Compiler inconsistency; linkage state stack overflow.!
#LINK_STATE_STACK_UNDERFLOW
4       Compiler inconsistency; linkage state stack underflow.!
#SCOPE_STATE_STACK_OVERFLOW
4       Compiler inconsistency; scope state stack overflow.!
#SCOPE_STATE_STACK_UNDERFLOW
4       Compiler inconsistency; scope state stack underflow.!
#TYPE_STATE_STACK_OVERFLOW
4       Compiler inconsistency; type state stack overflow.!
#TYPE_STATE_STACK_UNDERFLOW
4       Compiler inconsistency; type state stack underflow.!
#DIM_STACK_OVERFLOW
4       Compiler inconsistency; array dimension stack overflow.!
#DIM_STACK_UNDERFLOW
4       Compiler inconsistency; array dimension stack underflow.!
#SIG_STACK_OVERFLOW
4       Compiler inconsistency; function signature stack overflow.!
#SIG_STACK_UNDERFLOW
4       Compiler inconsistency; function signature stack underflow.!
#CLASS_STACK_OVERFLOW
4       Compiler inconsistency; member-pointer class stack overflow.!
#CLASS_STACK_UNDERFLOW
4       Compiler inconsistency; member-pointer class stack underflow.!
#DERIVED_TYPE_STACK_OVERFLOW
4       Compiler inconsistency; derived type stack overflow.!
#DERIVED_TYPE_STACK_UNDERFLOW
4       Compiler inconsistency; derived type stack underflow.!
#TYPEQ_STACK_OVERFLOW
4       Compiler inconsistency; derived type qualifier stack overflow.!
#TYPEQ_STACK_UNDERFLOW
4       Compiler inconsistency; derived type qualifier stack underflow.!
#FUN_TYPEQ_STACK_OVERFLOW
4       Compiler inconsistency; function type qualifier stack overflow.!
#FUN_TYPEQ_STACK_UNDERFLOW
4       Compiler inconsistency; function type qualifier stack underflow.!
#NODE_STACK_OVERFLOW
4       Compiler inconsistency; node stack overflow.!
#NODE_STACK_UNDERFLOW
4       Compiler inconsistency; node stack underflow.!
#LOOP_STK_OVER
4       Compiler inconsistency; loop stack overflow.!
#LOOP_STK_UNDER
4       Compiler inconsistency; loop stack underflow.!
#ASSERT_FAIL
4       Compiler inconsistency.!
/*
/* ---------------------------------------------------------------------
/* Statement Control Errors
/* ---------------------------------------------------------------------
/*
#DUP_LABEL_NAME
2       Label duplicates another declaration of "$" in this function.!
#DUP_CASE
3       Duplicate case label.!
#DUP_DEFAULT
3       A "default" for this switch has already been seen.!
#BAD_CASE_NUMBER
3       Invalid case number.!
#BAD_CASE_OR_DEFAULT
3       This "case" or "default" is not within any switch block.!
#BAD_BREAK
3       This "break" is not within any loop or switch block.!
#BAD_CONTINUE
3       This "continue" is not within any loop.!
#NO_RET_VALUE
2       This function can not return a value.!
#NEEDS_RET_VALUE
1       This function may return with no value to a caller
        which requires a value.!
#REQUIRES_RET_VALUE
3       Return without expression from a function with a non-void
        return type.!
#BYPASS_INIT
3       A jump to this label bypasses the initializing statement
        for "$".!
#SWITCH_BYPASS_INIT
3       Entering switch at this case bypasses the initializing
        statement for "$".!
#DESTRUCT_LABEL
3       This label is preceded in this block by objects which
        require destruction.!
/*
/* ---------------------------------------------------------------------
/* Expression Errors
/* ---------------------------------------------------------------------
/*
#INT_CONST_EXPR_REQ
2       An integer constant expression is required here.!
#INT_IS_REQD
2       An integer value is required here.!
#SUBSCRIPT_OPERAND
3       Neither of the operands of this "[]" is a pointer type.!
#NONARITH_PLUS
2       The operand of the unary plus operator (+) must be arithmetic type.!
#NONARITH_MINUS
2       The operand of the unary minus operator (-) must be arithmetic type.!
#NONARITH_ADD
2       The left and right operands of the addition operator (+) must
        both be arithmetic type, or pointer and integral type.!
#PTR_NONINT_ADD
2       An integral type is required for array subscripting and pointer addition.!
#NONARITH_SUB
2       The left and right operands of the subraction operator (-) must both
        be arithmetic type, pointer and integral type, or both pointer type.!
#PTR_NONINT_SUB
2       Only an integral or a pointer type may be subtracted from a pointer.!
#NONARITH_MUL
2       The operands of the multiplication operator (*) must be arithmetic type.!
#NONARITH_DIV
2       The operands of the division  operator (*)must be arithmetic types.!
#NONINT_MOD
2       The operands of the remainder operator (%) must be integral type.!
#NONINT_BITOP
2       The operands of the bitwise operators (|,&,^,<<,>>) must be integral type.!
#BAD_PTR_INT_ARITH
2       Zero or unknown sized object for pointer+int or pointer-int.!
#BAD_CONVERSION_VALUE
3       Invalid conversion; this is not a value.!
#CONVERSION_ARR_FCT
3       Invalid conversion of an array or function.!
#CONVERSION_STRUCT
3       Illegal attempt to convert a class, struct, or union to an incompatible type.!
#CONVERT_FROM_VOID
3       A "void" expression is evaluated for its side effects only. Explicit
        or implicit conversions may not be applied (except to "void").!
#USE_OF_LABEL
3       A label name can be used only in a "goto" statement.!
#BAD_CONVERSION
3       Invalid conversion; cannot convert to this result type.!
#NO_CONSTRUCTOR
3       The type being initialized has no constructor, but its initializer
        has 2 or more constructor arguments.!
#NON_LVALUE_ARRAY
1       An lvalue is required to convert "array of type" to "pointer to type".!
#UNARY_ADDR_LVALUE
3       The argument of the address-of operator (&) must be an lvalue.!
#NOT_AN_LVALUE
1       An lvalue is required here.!
#UNARY_ADDR_FIELD
3       The address-of operator (&) may not be applied to a bit-field.!
#UNARY_ADDR_LABEL
2       Unary "&" cannot be applied to a label name.!
#UNARY_ADDR_REG
2       Unary "&" cannot be applied to a "register" variable.!
#DISSIMILAR_ENUM_TYPES
1       Comparison of different enumeration types.!
#REQ_VOID_IN_CONDITIONAL
1       Incompatible types as second and third operands of conditional. The 
        "0" operand is being implicity cast to "void"; try explicit casting.!
#BAD_VOID_IN_CONDITIONAL
3       Incompatible types as second and third operands of conditional. If
        one operand has type "void", then both operands must have type "void";
        try explicit casting.!
#NOT_CONST_PTR_EXPR
3       This pointer valued initial expression is not a constant.!
#BAD_DEREFERNCE
3       An array subscript "[]" or a unary indirection "*"
        can be applied only to an array or pointer type.!
#NOT_CLASS_STRUCT_UNION
3       The name of the left of this member access operator "." or "->"
        does not refer to a class, struct, or union.!
#NOT_A_MEMBER
2       The name to the right of this member access operator is not a member
        of the class, struct, or union referenced on the left.!
#NOT_MEMBER_NAME
3       The name on right is not a structure or union member name.!
#SIZEOF_UNKNOWN
2       Operand of "sizeof" is of unknown size; zero value being used.!
#SIZEOF_BIT_FIELD
1       Operand of "sizeof" cannot designate a bit-field.!
#SIZEOF_FUNCT
3       Operand of "sizeof" cannot designate a function.!
#SIZEOF_RET_ZERO
1       Sizeof returns a zero value.!
#BAD_LVALUE_ASSIGN
3       Left side of assignment is not an lvalue as required.!
#NOT_STRUCT_UNION
3       Name on left of "." or "->" does not refer to a structure/union.!
#EVAL_FCT_DOT_MEMBER
2       Cannot do "function().member" from debugger.!
#NOT_A_FCT
3       This is not a function.!
#NOT_PRIMARY_EXPR
3       Left of "()" is not a primary expression.!
#BAD_CAST
2       Illegal cast to an array or function type; cast only to scalar types.
        Try casting to the array element or function return type instead.!
#CAST_STRUCT_UNION
3       Illegal cast to a class, struct, or union type; cast only to scalar types.
        To get this effect, cast to the pointer-to type, then de-reference it.!
#ILLEGAL_CONST_ACCESS
3       Illegal attempt to modify a "const" object.!
#UNKNOWN_PTR_SUBTR_SIZE
2       Illegal pointer subtraction; pointer(s) may not point to
        function types or types of unknown size (incomplete types).!
#ZERO_DIVIDE
1       Division by zero is not defined.!
#TOO_MANY_ARGS
2       Number of arguments exceeds implementation limit.!
#PASS_AS_PTR_TO
2       An array must be passed as a pointer-to type.!
#MUST_BE_INTEGRAL
2       Operand(s) must be of integral type.!
#ILLEGAL_MEMBER_FUN
3       Illegal use of a member function.!
#NEW_FUNCTION
2       Type of new object must not be function.!
#NEW_REFERENCE
2       Type of new object must not be reference.!
#NEW_INCOMPLETE
2       Type of new object is incomplete;
        its size cannot be calculated.!
#NEW_NO_MATCH
2       No declaration of operator "new" matches the
        "placement" arguments used here.!
#DELETE_FUNCTION
1       "Delete" expression must not point to function.!
#DELETE_REFERENCE
1       "Delete" expression must not point to reference.!
#DELETE_NON_POINTER
2       Type of "delete" expression must be pointer.!
#DELETE_CONST
2       Attempt to "delete" const object.!
#CTOR_NO_MATCH
2       No declaration of a constructor for "$" matches the
        argument list or initializer used here.!
/*
/* ---------------------------------------------------------------------
/* Pointer incompatibilities
/* ---------------------------------------------------------------------
/*
#PTR_PTR_ASSIGNMENT
1       Incompatible pointer types in assignment.  Try explicit casting.!
#PTR_PTR_QUAL_ASSIGNMENT
1       Incompatible pointer types in assignment; the types (qualified
        or unqualified) pointed to contain incompatible type qualifiers.
        Try explicit casting.!
#PTR_PTR_TOP_QUAL_ASSIGNMENT
2       Incompatible qualified pointer types in assignment; the type pointed
        to by the destination operand must have all the qualifiers of the
        type pointed to by the source operand.  Try explicit casting.!
#PTR_PTR_ARRAY_ASSIGNMENT
1       Incompatible pointer types in assignment; the size specifiers of any
        arrays pointed to, must have the same value.  Try explicit casting.!
#PTR_PTR_FUN_ASSIGNMENT
1       Incompatible pointer types in assignment; the number and types of
        parameters of any functions pointed to, must have compatible types.
        Try explicit casting.!
#NON_PTR_PTR_ASSIGNMENT
1       Illegal assignment of a non-pointer type to a pointer type; the
        non-pointer must be zero (i.e. a null pointer).  Try explicit casting.!
#PTR_NON_PTR_ASSIGNMENT
1       Illegal assignment of a pointer type to a non-pointer type.
        Try explicit casting.!
#PTR_PTR_INITIAL
1       Incompatible pointer types in initialization.  Try explicit casting.!
#PTR_PTR_QUAL_INITIAL
1       Incompatible pointer types in initialization; the types (qualified
        or unqualified) pointed to contain incompatible type qualifiers.
        Try explicit casting.!
#PTR_PTR_TOP_QUAL_INITIAL
2       Incompatible qualified pointer types in initialization; the type pointed
        to by the declared variable must have all the qualifiers of the type
        pointed to by the initializer.  Try explicit casting.!
#PTR_PTR_ARRAY_INITIAL
1       Incompatible pointer types in initialization; the size specifiers of
        any arrays pointed to, must have the same value.  Try explicit casting.!
#PTR_PTR_FUN_INITIAL
1       Incompatible pointer types in initialization; the number and types of
        parameters of any functions pointed to, must have compatible types.
        Try explicit casting.!
#NON_PTR_PTR_INITIAL
1       Illegal initialization of a pointer type to a non-pointer type; the
        non-pointer must be zero (i.e. a null pointer).  Try explicit casting.!
#PTR_NON_PTR_INITIAL
1       Illegal initialization of a non-pointer type to a pointer type.
        Try explicit casting.!
#PTR_PTR_ARGUMENT
1       The type of this argument and the corresponding parameter are
        incompatible pointer types.  Try explicit casting.!
#PTR_PTR_QUAL_ARGUMENT
1       The type of this argument and the corresponding parameter are
        incompatible pointer types; the types (qualified or unqualified)
        pointed to contain incompatible type qualifiers.  Try explicit casting.!
#PTR_PTR_TOP_QUAL_ARGUMENT
2       The type of this argument and the corresponding parameter are
        incompatible pointer types; the type pointed to by the parameter
        must have all the qualifiers of the type pointed to by the argument.
        Try explicit casting.!
#PTR_PTR_ARRAY_ARGUMENT
1       The type of this argument and the corresponding parameter are
        incompatible pointer types; the size specifiers of any arrays pointed
        to, must have the same value.  Try explicit casting.!
#PTR_PTR_FUN_ARGUMENT
1       The type of this argument and the corresponding parameter are
        incompatible pointer types; the number and types of parameters
        of any functions pointed to, must have compatible types.
        Try explicit casting.!
#NON_PTR_PTR_ARGUMENT
1       This non-pointer argument may not be converted to the pointer
        type of the corresponding parameter; the non-pointer must be
        zero (i.e. a null pointer).  Try explicit casting.!
#PTR_NON_PTR_ARGUMENT
1       This pointer argument may not be converted to the non-pointer
        type of the corresponding parameter.  Try explicit casting.!
#PTR_PTR_RETURN
1       The type of this return value and the declared function return
        are incompatible pointer types.  Try explicit casting.!
#PTR_PTR_QUAL_RETURN
1       The type of this return value and the declared function return are
        incompatible pointer types; the types (qualified or unqualified)
        pointed to contain incompatible type qualifiers.  Try explicit casting.!
#PTR_PTR_TOP_QUAL_RETURN
2       The type of this return value and the declared function return are
        incompatible pointer types; the type pointed to by the declared return
        type must have all the qualifiers of the type pointed to by the return
        value.  Try explicit casting.!
#PTR_PTR_ARRAY_RETURN
1       The type of this return value and the declared function return are
        incompatible pointer types; the size specifiers of any arrays pointed
        to, must have the same value.  Try explicit casting.!
#PTR_PTR_FUN_RETURN
1       The type of this return value and the declared function return are
        incompatible pointer types; the number and types of parameters of
        any functions pointed to, must have compatible types.  Try explicit
        casting.!
#NON_PTR_PTR_RETURN
1       This non-pointer return value type may not be converted to
        the declared pointer return type; the non-pointer must be
        zero (i.e. a null pointer).  Try explicit casting.!
#PTR_NON_PTR_RETURN
1       This pointer return value type may not be converted to the
        declared non-pointer return type.  Try explicit casting.!
#PTR_PTR_RELATIONAL
1       Incompatible pointer types in comparison.  Try explicit casting.!
#PTR_PTR_QUAL_RELATIONAL
1       Incompatible pointer types in comparison; the types (qualified
        or unqualified) pointed to contain incompatible type qualifiers.
        Try explicit casting.!
#PTR_PTR_ARRAY_RELATIONAL
1       Incompatible pointer types in comparison; the size specifiers of any
        arrays pointed to, must have the same value.  Try explicit casting.!
#PTR_PTR_FUN_RELATIONAL
1       Incompatible pointer types in comparison; the number and types of
        parameters of any functions pointed to, must have compatible types.
        Try explicit casting.!
#NON_PTR_PTR_RELATIONAL
1       Illegal comparison of a pointer type to a non-pointer type; the
        non-pointer must be zero (i.e. a null pointer).  Try explicit casting.!
#PTR_PTR_CONDITIONAL
1       Incompatible pointer types as second and third operands of conditional.
        Try explicit casting.!
#PTR_PTR_QUAL_CONDITIONAL
1       Incompatible pointer types as second and third operands of conditional;
        the (qualified or unqualified) types pointed to contain incompatible
        type qualifiers.  Try explicit casting.!
#PTR_PTR_ARRAY_CONDITIONAL
1       Incompatible pointer types as second and third operands of conditional;
        the size specifiers of any arrays pointed to, must have the same value.
        Try explicit casting.!
#PTR_PTR_FUN_CONDITIONAL
1       Incompatible pointer types as second and third operands of conditional;
        the number and types of parameters of any functions pointed to, must
        have compatible types.  Try explicit casting.!
#NON_PTR_PTR_CONDITIONAL
1       Incompatible pointer and non-pointer type as second and third operands
        of conditional; the non-pointer must be zero (i.e. a null pointer).
        Try explicit casting.!
#PTR_PTR_SUBTRACTION
1       Incompatible pointer types in subtraction.  Try explicit casting.!
#PTR_PTR_QUAL_SUBTRACTION
1       Incompatible pointer types in subtraction; the types (qualified
        or unqualified) pointed to contain incompatible type qualifiers.
        Try explicit casting.!
#PTR_PTR_ARRAY_SUBTRACTION
1       Incompatible pointer types in subtraction; the size specifiers of any
        arrays pointed to, must have the same value.  Try explicit casting.!
#PTR_PTR_FUN_SUBTRACTION
1       Incompatible pointer types in subtraction; the number and types of
        parameters of any functions pointed to, must have compatible types.
        Try explicit casting.!
#PTR_PTR_EXPRESSION
1       Incompatible pointer types in expression.  Try explicit casting.!
#PTR_PTR_QUAL_EXPRESSION
1       Incompatible pointer types in expression; the types (qualified
        or unqualified) pointed to contain incompatible type qualifiers.
        Try explicit casting.!
#PTR_PTR_ARRAY_EXPRESSION
1       Incompatible pointer types in expression; the size specifiers of any
        arrays pointed to, must have the same value.  Try explicit casting.!
#PTR_PTR_FUN_EXPRESSION
1       Incompatible pointer types in expression; the number and types of
        parameters of any functions pointed to, must have compatible types.
        Try explicit casting.!
#NON_PTR_PTR_EXPRESSION
1       Incompatible pointer and non-pointer types in expression; the
        non-pointer must be zero (i.e. a null pointer).  Try explicit casting.!
/*
/* ---------------------------------------------------------------------
/* End of pointer incompatibilities diagnostics
/* ---------------------------------------------------------------------
/*
#ILLEGAL_STRUCT_COND
3       Incompatible structure/union types as second
        and third operands of conditional.!
#BAD_CONSTANT_EXPR
2       This constant expression does not evaluate to a constant that is in
        the range of representable values for its type.!
#QUAL_VOID_PARAM
1       A "void" parameter should not be "const" or "volatile" qualified.!
#OLD_STYLE_VOID_PARAM
2       An old-style function parameter may not be of type "void"; assuming "int".!
#VOID_OBJECT
2       An object may not be declared as type "void"; assuming "int".!
#VIRT_FUN_RETURN_TYPE
3       Function "$" differs only in return type from a virtual
        function of the same name in the base class "$".!
#DIRECT_INDIRECT_BASE
3       Class "$" has been specified as both a direct
        and an indirect base class of class "$".!
#ARRAY_OF_INCOMPLETE
2       An array of incomplete type may not be specified.!
#REF_TO_REF
3       A reference to a reference type may not be specified.!
#MPTR_TO_REF
3       A pointer-to-member to a reference type may not be specified.!
#PTR_TO_REF
3       A pointer-to-member to a reference type may not be specified.!
#ARRAY_OF_FUN
3       An array of function type may not be specified.!
#FUN_RET_ARRAY
3       A function returning array type may not be specified.!
#FUN_RET_FUN
3       A function returning function type may not be specified.!
#BASE_DERIVED_PTR_CNV
2       A pointer to a base class ($) may not be converted to
        a pointer to a derived class ($) without an appropriate cast.!
#VBASE_DERIVED_PTR_CNV
2       A pointer to a virtual base class ($) may not be
        converted to a pointer to a derived class ($).!
#REF_CONSTANT_NEEDED
2       Type of $ is not compatible with the destination reference type.
        An incompatible initializer for a reference is valid
        only if the reference is to a const.!
#REF_INVALID_INIT
2       Expression of $ is not an lvalue.
        It is a valid initializer for a reference only if
        the reference is to a const.!
#REF_RET_LOCAL
3       A reference to a local name (automatic or passed-by-value argument) 
        cannot be returned.!
#PRIV_BASE_CLASS_REF
2       This is an illegal reference to a base class ($) from
        a derived class ($) due to insufficient access privileges.!
#AMBIG_BASE_DERIVED_PTR_CNV
2       A pointer to an ambiguous base class ($) may not
        be converted to a pointer to an derived class ($).!
#PRIV_BASE_DERIVED_PTR_CNV
2       A pointer to an inaccessible base class ($) may not
        be converted to a pointer to a derived class ($).!
#AMBIG_DERIVED_BASE_PTR_CNV
2       A pointer to a derived class ($) may not be converted
        to a pointer to an ambiguous base class ($).!
#PRIV_DERIVED_BASE_PTR_CNV
2       A pointer to a derived class ($) may not be converted
        to a pointer to an inaccessible base class ($).!
#TYPE_HIDES_NON_TYPE
1       This type name hides a previous non-type declaration of the same name
        in an enclosing scope.  A Classic C compatibility switch is available
        to alter this behavior; see your User's Guide for more information.!
#PRIV_BASE_MEMBER_REF
2       This is an illegal member reference due to insufficient access rights.!
#NOT_BASE_CLASS_OF
2       The class "$" is not a base of the class "$".!
#NO_MULTIPLE_INHERITANCE
1       No multiple inheritance is disabled; this base class will be ignored.!
#AMBIGUOUS_USER_CONVERSION
3       Ambiguous user conversions for this class object: $ and $.!
#AMBIGUOUS_OVERLOAD
3       Ambiguous overload resolution: $ and $.!
/* ---------------------------------------------------------------------
#UNOP_PARAM
3       A unary operator member function must specify no parameters; a
        unary operator non-member function must specify one parameter.!
#BINOP_PARAM
3       A binary operator member function must specify one parameter; a
        binary operator non-member function must specify two parameters.!
#MEMBER_OP_PARAM
3       A unary operator member function must specify no parameters; a
        binary operator member function must specify two parameters.!
#NON_MEMBER_OP_PARAM
3       A unary operator non-member function must specify one parameter; a
        binary operator non-member function must specify two parameters.!
#MEMBER_UNOP_PARAM
3       A unary operator member function must specify no parameters.!
#MEMBER_BINOP_PARAM
3       A binary operator member function must specify one parameter.!
#NON_MEMBER_UNOP_PARAM
3       A unary operator non-member function must specify one parameter.!
#NON_MEMBER_BINOP_PARAM
3       A binary operator non-member function must specify two parameters.!
#NON_STATIC_OP
3       This operator function must be declared as a non-static member function
        or as non-member function.!
#NON_STATIC_MEMBER_OP
3       This operator function must be declared as a non-static member function.!
#MEMBER_INCDEC_OP_PARAM
3       An increment/decrement operator member function may specify no
        parameters, or one parameter of type "int".!
#INCDEC_OP_PARAM
3       An increment/decrement operator non-member function must specify a
        first parameter, and optionally a second parameter of type "int".!
#COPY_CTOR_PARAM
3       A copy constructor for a class X may not be declared with a parameter
        of class type X, only a reference to class type X.!
#NO_VFTP
4       Cannot find virtual function table pointer for "$".!
#OVERLOAD_NON_FUN
2       The "overload" keyword may only be applied to function types.!
#NO_MEMBER_DCL_SPEC
1       No declaration specifiers (assuming "int"); declaration specifiers for
        a member declaration may be entirely omitted only for member functions.!
#ZERO_MEMBER_SIZE
2       This member is of unknown size (incomplete type).!
/* ---------------------------------------------------------------------
/* Reference incompatibilities
/* ---------------------------------------------------------------------
#REF_REF_CAST
1       Incompatible types in cast to reference.
        The operand is converted to a temporary of the type of the reference.!
#REF_REF_QUAL_CAST
1       Incompatible types in cast to reference; the types contain
        incompatible type qualifiers.
        The operand is converted to a temporary of the type of the reference.!
#REF_REF_TOP_QUAL_CAST
2       Incompatible type qualifiers in cast to reference;
        the type referenced by the destination must have all
        the qualifiers of the type of the source operand.!
#REF_REF_ARRAY_CAST
1       Incompatible types in cast to reference;
        the size specifiers of any arrays referenced,
        must have the same value.
        The operand is converted to a temporary of the type of the reference.!
#REF_REF_FUN_CAST
1       Incompatible types in cast to reference;
        the number and types of parameters of any functions referenced,
        must have compatible types.
        The operand is converted to a temporary of the type of the reference.!
#NON_REF_REF_CAST
2       The operand of cast is not an lvalue.  An lvalue
        is required when the type of the cast is a reference type.!
#REF_REF_INITIAL
1       Incompatible types in initialization of reference.
        This initializer is converted to a temporary of the type of the
        reference being initialized.!
#REF_REF_QUAL_INITIAL
1       Incompatible types in initialization of reference;
        the types contain incompatible type qualifiers.
        This initializer is converted to a temporary of the type of the
        reference being initialized.!
#REF_REF_TOP_QUAL_INITIAL
2       Incompatible type qualifiers in initialization of reference;
        the type referenced by the declared variable must have
        all the qualifiers of the initializer.!
#REF_REF_ARRAY_INITIAL
1       Incompatible types in initialization of reference;
        the size specifiers of any arrays referenced,
        must have the same value.
        This initializer is converted to a temporary of the type of the
        reference being initialized.!
#REF_REF_FUN_INITIAL
1       Incompatible types in initialization of reference;
        the number and types of parameters of any functions referenced,
        must have compatible types.
        This initializer is converted to a temporary of the type of the
        reference being initialized.!
#REF_REF_ARGUMENT
1       The types of this argument and the corresponding reference parameter
        are incompatible.
        The argument is converted to a temporary of the type referenced
        by the parameter.!
#REF_REF_QUAL_ARGUMENT
1       The types of this argument and the corresponding reference parameter
        are incompatible; the types contain incompatible type qualifiers.
        The argument is converted to a temporary of the type referenced
        by the parameter.!
#REF_REF_TOP_QUAL_ARGUMENT
2       The types of this argument and the corresponding reference parameter
        are incompatible; the type referenced by the parameter
        must have all the qualifiers of the type of the argument.!
#REF_REF_ARRAY_ARGUMENT
1       The types of this argument
        and the corresponding reference parameter are incompatible;
        the size specifiers of any arrays referenced,
        must have the same value.
        The argument is converted to a temporary of the type referenced
        by the parameter.!
#REF_REF_FUN_ARGUMENT
1       The types of this argument
        and the corresponding reference parameter are incompatible;
        the parameters of any functions referenced must have compatible types.
        The argument is converted to a temporary of the type referenced
        by the parameter.!
#REF_REF_RETURN
2       The type of this return value is incompatible with the
        reference type declared for the function return.!
#REF_REF_QUAL_RETURN
2       The type of this return value is incompatible with the
        type referenced by the declared function return;
        the types contain incompatible type qualifiers.!
#REF_REF_TOP_QUAL_RETURN
2       The types of this return value
        and the declared function return are incompatible;
        the type referenced by the declared return type
        must have all the qualifiers of the type of the return value.!
#REF_REF_ARRAY_RETURN
2       The type of this return value is incompatible with the
        type referenced by the declared function return;
        the size specifiers of any arrays referenced,
        must have the same value.!
#REF_REF_FUN_RETURN
2       The type of this return value is incompatible with the
        type referenced by the declared function return;
        the number and types of parameters of any functions referenced,
        must have compatible types.!
#NON_REF_REF_RETURN
2       The return expression is not an lvalue.  An lvalue
        is required when the return type is a reference type.!
/*
/* ---------------------------------------------------------------------
/* End of pointer and reference incompatibilities diagnostics
/* ---------------------------------------------------------------------
/*
#VOID_CONVERSION
2       A conversion to type "void" is not allowed.!
#DFT_CTOR_CLASS_INACCESS
2       Constructor $ exists, but is inaccessible for the construction of base
        class $.!
#DFT_CTOR_MEMBER_INACCESS
2       Constructor $ exists, but is inaccessible for the construction of member
        $.!
#DFT_DTOR_CLASS_INACCESS
2       Destructor $ exists, but is inaccessible for the destruction of base
        class $.!
#DFT_DTOR_MEMBER_INACCESS
2       Destructor $ exists, but is inaccessible for the destruction of member
        $.!
#DFT_COPY_CLASS_INACCESS
2       Copy constructor $ exists, but is inaccessible for the copying of base
        class $.!
#DFT_COPY_MEMBER_INACCESS
2       Copy constructor $ exists, but is inaccessible for the assignment of
        member$.!
#DFT_ASSIGN_CLASS_INACCESS
2       Assignment operator $ exists, but is inaccessible for the assignment of 
        base class $.!
#DFT_ASSIGN_MEMBER_INACCESS
2       Assignment operator $ exists, but is inaccessible for the assignment of 
        member $.!
#DFT_ASSIGN_SEMERR
2       Cannot generate a default assignment operator for class $ because the
        class has a $ member.!
#DUP_DEFAULT_ARG
2       A default argument for this parameter has already been given.!
#DEFAULT_ARG_PLACEMENT
2       A default argument may only be specified after the last argument
        without a default argument.!
#VIRT_FUN_INCOMPLETE_BASE
1       Function "$" is more complete than the virtual function
        it overrides in the base class "$".!
#VIRT_FUN_INCOMPLETE_DERIVED
0       Function "$" is less complete than the virtual function
        it overrides in the base class "$".!
#PURE_FUN_CALL
2       This is an illegal call to a pure virtual function "$".!
#AMBIG_VBC_VFO
2       Ambiguous overriding of a virtual function in a virtual base class;
        "$" both override the same virtual base class virtual function "$".!
#NO_DCL_SPEC
1       No declaration specifiers (assuming "int"); declaration specifiers for
        a declaration may be entirely omitted only for function declarations.!
#NO_MEMBER_DCL_SPEC_ANSI_C
1       No declaration specifiers (assuming "int"); declaration specifiers for
        a member declaration may not be omitted.!
#NO_DCL_SPEC_ANSI_C
1       No declaration specifiers (assuming "int"); declaration specifiers for
        a declaration may be entirely ommitted only for function definitions.!
#ABSTRACT_CLASS_CAST
3       "$" is an abstract class (it has/inherits a pure virtual function)
        and may not be specified as the type of an explicit cast.!
#UNDEF_CLASS_CAST
3       "$" is an undefined class and may not be specified as the type of an
        explicit cast.!
#FUN_RET_UNDEF_CLASS
2       The class return type "$" for this function definition of "$"
        has not yet been defined.!
****
