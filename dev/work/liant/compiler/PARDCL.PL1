/* C++ pardcl.pl1 - Parser semantic actions package (for declarations) */

/***********************************************************************
 * This product is the property of Liant Software Corporation and is   *
 * licensed pursuant to a written license agreement.  No portion of    *
 * this product may be reproduced without the written permission of    *
 * Liant Software Corporation except pursuant to the license agreement.*
 ***********************************************************************/

/***********************************************************************
 *
 *  LPI EDIT HISTORY               [ Update the VERSION__ string below ]
 *
 *  02.18.93  DGM  129 	Allow local static function declarations on switch.
 *  10.29.92  DGM  128 	Allow overloading a set of internal linkage
 *			(e.g. inline) functions in C-header mode.
 *  10.21.92  DGM  127 	Minor diagnostic improvement.
 *  09.17.92  DGM  126 	Support for SW_DEFAULT_UNSIGNED_CHAR (-uchar).
 *  09.11.92  DGM  125 	To prevent back-end blowup, clear the register
 *			attribute for aggregate types.
 *  08.31.92  DGM  124 	New interface to NOTE_DEFERRED_FUNCTION.
 *			Skip past C++ stuff in END_CLASS_BODY in -ansic
 *			and -classicc mode to avoid weird diagnostics
 *			in certain situations.
 *  08.19.92  DGM  123 	Set anonymous-union-member bit for bit-field,
 *			tag, and typedef members of anonymous unions.
 *  08.13.92  DGM  122R	Clear declaration data before parsing deferred
 *			inline member function bodies.
 *  08.10.92  DGM  122 	Minor fix to diagnose duplicate function
 *			definitions involving deferred funtions.
 *  07.15.92  DGM  121 	Minor fix to not give ANSI-C errors for
 *			implicitly declared functions in a for-statement.
 *			No dtor-but-no-ctor warning for abstract classes.
 *  06.03.92  DGM  120 	Call CHECK_NESTED_TYPES (PKT).
 *  06.29.92  DGM  119 	Minor data-section changes.
 *  06.26.92  DGM  118 	Just to be safe, turn off SYMBOL_NODE.REGISTER_AT
 *			if the size of the object is more than the size
 *			of a register; the code generator probably should
 *			handle it put does not.  Fixes this case:
 *				register char *bug[5];
 *				char *ch = "test";
 *				bug[0] = ch;
 *  06.19.92  DGM  117 	Minor fix for befriending functions which are also
 *			type names.  Implemented #pragma LPI data_sections.
 *  06.15.92  DGM  116 	Minor fix for deferred functions.
 *  06.05.92  DGM  115 	Give NOTE for a function defined within a header
 *			file with external linkage.  No longer overload
 *			from block/function scope to global scope.
 *  05.19.92  DGM  114 	For function symbols, set SYM_NODE.SOURCE to the
 *			SOURCE_NODE id corresponding to the containing
 *			source file; this is for use by the debugger.
 *			Added ability to defer processing of internal
 *			linkage (typically inline) functions defined in
 *			header files until the end of the compilation.
 *  05.13.92  DGM  113 	Added extern "FORTRAN", "Pascal", "PL/I".
 *			Fix for friend class regression.
 *  05.08.92  DGM  112R	Bug fix.
 *  05.08.92  PKT  112R	Remove 111 diagnosis of "new" of const type.
 *  05.01.92  TLF  112R	Bug fix in END_FUNCTION_BODY for emitting
 *                      branch-around-label.
 *  05.07.92  DGM  112R	Fixes for 111 regressions.
 *  05.06.92  DGM  112R Fix for 111.
 *  04.17.92  PKT  112	Updated for 'this' qualifiers in SIG_NODE.
 *  04.13.92  PKT  112	Permit a union to have a static member function.
 *			Don't set NEEDS_INIT for union with const
 *			or reference member.
 *  04.30.92  DGM  111  Diagnose for extern "C++" typedef; diagnose
 *			definition of types in "new", "sizeof", cast,
 *			parameter-list, and conversion-operator. Minor
 *			short enum declaration fixes.  Don't allow
 *			overloading across local/global scope. Check
 *			for accessibility of nested types when explicit
 *			qualifier isn't used (LOOKUP_CURRENT_QUALIFIED_TYPE).
 *			Set sizeof struct S {int a;int b[];} to sizeof(int).
 *  04.18.92  PKT  110	Merged 106->107 with 106->109.
 *  03.24.92  PKT  109	Updated for parameter nodes, to reuse the symbols
 *			from a prototype scope.
 *  03.26.92  DGM  108	New value-node scheme.
 *  03.30.92  DGM  107  SET_TYPE_SCOPE_QUALIFIER is now obsolete;
 *			Fix in SET_FUNCTION_TYPE for:
 *			file.h:	#pragma LPI C-header
 *				void g (int) { }
 *			file.c:	#include "file.h"
 *				void f (int) { }
 *				void f (int,int) { }
 *  03.19.92  DGM  106	Diagnose use of "auto" for parameter declarations
 *			in C (ANSI and Classic) mode.  Diagnose negative
 *			bit-field specifiers.  Diagnose empty struct,
 *			union, and enum bodies in C (ANSI and Classic).
 *			Warn about class with dtor but no ctor correctly.
 *			Diagnose unnamed class needing default ctors/dtor.
 *			Diagnose declaration in for statement initializer
 *			in C mode.  Diagnose declaration after statement
 *			in a block in C mode.
 *  01.31.92  PKT  105	Bug fix weird cfront member-reference extension,
 *			and to allow typedef of qualified name.
 *            DGM       Fixed goof made in 102 which broke:
 *			   class A { friend void f (); };
 *  01.21.92  DGM  104  Added WARN_EXTRA_ARGUMENT_COMMA.
 *			Accept weird cfront member-reference extension.
 *			Accept member-pointers to undefined classes.
 *  01.06.92  PKT  103	Modified destructor access checking.
 *  01.13.92  DGM  102  Handle: class A { typedef int T; void f (T); };
 *				void A::f (T x) { }
 *			Fix in BEGIN_ENUM_BODY for -shortenum.
 *			Implemented SW_ALLOW_PARAMETER_NAME_HIDING.
 *  12.23.91  PKT  101  Fix nested class -cfront2.1 warnings for friends.
 *			Fix 098 bug fix to handle class A; struct A {}.
 *  12.19.91  DGM  100R Fix to 100; moved setting of .DEFINED up.
 *  12.16.91  DGM  100  Fix in END_CLASS_BODY; moved FINISH_CLASS_SIZE
 *			to after default destructor/assignment-operator
 *			generation; fixed internal compiler error for:
 *			   struct V { virtual ~V () ; };
 *			   class A : virtual public V { A (); };
 *			   A :: A () { }
 *			Give warning for duplicate enumerator values if
 *			desired (SW_WARN_DUP_ENUMERATOR_VALUE) - Sequoia
 *			request.  Added SET_DEFAULT_STRUCT_ALIGNMENT for
 *			the -pack switch.
 *  12.11.91  DGM  099R Fix to 099 fix below.
 *  12.10.91  DGM  099  Fixed SET_DECLARATION to give "f" internal linkage:
 *				extern int f ();
 *				static int f () { }
 *			Reported by Tom Bernhard of RM on 12.06.91.
 *  12.03.91  DGM  098  Bug fix in IS_ENCLOSING_SCOPE_OF; no violation
 *			for inline friend; handle class A; struct A {}.
 *  11.14.91  DGM  097  Merged.  Updated for enum integral-type-specifier.
 *  10.26.91  PKT  096L Better determination of HAS_CONST_MEMBER.
 *			Also, DGM fixes for duplicate friend declaration
 *			warning and cfront2.1 missing qualifier warning.
 *  10.03.91  DGM  095  Allow overloaded asm functions if SW_ALLOW_ASM.
 *  09.26.91  PKT  094  Diagnose class's lack of assignment at point
 *			of assignment.  Tightened up diagnostics for
 *			const and reference members.
 *  09.06.91  DGM  093  Give defaulting-to-private-base-class warning
 *			only if -lint.
 *  08.23.91  DGM  092  Fix for class A { int a; }; class B : A { class
 *			C { }; A::a; };  Added extern "FORTRAN" & extern
 *			"Pascal" - same as extern "C" (Zortech has it).
 *			Added MAKE_QUALIFIED_NAME to get around apparent
 *			PL/I compiler bug (sun3->i386 cross).
 *  08.15.91  DGM  091R Removed VIOLATION for nested functions.
 *  08.06.91  DGM  091  Fix for 090.
 *  08.01.91  DGM  090  Updates for new rules for overloading in the
 *			presence of old-style functions.
 *  07.24.91  DGM  089  Updated for #pragma LPI wrapper_redeclarations.
 *  07.23.91  PKT  088  Bug fix nested type accessibility.
 *  07.17.91  DGM  087  Applied PKT linkage-stack/c-header fix.
 *  07.08.91  DGM  086  Fix for struct A {}; union U { A x; } in
 *			SET_MEMBER_DECLARATION, etc.
 *  06.21.91  PKT  085  Catch error: redefined implicit member function.
 *			Suppress "operator=" declaration in C mode.
 *  06.17.91  DGM  084  Miscellaneous fixes.
 *  06.11.91  PKT  083  Added declaration of trivial "operator=".
 *  06.05.91  PKT  082  Added support for int::~int.
 *  06.04.91  DGM  081  Minor fix for CURRENT_BASE_TYPE_UNSPECIFIED;
 *			fixes for linkage conflict; and much much more.
 *  05.22.91  PKT  080  Updated.
 *  05.15.91  PKT  079  Added call to DECLARE_ARRAY_CONSTRUCTOR, to
 *			declare dummy array initializer, if necessary.
 *			Also fix to 078 fix (DGM).
 *  05.13.91  DGM  078  Minor fix for CURRENT_BASE_TYPE_UNSPECIFIED.
 *  05.02.91  DGM  077  Minor fix for C linkage in SET_DECLARATION.
 *  04.29.91  DGM  076  New anonymous union handling; now we peek ahead
 *			to see if we have an anonymous union up front;
 *			this simplifies everything, *especially* when
 *			SW_DISALLOW_NESTED_TYPES is TRUE.
 *  04.24.91  PKT  075  Changed lookups to _QUIETLY.
 *  04.18.91  DGM  074  Updated BEGIN_OLD_FUNCTION_TYPE to give a warning
 *			when compiling in C++ mode.
 *  04.09.91  DGM  073  Updated SET_DECLARATION to accept without warning:
 *				int f(); inline int f();
 *			Fix in SET_OLD_PARAMETER_DECLARATION to widen
 *			old-style "float" parameters to "double".
 *  03.26.91  PKT  072  Put processing of generated member functions at
 *			an earlier point; ditto for overriding virtuals.
 *  03.21.91  DGM  071  Expanded SW_TENTATIVE_DEFN (-tdefn) to apply to
 *			"const" declarations (i.e. to not assume "const"
 *			means internal linkage.
 *  03.12.91  DGM  070  Minor update.
 *  03.08.91  PKT  069  Fix so class is defined when inlines processed.
 *  03.08.91  DGM  068  Fix in SET_CONVERSION_NAME & misc. fixes.
 *  02.22.91  DGM  067  Set extern "C" linkage for old-style functions.
 *  02.21.91  DGM  066  Fix for static "int x; f () { extern int x; }"
 *			in SET_DECLARATION.
 *  02.11.91  DGM  065  Fix for "int f(int(*)[]);int f(a)int(*a)[3];{}".
 *  02.01.91  DGM  064  Updated to the new global names scheme.
 *  01.31.91  DGM  063  Various miscellaneous fixes.
 *  01.27.91  PKT  062  Fixed HAS_CONST_MEMBER bug.
 *  01.18.91  DGM  061  Various miscellaneous fixes.
 *  01.11.91  PKT  060  Improved accessibility checking.
 *  01.10.91  DGM  059  Added support for multi-qualified names.
 *  12.21.90  PKT  058  Give inline functions internal linkage. [DGM]
 *			Declare copy ctor even if trivial.
 *  12.17.90  PKT  057	Implemented access control during generation
 *			of default constructor/destructor.
 *  12.17.90  DGM  056  Added checks for duplicate/illegal initialization
 *			of static members.
 *  11.29.90  DGM  055  Support for nested functions; improved errors.
 *  11.28.90  TLF  054  Set SYM_NODE.ASSIGNMENT in END_CLASS_BODY.
 *  11.19.90  TLF  053  Simple change in BEGIN_FUNCTION_BODY to call 
 *                      RESET_PSECT to insure that operators for the
 *			function are inserted inside the function.
 *                      a global startup routine being generated.
 *  11.15.90  DGM  052  Fix in SET_DECLARATION.
 *  11.09.90  PKT  051  Updated for default arguments.
 *  11.06.90  DGM  050  Micellaneous updates for virtual function
 *			overriding, pure virtual function inheritance,
 *			omitted declaration specifiers, etc.
 *  10.22.90  DGM  049  Updated.
 *  10.18.90  TLF  048  Modified END_CLASS_BODY to declare default
 *                      constructor, destructor, and assign operator.
 *  10.16.90  PKT  047  Moved member and base initialization to parmin.
 *  10.12.90  DGM  046  Minor fix in SET_FRIEND_DECLARATION.
 *  10.10.90  DGM  045  Minor fix in SET_MEMBER_DECLARATION; fixes
 *			for null type/declaration specifiers; moved
 *			BEGIN/END_CLASS_INITIALIZER to parini.pl1.
 *  09.25.90  DGM  044  Preprocessor include file name changes.
 *  09.25.90  DGM  043  New BUILD_CURRENT_TYPE, BUILD_CURRENT_NEW_TYPE,
 *			and BUILD_CURRENT_PARAMETER_TYPE interface;
 *			removed ADJUST_PARAMETER_TYPE.
 *  09.17.90  PKT  042  Repaired setting of NEEDS_ flags.
 *  09.14.90  DGM  041  Changed include file names and VOP names.
 *  09.13.90  DGM  040  Changed xxx_SC names to xxx_ST.
 *  09.12.90  DGM  039  Minor fix in SET_BASE_TYPE.
 *  09.05.90  PKT  038  Updated.  DGM.
 *  08.31.90  DGM  037  Miscellaneous type-node related changes/fixes.
 *  08.29.90  DGM  036  Miscellaneous type-node related changes/fixes.
 *  08.21.90  DGM  035  Added ADJUST_PARAMETER_TYPE.
 *  08.15.90  DGM  034  New type-node.  And PKT name space changes in
 *			SET_TAG_DECLARATION, SET_TYPEDEF_DECLARATION,
 *			and SET_DECLARATION.
 *  08.07.90  PKT  033  Moved the setting of SYM_NODE.DEFINED to parini.
 *			Removed redundant diagnostic re redeclaration.
 *  07.26.90  DGM  032  Call CREATE_SPECIAL_PARAMETERS
 *			rather than INSTALL_THIS_PARAMETER.
 *  07.23.90  DGM  031  Set the new SYM_NODE.CONVERSION_TYPE for
 *			conversion operator functions.
 *  07.20.90  PKT  030  Emit RETURN_VO for destruction at end of function.
 *  07.13.90  DGM  029  Moved EMIT_FUNCTION_BEGIN/END and SET_LABEL_
 *			DECLARATION to parstm.pl1, and PROCESS_
 *			ANONYMOUS_UNION to instal.pl1.
 *  06.26.90  DGM  028  Set SYM_NODE.CONVERSION.
 *  06.14.90  PKT  027  Bug fixes, especially for old-style parameter lists.
 *  06.05.90  DGM  026  Updated for the new utilities.
 *  05.31.90  PKT  025  SET_MEMBER_INITIALIZER emits initializing code.
 *  05.25.90  DGM  024  Moved INSTALL_PARAMETERS & INSTALL_THIS_PARAMETER
 *			to CXX_SYMBOL_TABLE_INSTALL_PKG, and other changes.
 *  05.17.90  DGM  023  Moved BUILD_TYPE to buityp.pl1 (CXX_BUILD_TYPE_PKG).
 *			Fix in SET_TYPEDEF_DECLARATION for a typedef of
 *			an unnamed class (give class the typedef name).
 *  05.15.90  DGM  022  Added code to set the sizes of derived classes
 *			(see new CXX_CLASS_SIZE_PKG routines), and to look
 *			up virtual functions (see new C_SYMBOL_TABLE_
 *			LOOKUP_PKG routines), and misc. fixes.
 *  05.04.90  DGM  021  Removed the need for CONFLICTING_VISIBLE_TYPE;
 *			now handled within INSTALL_SYMBOL.
 *  05.02.90  DGM  020  Changes for "const" members.
 *  04.27.90  DGM  019  Changes for (88-Open/ABI) bit-fields; see
 *			SET_BIT_FIELD_DECLARATION (adapted from ANSI-C).
 *  04.25.90  DGM  018  Changes/fixes for old-style function declarations.
 *  04.23.90  DGM  017  Changes/fixes for old-style function declarations.
 *  04.19.90  DGM  016  Fix in END_CLASS_BODY.
 *  04.04.90  DGM  015  Minor fixes/updates.
 *  03.26.90  DGM  014  Updated; new BUILD_TYPE interface, added
 *			PROCESS_NAME_DECLARATOR,
 *			VALID_OPERATOR_FUNCTION, and more.
 *  03.15.90  PKT  013  Fix to DECLARE_LABEL.
 *  03.02.90  DGM  012  Updated; many changes for name space, linkage,
 *			etc, etc. Changed MAKE_LABEL, to DECLARE_LABEL.
 *  02.27.90  PKT  011  Updated array declarations.
 *  02.22.90  DGM  010  Updated.
 *  02.20.90  PKT  009  Added SET_LABEL_DECLARATION and MAKE_LABEL,
 *  			moved SET_CONSTANT_EXPRESSION to parexp.pl1.
 *			Now uses EMIT_EXPRESSION and EMIT_STATEMENT_ID 
 *			from parstm.pl1.
 *  02.15.90  DGM  008  Updated for the new TYPE_NODE scheme, etc.
 *  02.09.90  DGM  007  Updated.
 *  02.05.90  DGM  005  Updated.
 *  12.12.89  DGM  004  Original.
 *
 ***********************************************************************/

/* ---------------------------------------------------------------------
/* Version and copyright stamp
/* ------------------------------------------------------------------- */

declare	VERSION__	character (28) varying static internal initial

('@(#)LPI 02.18.93 129 PARDCL');

/* ---------------------------------------------------------------------
/* Include Files
/* ------------------------------------------------------------------- */

%include 'incfil';
%include GLOBAL_IN;
%include CXX_UTL_DEFS_IN;
%include CXX_UTL_SYMBOL_TABLE_PKG;
%include CXX_UTL_ROUNDU_PKG;
%include CXX_STANDARD_DEFS_IN;
%include CXX_EXTERNAL_NAME_MAP_IN;
%include CXX_COMPILATION_SWITCHES_IN;
%include CXX_C_HEADER_MODE_PKG;
%include CXX_PARSER_PKG;
%include CXX_TYPE_STACK_PKG;
%include CXX_DECLARATION_STACK_PKG;
%include CXX_SCOPE_DECLARATION_PKG;
%include CXX_SET_SCOPE_PKG;
%include CXX_SCOPE_STACK_PKG;
%include CXX_SOURCE_MGR_PKG;
%include CXX_SYMBOL_TABLE_PKG;
%include CXX_SYMBOL_TABLE_NAMES_PKG;
%include CXX_PROCESS_VIRTUAL_FUNCTION_PKG;
%include CXX_DECLARE_SYMBOL_PKG;
%include CXX_DECLARE_TYPE_PKG;
%include CXX_TYPE_COMPATIBILITY_PKG;
%include CXX_BUILD_TYPE_PKG;
%include CXX_COMPOSITE_TYPE_PKG;
%include CXX_TYPE_SIZE_PKG;
%include CXX_CLASS_SIZE_PKG;
%include CXX_ACCESS_CONTROL_PKG;
%include CXX_CHECK_DECLARATION_PKG;
%include CXX_ARGUMENT_PROMOTION_PKG;
%include CXX_CHECK_ARGUMENT_LIST_PKG;
%include CXX_LEXER_TOKENS_PKG;
%include CXX_PP_TOKEN_POD_SPELLING_PKG;
%include CXX_NODE_MGR_PKG;
%include CXX_ERROR_MGR_PKG;
%include CXX_GLOBAL_NAMES_PKG;
%include CXX_TYPE_MAP_IN;
%include CXX_TOKEN_MAP_DECLARATION_IN;
%include CXX_GLOBAL_DECLARATION_DATA_IN;
%include CXX_GLOBAL_TYPE_DATA_IN;
%include CXX_GLOBAL_SEMANTIC_DATA_IN;
%include CXX_GLOBAL_STATEMENT_DATA_IN;
%include CXX_GLOBAL_EXPRESSION_DATA_IN;
%include CXX_PROCESS_STATEMENT_PKG;
%include CXX_DEFAULT_PROC_GENERATION_PKG;
%include CXX_PSECT_PKG;
%include CXX_INTERNAL_PARSE_IN;
%include CXX_TARGET_HARDWARE_IN;
%include CXX_DUMP_VALUE_TREE_PKG;
%include CXX_DEFER_FUNCTION_PKG;
%include CXX_PRAGMA_DATA_SECTION_PKG;

/* ---------------------------------------------------------------------
/* Local static data
/* ------------------------------------------------------------------- */

declare

DEFAULT_STRUCT_ALIGNMENT		type (SHORT_T)
					static internal initial (0),
CURRENT_STRUCT_ALIGNMENT		type (SHORT_T)
					static internal initial (0);

declare

INACCESSIBLE_QUALIFIED_BASE_TYPE	type (NID_T)
					static internal initial (NULL_NID);

declare

IN_PAREN_TYPE_NAME_LEVEL		type (SHORT_T)
					static internal initial (0),
IN_CONVERSION_FUNCTION_DCL		type (BOOL_T)
					static internal initial (FALSE);

/* ---------------------------------------------------------------------
/* PARDCL
/* ------------------------------------------------------------------- */

PARDCL: procedure external; end PARDCL;

/* ---------------------------------------------------------------------
/* CLEAR_DECLARATION
/*
/* Called at the beginning of a declaration (before the declaration
/* specifiers) to clear all of the declaration (specifer, name, and
/* declarator) data.
/* ------------------------------------------------------------------- */

CLEAR_DECLARATION: procedure external (X_CLEAR_DECLARATION);

	/* call CLEAR_DECLARATION_SPECIFIERS (); */

	CURRENT_SIMPLE_TYPES		 = NULL_SIMPLE_TYPES;

	CURRENT_BASE_TYPE		 = NULL_BT;
	CURRENT_BASE_TYPE_ID		 = NULL_NID;
	CURRENT_BASE_TYPE_QUALIFIER	 = NULL_TQ;
	CURRENT_BASE_TYPE_UNSPECIFIED	 = TRUE;
	CURRENT_BASE_TYPE_SIGNED	 = FALSE;
	CURRENT_BASE_TYPE_TAG_DEFINITION = FALSE;
	CURRENT_OLD_FUNCTION_DEFINITION	 = FALSE;

	if CURRENT_SIMPLE_LINKAGE_SPECIFIER then
		CURRENT_STORAGE_CLASS	 = EXTERN_ST;
	else	CURRENT_STORAGE_CLASS	 = NULL_ST;

	CURRENT_FRIEND			 = FALSE;
	CURRENT_INLINE			 = FALSE;
	CURRENT_VIRTUAL			 = FALSE;
	CURRENT_OVERLOAD		 = FALSE;

	/* call CLEAR_NAME (); */

	CURRENT_NAME_KIND		 = VANILLA_NK;
	CURRENT_NAME			 = NULL_NID;
	CURRENT_NAME_SCOPE		 = NULL_NID;
	CURRENT_NAME_SCOPE_NAME		 = NULL_NID;
	CURRENT_NAME_SCOPE_SYMBOL	 = NULL_NID;

	/* call CLEAR_DECLARATOR (); */

	CURRENT_DERIVED_TYPE_LEVEL	 = 0;
	CURRENT_TYPE_QUALIFIER		 = NULL_TQ;

end CLEAR_DECLARATION;

/* ---------------------------------------------------------------------
/* CLEAR_DECLARATION_SPECIFIERS
/* ------------------------------------------------------------------- */

CLEAR_DECLARATION_SPECIFIERS: procedure
			      external  (X_CLEAR_DECLARATION_SPECIFIERS);

	/* call CLEAR_TYPE_SPECIFIERS (); */

	CURRENT_SIMPLE_TYPES		 = NULL_SIMPLE_TYPES;
	CURRENT_BASE_TYPE		 = NULL_BT;
	CURRENT_BASE_TYPE_ID		 = NULL_NID;
	CURRENT_BASE_TYPE_QUALIFIER	 = NULL_TQ;
	CURRENT_BASE_TYPE_UNSPECIFIED	 = TRUE;
	CURRENT_BASE_TYPE_SIGNED	 = FALSE;
	CURRENT_BASE_TYPE_TAG_DEFINITION = FALSE;
	CURRENT_OLD_FUNCTION_DEFINITION	 = FALSE;

	/* Clear the rest of the declaration specifiers */

	if CURRENT_SIMPLE_LINKAGE_SPECIFIER then
		CURRENT_STORAGE_CLASS	 = EXTERN_ST;
	else	CURRENT_STORAGE_CLASS	 = NULL_ST;

	CURRENT_FRIEND			 = FALSE;
	CURRENT_INLINE			 = FALSE;
	CURRENT_VIRTUAL			 = FALSE;
	CURRENT_OVERLOAD		 = FALSE;

end CLEAR_DECLARATION_SPECIFIERS;

/* ---------------------------------------------------------------------
/* CLEAR_TYPE_SPECIFIERS
/* ------------------------------------------------------------------- */

CLEAR_TYPE_SPECIFIERS: procedure external (X_CLEAR_TYPE_SPECIFIERS);

	CURRENT_SIMPLE_TYPES		 = NULL_SIMPLE_TYPES;
	CURRENT_BASE_TYPE		 = NULL_BT;
	CURRENT_BASE_TYPE_ID		 = NULL_NID;
	CURRENT_BASE_TYPE_UNSPECIFIED	 = TRUE;
	CURRENT_BASE_TYPE_QUALIFIER	 = NULL_TQ;
	CURRENT_BASE_TYPE_SIGNED	 = FALSE;
	CURRENT_BASE_TYPE_TAG_DEFINITION = FALSE;
	CURRENT_OLD_FUNCTION_DEFINITION	 = FALSE;

end CLEAR_TYPE_SPECIFIERS;

/* ---------------------------------------------------------------------
/* CLEAR_NAME
/* ------------------------------------------------------------------- */

CLEAR_NAME: procedure internal;

	/* call CLEAR_SIMPLE_NAME (); */

	CURRENT_NAME_KIND		= VANILLA_NK;
	CURRENT_NAME			= NULL_NID;

	/* call CLEAR_SCOPE_QUALIFIER (); */

	CURRENT_NAME_SCOPE		= NULL_NID;
	CURRENT_NAME_SCOPE_NAME		= NULL_NID;
	CURRENT_NAME_SCOPE_SYMBOL	= NULL_NID;

end CLEAR_NAME;

/* ---------------------------------------------------------------------
/* SET_SIMPLE_NAME
/* ------------------------------------------------------------------- */

SET_SIMPLE_NAME: procedure external (X_SET_SIMPLE_NAME);

	CURRENT_NAME			= MATCHED_TOKEN.SPELLING;
	CURRENT_NAME_KIND		= VANILLA_NK;
	CURRENT_NAME_LINE_ID		= MATCHED_TOKEN.LINE;
	CURRENT_NAME_FILE_ID		= CURRENT_SOURCE.FILE;

	/* call CLEAR_SCOPE_QUALIFIER (); */

	CURRENT_NAME_SCOPE		= NULL_NID;
	CURRENT_NAME_SCOPE_NAME		= NULL_NID;
	CURRENT_NAME_SCOPE_SYMBOL	= NULL_NID;

end SET_SIMPLE_NAME;

/* ---------------------------------------------------------------------
/* SET_VANILLA_NAME
/* ------------------------------------------------------------------- */

SET_VANILLA_NAME: procedure external (X_SET_VANILLA_NAME);

	CURRENT_NAME		= MATCHED_TOKEN.SPELLING;
	CURRENT_NAME_KIND	= VANILLA_NK;
	CURRENT_NAME_LINE_ID	= MATCHED_TOKEN.LINE;
	CURRENT_NAME_FILE_ID	= CURRENT_SOURCE.FILE;

end SET_VANILLA_NAME;

/* ---------------------------------------------------------------------
/* SET_DESTRUCTOR_NAME
/* ------------------------------------------------------------------- */

SET_DESTRUCTOR_NAME: procedure external (X_SET_DESTRUCTOR_NAME);

	declare TYPE_CODE		type (SHORT_T);

	if MATCHED_TOKEN.TYPE = IDENTIFIER_TOKEN then do;
		CURRENT_NAME		= MATCHED_TOKEN.SPELLING;
		CURRENT_NAME_KIND	= DESTRUCTOR_NK;
	end;
	else do;
		/*
		/* A type destructor like "~int".
		/* Get the type code implied by the simple type keyword.
		/**/
		TYPE_CODE = MAP_SIMPLE_TYPE_TOKEN (MATCHED_TOKEN.TYPE);

		/* Set the current name indication peculiarly */

		CURRENT_NAME		= GET_BASIC_TYPE (TYPE_CODE);
		CURRENT_NAME_KIND	= TYPE_DESTRUCTOR_NK;
	end;

	CURRENT_NAME_LINE_ID	= MATCHED_TOKEN.LINE;
	CURRENT_NAME_FILE_ID	= CURRENT_SOURCE.FILE;

end SET_DESTRUCTOR_NAME;

/* ------------------------------------------------------------------- */
/* CHECK_DECLARED_DESTRUCTOR
/* ------------------------------------------------------------------- */

CHECK_DECLARED_DESTRUCTOR: procedure
			   external (X_CHECK_DECLARED_DESTRUCTOR);

	/* Make sure that this destructor name is not a type destructor. */

	if CURRENT_NAME_KIND = TYPE_DESTRUCTOR_NK then do;
		/*
		/* Error; this is not a class name.
		/**/
		call SEMANTIC_ERROR_I (ERR_TYPE_DESTRUCTOR_DECLARATOR,
				       TYPE_NAME (CURRENT_NAME, ''));

		CURRENT_NAME = NULL_NID;
		CURRENT_NAME_KIND = DESTRUCTOR_NK;
	end;

end CHECK_DECLARED_DESTRUCTOR;

/* ---------------------------------------------------------------------
/* SET_OPERATOR_NAME
/* ------------------------------------------------------------------- */

SET_OPERATOR_NAME: procedure external (X_SET_OPERATOR_NAME);

	CURRENT_NAME		= OPERATOR_NAME (MATCHED_TOKEN.TYPE);
	CURRENT_NAME_KIND	= OPERATOR_NK;
	CURRENT_NAME_LINE_ID	= MATCHED_TOKEN.LINE;
	CURRENT_NAME_FILE_ID	= CURRENT_SOURCE.FILE;

end SET_OPERATOR_NAME;

/* ---------------------------------------------------------------------
/* BEGIN_CONVERSION_NAME
/* ------------------------------------------------------------------- */

BEGIN_CONVERSION_NAME: procedure external (X_BEGIN_CONVERSION_NAME);

	CURRENT_NAME_LINE_ID	= MATCHED_TOKEN.LINE;
	CURRENT_NAME_FILE_ID	= CURRENT_SOURCE.FILE;

	call SAVE_DECLARATION_STATE ();

	IN_CONVERSION_FUNCTION_DCL = TRUE;

end BEGIN_CONVERSION_NAME;

/* ---------------------------------------------------------------------
/* SET_CONVERSION_NAME
/* ------------------------------------------------------------------- */

SET_CONVERSION_NAME: procedure external (X_SET_CONVERSION_NAME);

	/*
	/* Set the CURRENT_NAME to the type-node id of the target
	/* conversion type; later (in SET_MEMBER_DECLARATION), it
	/* will be set to CONVERSION_NAME, and SYM_NODE.TYPE
	/* will be set to a type-node representing a functinon returning
	/* the type specified in the CURRENT_NAME type-node.
	/**/

	call BUILD_CURRENT_CONVERSION_TYPE ();

	call RESTORE_DECLARATION_STATE ();

	CURRENT_NAME	  = CURRENT_TYPE;
	CURRENT_NAME_KIND = CONVERSION_NK;

	IN_CONVERSION_FUNCTION_DCL = FALSE;

end SET_CONVERSION_NAME;

/* ---------------------------------------------------------------------
/* CLEAR_SCOPE_QUALIFIER
/* ------------------------------------------------------------------- */

CLEAR_SCOPE_QUALIFIER: procedure external (X_CLEAR_SCOPE_QUALIFIER);

	CURRENT_NAME_SCOPE	  = NULL_NID;
	CURRENT_NAME_SCOPE_NAME	  = NULL_NID;
	CURRENT_NAME_SCOPE_SYMBOL = NULL_NID;

end CLEAR_SCOPE_QUALIFIER;

/* ---------------------------------------------------------------------
/* SET_CLASS_SCOPE_QUALIFIER
/* ------------------------------------------------------------------- */

SET_CLASS_SCOPE_QUALIFIER: procedure
			   external (X_SET_CLASS_SCOPE_QUALIFIER);

	declare
		NAME		type (NID_T),
		TOKEN_TYPE	type (SHORT_T);

	/* Get the name of this (class) scope qualifier */

	NAME = MATCHED_TOKEN.SPELLING;
	TOKEN_TYPE = MATCHED_TOKEN.TYPE;

	if TOKEN_TYPE ^= IDENTIFIER_TOKEN then do;
		/*
		/* Here, we have a non-class scope qualifier,
		/* i.e. a simple type name like "int".  This is
		/* ok only if what follows is a destructor name.
		/**/
		if CURRENT_NAME_SCOPE_NAME ^= NULL_NID then do;
			/*
			/* Error; a simple type name may not be used as
			/* a subsequent scope qualifier (e.g. A::int::x).
			/**/
			call SEMANTIC_ERROR_I
			     (ERR_UNDEF_SCOPE_QUALIFIER,
			      MAKE_QUALIFIED_NAME_FROM_TOKEN
			      (CURRENT_NAME_SCOPE_SYMBOL, MATCHED_TOKEN_PTR));
			return;
		end;
		/*
		/* --> Note!  Name is set to the type-node id! <--
		/**/
		CURRENT_NAME_SCOPE	  = NULL_NID;
		CURRENT_NAME_SCOPE_SYMBOL = NULL_NID;
		CURRENT_NAME_SCOPE_NAME	  = GET_BASIC_TYPE
					    (MAP_SIMPLE_TYPE_TOKEN
					     (TOKEN_TYPE));
		return;
	end;

	/* Look up the name */

	if CURRENT_NAME_SCOPE_NAME = NULL_NID then do;
		/*
		/* This is the first scope qualifier in this sequence.
		/**/
		if LOOKUP_TYPE_NAME_QUIETLY
		   (NAME, CURRENT_SCOPE) = NULL_NID then do;
			/*
			/* Error; unknown class scope name used
			/* as an initial scope qualifier (A::x).
			/**/
			call SEMANTIC_ERROR_I (ERR_UNDEF_SCOPE_QUALIFIER,
					       TOKEN_NAME (NAME));
			return;
		end;
	end;
	else if CURRENT_NAME_SCOPE = NULL_NID then do;
		/* 
		/* Error; the last scope qualifier name specified an
		/* undefined class or a simple type or a typedef name
		/* which did not refer to a class.
		/**/
		if CURRENT_NAME_SCOPE_SYMBOL = NULL_NID then
			call SEMANTIC_ERROR_I (ERR_UNDEF_SCOPE_QUALIFIER,
					       TYPE_NAME
					       (CURRENT_NAME_SCOPE_NAME, ''));
		else	call SEMANTIC_ERROR_I (ERR_UNDEF_SCOPE_QUALIFIER,
					       QUALIFIED_SYMBOL_NAME
					       (CURRENT_NAME_SCOPE_SYMBOL));
		CURRENT_NAME_SCOPE_NAME	  = NULL_NID;
		CURRENT_NAME_SCOPE_SYMBOL = NULL_NID;
		return;
	end;
	else do;
		if SEARCH_CLASS_FOR_TYPE
		   (CURRENT_NAME_SCOPE_SYMBOL, NAME) = NULL_NID then do;
			/*
			/* The current name was not found as a tag in the
			/* class specified as the qualifier; this is an ERROR,
			/* BUT we want to allow it easy transition from old
			/* C++ style nested classes (i.e. non-nested classes)
			/* to new style (i.e. real nested classes).  E.g.,
			/* we want to allow the following in -xnnt mode:
			/*
			/*     struct A { struct B { struct C {} }; };
			/*     A::B::C x;  // B & C global but we'll take it
			/**/
			if NAME ^= CURRENT_NAME_SCOPE_NAME then do;
				if RUMMAGE_QUALIFIED_TAG_NAME
				   (NAME) = NULL_NID then do;
					/*
					/* Error; unknown class scope name
					/* used as a (subsequent) scope
					/* qualifier (A::B::x).
					/**/
					call SEMANTIC_ERROR_I
					     (ERR_UNDEF_SCOPE_QUALIFIER,
					      MAKE_QUALIFIED_NAME
					      (CURRENT_NAME_SCOPE_SYMBOL,
					       NAME));
					return;
				end;
				else if SYM_NODE.ENCLOSING_CLASS ^=
					CURRENT_NAME_SCOPE_SYMBOL then do;
					/*
					/* Warning; this qualified tag name
					/* is qualified with a class name
					/* in which it was not declared.
					/**/
					call SEMANTIC_ERROR_I
					     (ERR_BAD_QUAL_TYPE_NAME,
					      MAKE_QUALIFIED_NAME
					      (SYM_NODE.ENCLOSING_CLASS,
					       NAME));
					return;
				end;
			end;
		end;
	end;

	/* Make sure that this is a type */

	if ^SYM_NODE.IS_TYPE then do;
		/*
		/* Error; this is not a type name.
		/**/
		call SEMANTIC_ERROR_I (ERR_UNDEF_SCOPE_QUALIFIER,
				       QUALIFIED_SYMBOL_NAME
				       ((CURRENT_NODE_ID)));
		return;
	end;

	/* See if this is a non-class scope qualifier */

	else if ^SYM_NODE.IS_AGGREGATE_TAG then do;
		/*
		/* Here, we have a non-class scope qualifier, i.e.
		/* a typedef name which does not refer to a class.
		/* This is ok only if what follows is a destructor name,
		/* but we will check for that in CHECK_CLASS_SCOPE_QUALIFIER.
		/*
		/* --> Note!  Name is set to the type-node id! <--
		/**/
		CURRENT_NAME_SCOPE	  = NULL_NID;
		CURRENT_NAME_SCOPE_SYMBOL = CURRENT_NODE_ID;
		CURRENT_NAME_SCOPE_NAME	  = SYM_NODE.TYPE;
		return;
	end;

	/* See if this is a defined class scope qualifier */

	else if SYM_NODE.DEFINED_SCOPE = NULL_NID then do;
		if (CURRENT_STORAGE_CLASS = TYPEDEF_ST) &
		   (CURRENT_BASE_TYPE ^= NULL_BT) then do;
			/*
			/* Handle the strange cfront extension
			/* which support the typedef of a new
			/* member-function-reference type.  E.g.:
			/*
			/*   struct A *ap;
			/*   typedef void A::T();
			/*   T *mp; // Same as: void (A::*mp)();
			/**/
			;
		end;
		else if AT_MEMBER_POINTER (FALSE) then do;
			/*
			/* Here, we are at a member pointer declarator,
			/* so it's ok that the class qualifier is undefined.
			/**/
			;
		end;
		else do;
			/*
			/* Error; this class has not yet been defined.
			/**/
			call SEMANTIC_ERROR_I (ERR_UNDEF_SCOPE_QUALIFIER,
					       QUALIFIED_SYMBOL_NAME
					       ((CURRENT_NODE_ID)));
			return;
		end;
	end;

	CURRENT_NAME_SCOPE	  = SYM_NODE.DEFINED_SCOPE;
	CURRENT_NAME_SCOPE_SYMBOL = CURRENT_NODE_ID;
	CURRENT_NAME_SCOPE_NAME	  = NAME;

end SET_CLASS_SCOPE_QUALIFIER;

/* ---------------------------------------------------------------------
 * CHECK_CLASS_SCOPE_QUALIFIER
 * ------------------------------------------------------------------- */

CHECK_CLASS_SCOPE_QUALIFIER: procedure
			     external (X_CHECK_CLASS_SCOPE_QUALIFIER);

	/*
	/* Make sure that this is a class tag, or a typedef or
	/* simple type which is followed by a destructor name.
	/**/

	if CURRENT_NAME_SCOPE ^= NULL_NID then do;
		/*
		/* Here, we have a defined class scope qualifier.
		/* All is well.
		/**/
		return;
	end;
	else if CURRENT_NAME_SCOPE_SYMBOL ^= NULL_NID then do;
		/*
		/* Here, we have either an undefined class
		/* scope qualifier or a non-class scope qualifier.
		/**/
		call SET_SYM_NODE_R (CURRENT_NAME_SCOPE_SYMBOL);
		if ^SYM_NODE.IS_AGGREGATE_TAG then do;
			/*
			/* Here, we have a non-class scope qualifier,
			/* i.e. a typedef name which does not refer
			/* to a class.  This only makes sense if it
			/* is followed by a destructor name, e.g.:
			/*
			/*   typedef int T;
			/*   int *p;
			/*   p->T::~T ()
			/**/
			if ^AT_DESTRUCTOR_NAME () then do;
				call SEMANTIC_ERROR_I
				     (ERR_TYPE_NAME_QUALIFIER,
				      QUALIFIED_SYMBOL_NAME
				      (CURRENT_NAME_SCOPE_SYMBOL));
				CURRENT_NAME_SCOPE_NAME	  = NULL_NID;
				CURRENT_NAME_SCOPE_SYMBOL = NULL_NID;
			end;
		end;
		else if (CURRENT_STORAGE_CLASS = TYPEDEF_ST) &
			(CURRENT_BASE_TYPE ^= NULL_BT) then do;
			/*
			/* Handle the strange cfront extension
			/* which supports the typedef of a
			/* member-function-reference type.
			/*
			/*   struct A *ap;
			/*   typedef void A::T();
			/*   T *mp; // Same as: void (A::*mp)();
			/**/
			;
		end;
		else if AT_MEMBER_POINTER (TRUE) then do;
			/*
			/* Here, we are at a member pointer declarator,
			/* so it's ok that the class qualifier is undefined.
			/**/
			if SW_WARN_MEMBER_PTR_UNDEF_CLASS then
				call SEMANTIC_ERROR_I
				     (ERR_MEMPTR_CLASS_UNDEF_AT_DCL,
				      QUALIFIED_SYMBOL_NAME
				      ((CURRENT_NODE_ID)));
		end;
		else do;
			/*
			/* Error; this scope qualifier name
			/* does not refer to a defined class.
			/**/
			call SEMANTIC_ERROR_I
			     (ERR_UNDEF_SCOPE_QUALIFIER,
			      QUALIFIED_SYMBOL_NAME
			      (CURRENT_NAME_SCOPE_SYMBOL));
			CURRENT_NAME_SCOPE_NAME	  = NULL_NID;
			CURRENT_NAME_SCOPE_SYMBOL = NULL_NID;
		end;
	end;
	else if CURRENT_NAME_SCOPE_NAME ^= NULL_NID then do;
		/*
		/* Here, we have a non-class scope qualifier,
		/* i.e. a simple type specifier.  This only makes
		/* sense if it is followed by a destructor name, e.g.:
		/*
		/*   p->int::~int ()
		/**/
		if ^AT_DESTRUCTOR_NAME () then do;
			call SEMANTIC_ERROR_I (ERR_UNDEF_SCOPE_QUALIFIER,
					       TYPE_NAME
					       (CURRENT_NAME_SCOPE_NAME, ''));
			CURRENT_NAME_SCOPE_NAME	  = NULL_NID;
			CURRENT_NAME_SCOPE_SYMBOL = NULL_NID;
		end;
	end;

end CHECK_CLASS_SCOPE_QUALIFIER;

/* ---------------------------------------------------------------------
/* SET_TYPE_SCOPE_QUALIFIER
/* ------------------------------------------------------------------- */

SET_TYPE_SCOPE_QUALIFIER: procedure external (X_SET_TYPE_SCOPE_QUALIFIER);

	/* OBSOLETE */

end SET_TYPE_SCOPE_QUALIFIER;

/* ---------------------------------------------------------------------
/* SET_GLOBAL_SCOPE_QUALIFIER
/* ------------------------------------------------------------------- */

SET_GLOBAL_SCOPE_QUALIFIER: procedure
			    external (X_SET_GLOBAL_SCOPE_QUALIFIER);

	CURRENT_NAME_SCOPE	  = CURRENT_GLOBAL_SCOPE;
	CURRENT_NAME_SCOPE_NAME	  = NULL_NID;
	CURRENT_NAME_SCOPE_SYMBOL = NULL_NID;

end SET_GLOBAL_SCOPE_QUALIFIER;

/* ---------------------------------------------------------------------
/* SET_STORAGE_CLASS_SPECIFIER
/* ------------------------------------------------------------------- */

SET_STORAGE_CLASS_SPECIFIER: procedure
			     external  (X_SET_STORAGE_CLASS_SPECIFIER);

	if CURRENT_STORAGE_CLASS ^= NULL_ST then
		call SYNTAX_ERROR (ERR_TOO_MANY_STORAGE);

	if (CURRENT_BASE_TYPE ^= NULL_BT) |
	   (CURRENT_SIMPLE_TYPES ^= NULL_SIMPLE_TYPES) then do;
		/*
		/* Warning; placement of a storage-class specifier
		/* other than a at the beginning of declaration is
		/* an obsolescent feature.  Avoid this if possible.
		/**/
		call SYNTAX_ERROR (ERR_STORAGE_PLACEMENT);
	end;

	CURRENT_STORAGE_CLASS =
		MAP_STORAGE_CLASS_TOKEN (MATCHED_TOKEN.TYPE);

end SET_STORAGE_CLASS_SPECIFIER;

/* ---------------------------------------------------------------------
/* SET_VIRTUAL_SPECIFIER
/* ------------------------------------------------------------------- */

SET_VIRTUAL_SPECIFIER: procedure external (X_SET_VIRTUAL_SPECIFIER);

	CURRENT_VIRTUAL = TRUE;

end SET_VIRTUAL_SPECIFIER;

/* ---------------------------------------------------------------------
/* SET_INLINE_SPECIFIER
/* ------------------------------------------------------------------- */

SET_INLINE_SPECIFIER: procedure external (X_SET_INLINE_SPECIFIER);

	CURRENT_INLINE = TRUE;

end SET_INLINE_SPECIFIER;

/* ---------------------------------------------------------------------
/* SET_OVERLOAD_SPECIFIER
/* ------------------------------------------------------------------- */

SET_OVERLOAD_SPECIFIER: procedure external (X_SET_OVERLOAD_SPECIFIER);

	/*
	/* Error; use of the obsolete "overload" specifier.
	/* If the type turns out to be a non-function, we will
	/* entirely ignore this declaration.
	/**/

	if ^SW_ALLOW_OVERLOAD_KEYWORD then
		call SEMANTIC_ERROR (ERR_WARN_OVERLOAD);

	CURRENT_OVERLOAD = TRUE;

end SET_OVERLOAD_SPECIFIER;

/* ---------------------------------------------------------------------
/* SET_FRIEND_SPECIFIER
/* ------------------------------------------------------------------- */

SET_FRIEND_SPECIFIER: procedure external (X_SET_FRIEND_SPECIFIER);

	if CURRENT_SCOPE_TYPE ^= CLASS_SCOPE then do;
		/*
		/* Warning; only class members may
		/* be designated as friends; ignored.
		/**/
		call SEMANTIC_ERROR (ERR_ONLY_MEMBER_FRIENDS);
		return;
	end;

	CURRENT_FRIEND = TRUE;

end SET_FRIEND_SPECIFIER;

/* ---------------------------------------------------------------------
/* SET_SIMPLE_TYPE
/* ------------------------------------------------------------------- */

SET_SIMPLE_TYPE: procedure external (X_SET_SIMPLE_TYPE);

	declare T type (SHORT_T);

	if CURRENT_BASE_TYPE ^= NULL_BT then do;
		/*
		/* Already have a class, struct, union, enum,
		/* typedef-name, or other simple type specifier.
		/**/
		call SYNTAX_ERROR (ERR_INCONSISTENT_TYPES);
		return;
	end;
	T = MATCHED_TOKEN.TYPE;
	if CURRENT_SIMPLE_TYPE (T) then do;
		call SYNTAX_ERROR (ERR_DUP_TYPE_KEYWORD);
		return;
	end;
	if (CONSISTENT_SIMPLE_TYPES (T) & CURRENT_SIMPLE_TYPES) ^=
	    CURRENT_SIMPLE_TYPES then do;
		/*
		/* Error; inconsistent type specifiers.
		/**/
		if SW_X_LONG_FLOAT &
		   (((T = KW_FLOAT_TOKEN) &
		     CURRENT_SIMPLE_TYPE (KW_LONG_TOKEN)) |
		    ((T = KW_LONG_TOKEN) &
		     CURRENT_SIMPLE_TYPE (KW_FLOAT_TOKEN))) then do;
			/*
			/* Allow "long float" if compatibility switch
			/* was given (same as double; see SET_BASE_TYPE).
			/**/
			return; 
		end;
		call SEMANTIC_ERROR (ERR_INCONSISTENT_TYPE_KEYWORDS);
		return;
	end;
	CURRENT_SIMPLE_TYPE (T) = TRUE;

end SET_SIMPLE_TYPE;

/* ---------------------------------------------------------------------
/* SET_TYPE_NAME
/* ------------------------------------------------------------------- */

SET_TYPE_NAME: procedure external (X_SET_TYPE_NAME);

	/* Lookup the type-name in the desired scope (guaranteed to work) */

	CURRENT_BASE_TYPE_ID = LOOKUP_CURRENT_QUALIFIED_TYPE ();

	/* If CURRENT_BASE_TYPE_ID = NULL_NID then compiler error */

	/* See if this is a class, struct, union, or enum tag name */

	if SYM_NODE.IS_TAG then
		CURRENT_BASE_TYPE = rank (SYM_NODE.TOP_TYPE.CODE);

	/* Otherwise, this must be a typedef name */

	else do;
		if SYM_NODE.SIGNED then
			CURRENT_BASE_TYPE_SIGNED = TRUE;
		CURRENT_BASE_TYPE = TYPEDEF_BT;
	end;

	CURRENT_BASE_TYPE_UNSPECIFIED = FALSE;

end SET_TYPE_NAME;

/* ---------------------------------------------------------------------
/* LOOKUP_CURRENT_QUALIFIED_TYPE
/* ------------------------------------------------------------------- */

LOOKUP_CURRENT_QUALIFIED_TYPE: procedure returns (type (NID_T)) internal;

	declare
		ID	type (NID_T),
		WARNING	type (BOOL_T),
		SP	type (POINTER_T);

	INACCESSIBLE_QUALIFIED_BASE_TYPE = NULL_NID;

	/* Lookup the name in the desired scope */

	if CURRENT_NAME_SCOPE = NULL_NID then do;
		ID = LOOKUP_NAME_QUIETLY
		     (CURRENT_NAME, TYPE_SK, CURRENT_SCOPE);
		if SW_CFRONT_2_1_MODE then do;
			if (ID ^= NULL_NID) &
			   (SYM_NODE.ENCLOSING_CLASS ^= NULL_NID) &
			   (^SYM_NODE.IS_DUMMY) then do;
				/*
				/* In -cfront2.1 mode (which will, oddly
				/* enough, imply -xnnt mode), we want to
				/* give a warning for cases like:
				/*
				/*     struct A { struct B { }; };
				/*     B x;  // warning; use A::B
				/**/
				WARNING = TRUE;
				if IS_ENCLOSING_CLASS_OF
				   (SYM_NODE.ENCLOSING_CLASS, CURRENT_SCOPE) |
				   IS_ENCLOSING_CLASS_OF
				   (ID, CURRENT_SCOPE) then
					WARNING = FALSE;
				else if CURRENT_CLASS_SCOPE ^= NULL_NID then do;
					call GET_SCOPE_NODE_R 
					(CURRENT_CLASS_SCOPE, SP);
					if IS_ANY_BASE_CLASS_OF
					   (SYM_NODE.ENCLOSING_CLASS,
					    SP->SCOPE_NODE.OWNER) |
					   IS_ANY_BASE_CLASS_OF
					   (ID, SP->SCOPE_NODE.OWNER) then
						WARNING = FALSE;
					call RELEASE_SCOPE_NODE
					     (CURRENT_CLASS_SCOPE);
				end;
				if WARNING &
				   SW_WARN_UNQUALIFIED_NESTED_TYPE then do;
					call SEMANTIC_ERROR_I
					     (ERR_UNQUAL_NESTED_TYPE,
					      MAKE_QUALIFIED_NAME
					      (SYM_NODE.ENCLOSING_CLASS,
					       CURRENT_NAME));
				end;
			end;
		end;
		if SYM_NODE.IS_AGGREGATE_MEMBER then
			goto CHECK_ACCESSIBILITY;
		return (ID);
	end;

	/* Here, we are looking for a qualified type-name */

	if CURRENT_NAME_SCOPE_SYMBOL = NULL_NID then do;
		/*
		/* Lookup a simple global qualified name.
		/**/
		ID = LOOKUP_NAME (CURRENT_NAME,
				  TYPE_SK,
				  CURRENT_GLOBAL_SCOPE);
		return (ID);
	end;
	else do;
		/*
		/* Lookup a class qualified name.
		/**/
		ID = SEARCH_CLASS (CURRENT_NAME_SCOPE_SYMBOL,
				   CURRENT_NAME,
				   TYPE_SK);
	end;

	if ID = NULL_NID then do;
		/*
		/* The current name was not found as a type in the class
		/* specified as the qualifier; this is an ERROR, BUT we want
		/* to allow it easy transition from old C++ style nested
		/* classes (i.e. non-nested classes) to new style (i.e. real
		/* nested classes).  E.g., we want to allow the following
		/* in -xnnt mode:
		/*
		/*     struct A { struct B { }; };
		/*     A::B x;  // B at global scope but we'll take it
		/**/
		if (CURRENT_NAME_SCOPE_NAME ^= CURRENT_NAME) &
		   (CURRENT_NAME_SCOPE_NAME ^= NULL_NID) then do;
			ID = RUMMAGE_QUALIFIED_TYPE_NAME (CURRENT_NAME);
			if ID = NULL_NID then
				return (NULL_NID);
			else if SYM_NODE.ENCLOSING_CLASS ^=
				CURRENT_NAME_SCOPE_SYMBOL then do;
				/*
				/* Warning; this qualified type name is
				/* qualified with a class name in which
				/* it was not declared.
				/**/
				call SEMANTIC_ERROR_I
				     (ERR_BAD_QUAL_TYPE_NAME,
				      MAKE_QUALIFIED_NAME
				      (SYM_NODE.ENCLOSING_CLASS,
				       CURRENT_NAME));
			end;
		end;
		return (ID);
	end;

	CHECK_ACCESSIBILITY:

	if ^IS_ACCESSIBLE_STATIC (ID) then do;
		/*
		/* Error; this nested type is inaccessible ... maybe ...
		/*
		/* N.B. if we are at global scope, then defer until we
		/* are sure we aren't really just defining a class member,
		/* in which case access checking was already done; e.g:
		/*
		/*    class A { typedef int T; void f (); };
		/*    A::T f () { }
		/**/
		if CURRENT_SCOPE_TYPE = GLOBAL_SCOPE then
			INACCESSIBLE_QUALIFIED_BASE_TYPE = ID;
		else if SYM_NODE.IS_TAG then
			call SEMANTIC_ERROR_I
			     (ERR_PRIV_TYPE_NAME, QUALIFIED_SYMBOL_NAME (ID));
		else	call SEMANTIC_ERROR_I
			     (ERR_PRIV_CLASS_NAME, QUALIFIED_SYMBOL_NAME (ID));
	end;

	return (ID);

/* ---------------------------------------------------------------------
/* IS_ENCLOSING_CLASS_OF
/*
/* Return TRUE if the class represented by the given sym-node id CLASS is
/* (semantically) an enclosing class of the scope represented by the given
/* scope-node id SCOPE, or if SCOPE is simply the scope associated with
/* CLASS, otherwise return FALSE.  Preserves current-node-id.
/* ------------------------------------------------------------------- */

IS_ENCLOSING_CLASS_OF: procedure (CLASS, SCOPE)
		       returns   (type (BOOL_T))
		       internal;
	declare
		CLASS		type (NID_T),
		SCOPE		type (NID_T);
	declare
		(SP, P)		type (POINTER_T),
		(S, NEXT_S)	type (NID_T),
		STATUS		type (BOOL_T);

	STATUS = FALSE;

	do S = SCOPE repeat (NEXT_S) while (S ^= NULL_NID);
		call GET_SCOPE_NODE_R (S, SP);
		if SP->SCOPE_NODE.TYPE = byte (GLOBAL_SCOPE) then do;
			call RELEASE_SCOPE_NODE (S);
			return (STATUS);
		end;
		else if SP->SCOPE_NODE.TYPE = byte (CLASS_SCOPE) then do;
			if SP->SCOPE_NODE.OWNER = CLASS then do;
				STATUS = TRUE;
				call RELEASE_SCOPE_NODE (S);
				return (STATUS);
			end;
		end;
		if SP->SCOPE_NODE.OWNER ^= NULL_NID then do;
			call GET_SYM_NODE_R (SP->SCOPE_NODE.OWNER, P);
			NEXT_S = P->SYM_NODE.ENCLOSING_SCOPE;
			call RELEASE_SYM_NODE (SP->SCOPE_NODE.OWNER);
		end;
		else if SP->SCOPE_NODE.ENCLOSING_SCOPE = NULL_NID then do;
			call RELEASE_SCOPE_NODE (S);
			return (STATUS);
		end;
		else	NEXT_S = SP->SCOPE_NODE.ENCLOSING_SCOPE;
		call RELEASE_SCOPE_NODE (S);
	end;

	return (STATUS);

end IS_ENCLOSING_CLASS_OF;

end LOOKUP_CURRENT_QUALIFIED_TYPE;

/* ---------------------------------------------------------------------
/* SET_TYPE_QUALIFIER
/* ------------------------------------------------------------------- */

SET_TYPE_QUALIFIER: procedure external (X_SET_TYPE_QUALIFIER);

	declare T type (SHORT_T);

	T = MATCHED_TOKEN.TYPE;
	if T = KW_CONST_TOKEN then do;
		if (CURRENT_TYPE_QUALIFIER & CONST_TQ) = CONST_TQ then
			call SYNTAX_ERROR (ERR_DUP_TYPE_QUAL);
		else	CURRENT_TYPE_QUALIFIER =
				CURRENT_TYPE_QUALIFIER | CONST_TQ;
	end;
	else if T = KW_VOLATILE_TOKEN then do;
		if (CURRENT_TYPE_QUALIFIER & VOLATILE_TQ) = VOLATILE_TQ then
			call SYNTAX_ERROR (ERR_DUP_TYPE_QUAL);
		else	CURRENT_TYPE_QUALIFIER =
				CURRENT_TYPE_QUALIFIER | VOLATILE_TQ;
	end;

end SET_TYPE_QUALIFIER;

/* ---------------------------------------------------------------------
/* SET_BASE_TYPE
/* ------------------------------------------------------------------- */

SET_BASE_TYPE: procedure external (X_SET_BASE_TYPE);

	if CURRENT_BASE_TYPE ^= NULL_BT then do;
		/*
		/* Already have a class, struct, union, enum,
		/* typedef-name, or other simple type specifier.
		/**/
		goto DONE_SET_BASE_TYPE;
	end;

	/* Set the base type */

	if CURRENT_SIMPLE_TYPES = NULL_SIMPLE_TYPES then
		goto DONE_SET_NULL_BASE_TYPE;

	if CURRENT_SIMPLE_TYPE (KW_VOID_TOKEN) then
		CURRENT_BASE_TYPE = VOID_BT;
	else if CURRENT_SIMPLE_TYPE (KW_CHAR_TOKEN) then
		CURRENT_BASE_TYPE = CHAR_BT;
	else if CURRENT_SIMPLE_TYPE (KW_SHORT_TOKEN) then
		CURRENT_BASE_TYPE = SHORT_BT;
	else if CURRENT_SIMPLE_TYPE (KW_FLOAT_TOKEN) then do;
		if CURRENT_SIMPLE_TYPE (KW_LONG_TOKEN) then
			CURRENT_BASE_TYPE = DOUBLE_BT;
		else	CURRENT_BASE_TYPE = FLOAT_BT;
	end;
	else if CURRENT_SIMPLE_TYPE (KW_DOUBLE_TOKEN) then do;
		if CURRENT_SIMPLE_TYPE (KW_LONG_TOKEN) then
			CURRENT_BASE_TYPE = LDOUBLE_BT;
		else	CURRENT_BASE_TYPE = DOUBLE_BT;
	end;
	else if CURRENT_SIMPLE_TYPE (KW_LONG_TOKEN) then
		CURRENT_BASE_TYPE = LONG_BT;
	else	CURRENT_BASE_TYPE = INT_BT;

	if CURRENT_SIMPLE_TYPE (KW_UNSIGNED_TOKEN) then
		CURRENT_BASE_TYPE = MAP_TO_UNSIGNED_TYPE (CURRENT_BASE_TYPE);

	else if CURRENT_SIMPLE_TYPE (KW_SIGNED_TOKEN) then do;
		/*
		/* Note the following weirdness for signed types: char and
		/* signed char are distinct types so they will be represented
		/* using two separate values, CHAR_BT and SCHAR_BT.  Not so
		/* with short, int, long, and their signed flavors, i.e.
		/* signed short, signed int, & signed long are synonyms for
		/* short, int, & long; we will represent these with the type
		/* codes SHORT_BT, INT_BT, and LONG_BT (i.e. SSHORT_BT,
		/* SINT_BT, SLONG_BT will not be used ... these are in fact
		/* obsolete).  However, in the case of bit-fields, we need
		/* to know whether or not the type is signed (even for short,
		/* int, and long) for proper treatment of the MSB; this is
		/* (only) the purpose of CURRENT_BASE_TYPE_SIGNED.
		/**/
		CURRENT_BASE_TYPE_SIGNED = TRUE;
		if CURRENT_BASE_TYPE = CHAR_BT then
			CURRENT_BASE_TYPE = SCHAR_BT;
	end;

	else if SW_DEFAULT_UNSIGNED_CHAR then do;
		/*
		/* Here, we want plain "char" to map to
		/* "unsigned char" rather than "signed char".
		/**/
		if CURRENT_BASE_TYPE = CHAR_BT then
			CURRENT_BASE_TYPE = UCHAR_BT;
	end;

	DONE_SET_BASE_TYPE:

	CURRENT_BASE_TYPE_UNSPECIFIED = FALSE;

	DONE_SET_NULL_BASE_TYPE:

	/* Set the base type qualifier */

	CURRENT_BASE_TYPE_QUALIFIER = CURRENT_TYPE_QUALIFIER;

	/* Clear this for a possible subsequent declarator */

	CURRENT_TYPE_QUALIFIER = NULL_TQ;
	CURRENT_NAME           = NULL_NID;

end SET_BASE_TYPE;

/* ---------------------------------------------------------------------
/* BEGIN_CLASS_DECLARATION
/* ------------------------------------------------------------------- */

BEGIN_CLASS_DECLARATION: procedure external (X_BEGIN_CLASS_DECLARATION);

	declare T type (SHORT_T);

	if (CURRENT_BASE_TYPE ^= NULL_BT) |
	   (CURRENT_SIMPLE_TYPES ^= NULL_SIMPLE_TYPES) then do;
		/*
		/* Already have a class, struct, union, enum,
		/* typedef-name, or other simple type specifier.
		/**/
		call SYNTAX_ERROR (ERR_INCONSISTENT_TYPES);
	end;

	CURRENT_BASE_TYPE = MAP_TAG_TOKEN (MATCHED_TOKEN.TYPE);
	CURRENT_BASE_TYPE_UNSPECIFIED = FALSE;

	CURRENT_NBASE_CLASSES		 = 0;
	CURRENT_BASE_CLASSES		 = NULL_NID;
	CURRENT_CLASS_ABSTRACTLY_DERIVED = FALSE;
	CURRENT_CLASS_NON_NESTED	 = SW_NO_NESTED_TYPE_NAMES;

end BEGIN_CLASS_DECLARATION;

/* ---------------------------------------------------------------------
/* SET_TAG_EXTERN
/*
/* This will specify that the enumeration about to be declared is to be
/* declared at the current non-class scope (i.e. if this enum is being
/* declared nested (lexically) within class scope).  For example:
/*
/*     class Act {
/*           enum extern boolean { false, true };
/*     };
/*
/* This is an LPI extension to handle our C++ header files (e.g. iostreams)
/* either with or without the "-xnnt" switch (i.e. SW_NO_NESTED_TYPE_NAMES).
/* ------------------------------------------------------------------- */

SET_TAG_EXTERN: procedure external (X_SET_TAG_EXTERN);

	if MAP_STORAGE_CLASS_TOKEN (MATCHED_TOKEN.TYPE) ^= EXTERN_ST then
		call SYNTAX_ERROR (ERR_TAG_STORAGE_CLASS);
	CURRENT_CLASS_NON_NESTED = TRUE;

end SET_TAG_EXTERN;

/* ---------------------------------------------------------------------
/* BEGIN_TAG_NAME
/*
/* Called from the grammar after: { CLASS | STRUCT | UNION | ENUM } name
/* ------------------------------------------------------------------- */

BEGIN_TAG_NAME: procedure external (X_BEGIN_TAG_NAME);

	CURRENT_NAME		= MATCHED_TOKEN.SPELLING;
	CURRENT_NAME_LINE_ID	= MATCHED_TOKEN.LINE;
	CURRENT_NAME_FILE_ID	= CURRENT_SOURCE.FILE;

end BEGIN_TAG_NAME;

/* ---------------------------------------------------------------------
/* SET_TAG_NAME
/* ------------------------------------------------------------------- */

SET_TAG_NAME: procedure external (X_SET_TAG_NAME);

	declare REFERENCE type (BOOL_T);

	/*
	/* See if we've already declared the tag name from
	/* BEGIN_CLASS_BODY.  This seems a little backwards, but is
	/* necessary since a class-specifier can be either a reference
	/* to or a redefinition of a previously declared class.
	/**/

	if CURRENT_BASE_TYPE_ID ^= NULL_NID then
		return;

	/*
	/* Here, this class-specifier is not defining the class body,
	/* but if the next token is a semi-colon (or comma?), then this
	/* is a tag declaration which should hide any declaration of the
	/* tag in an enclosing scope; i.e. it is not merely a tag reference.
	/* I know this seems a bit hacky, but I couldn't come up with more
	/* elegant solution at the time.
	/**/

	REFERENCE = ^AT_START_OF_TAG_DEFINITION ();

	/* Declare this (named) tag symbol */

	call SET_TAG_DECLARATION (REFERENCE);

	/* Clear this for a possible subsequent declarator (needed?) */

	CURRENT_NAME = NULL_NID;

end SET_TAG_NAME;

/* ---------------------------------------------------------------------
/* SET_TAG_DECLARATION
/*
/* Declares the current tag and sets CURRENT_BASE_TYPE_ID appropriately.
/* ------------------------------------------------------------------- */

SET_TAG_DECLARATION: procedure (REFERENCE) internal;

	declare
		REFERENCE			 type (BOOL_T);
	declare
		THIS_KIND			 type (LONG_BITS_T),
		THIS_SCOPE			 type (NID_T),
		P				 type (POINTER_T),
		ANONYMOUS_UNION			 type (BOOL_T),
		NON_NESTED_CLASS_ENCLOSING_CLASS type (NID_T),
		SIZE_UNITS			 type (SHORT_T),
		BOUNDARY			 type (SHORT_T);

	/* Set the appropriate (class/struct/union/enum) symbol kind */

	THIS_KIND = MAP_TAG_KIND (CURRENT_BASE_TYPE);

	/* See if this is an anonymous union */

	ANONYMOUS_UNION = FALSE;

	if (CURRENT_NAME = NULL_NID) & (CURRENT_BASE_TYPE = UNION_BT) then do;
		if PEEK_ANONYMOUS_UNION_BODY () then do;
			ANONYMOUS_UNION = TRUE;
			THIS_KIND = THIS_KIND | ANON_UNION_TAG_SK;
		end;
	end;

	/* Set the scope in which we want to look-up/declare this tag */

	NON_NESTED_CLASS_ENCLOSING_CLASS = NULL_NID;

	if CURRENT_SCOPE_TYPE = CLASS_SCOPE then do;
		if CURRENT_CLASS_NON_NESTED & ^ANONYMOUS_UNION then do;
			/*
			/* If SW_NO_NESTED_TYPE_NAMES is set (i.e. when C mode
			/* or the -xnnt switch is given), then nested classes
			/* will be scoped at the same scope as the enclosing
			/* class tag *except* if the nested class happens to
			/* be an anonymous union; we will also scope this tag
			/* at the same scope as the enclosing class tag if
			/* this class uses our nifty "enum extern" extension
			/* (CURRENT_CLASS_NON_NESTED).
			/**/
			THIS_SCOPE = CURRENT_NON_CLASS_SCOPE;
			if ^CURRENT_FRIEND then
				NON_NESTED_CLASS_ENCLOSING_CLASS 
					= CURRENT_CLASS;
		end;
		else if CURRENT_FRIEND then do;
			/*
			/* Hmmm, see SET_FRIEND_DECLARATION for
			/* some comments on the scoping of friends.
			/*
			/* call SET_SYM_NODE_R (CURRENT_CLASS);
			/* THIS_SCOPE = SYM_NODE.ENCLOSING_SCOPE;
			/**/
			/* THIS_SCOPE = CURRENT_GLOBAL_SCOPE; */
			THIS_SCOPE = CURRENT_SCOPE;
		end;
		else do;
			THIS_SCOPE = CURRENT_SCOPE;
			THIS_KIND = THIS_KIND |
				    MAP_MEMBER_KIND (CURRENT_CLASS_TYPE);
			call GET_SYM_NODE_R (CURRENT_CLASS, P);
			if P->SYM_NODE.IS_ANON_UNION_TAG then
				THIS_KIND = THIS_KIND | ANON_UNION_MEMBER_SK;
			call RELEASE_SYM_NODE (CURRENT_CLASS);
			if ^REFERENCE &
			    (CURRENT_NAME = CURRENT_CLASS_NAME) &
			    (CURRENT_NAME ^= NULL_NID) then do;
				/*
				/* Error; a nested tag (type) name may not
				/* have the same name as its enclosing class.
				/**/
				call SEMANTIC_ERROR_I
				     (ERR_MEMBER_NAME,
				      TOKEN_NAME (CURRENT_CLASS_NAME));
			end;
		end;
	end;
	else if (CURRENT_SCOPE_TYPE = PROTOTYPE_SCOPE) &
		 SW_NO_PROTO_SCOPE_TAG_NAMES then do;
		if ^CURRENT_CLASS_NON_NESTED then do;
			THIS_SCOPE = CURRENT_NON_PROTOTYPE_SCOPE;
			call GET_SCOPE_NODE_R (THIS_SCOPE, P);
			if P->SCOPE_NODE.TYPE = byte (CLASS_SCOPE) then do;
				THIS_KIND = THIS_KIND |
					    MAP_MEMBER_KIND
					    (CURRENT_CLASS_TYPE);
				if ^REFERENCE &
				    (CURRENT_NAME = CURRENT_CLASS_NAME) &
				    (CURRENT_NAME ^= NULL_NID) then do;
					call SEMANTIC_ERROR_I
					     (ERR_MEMBER_NAME,
					      TOKEN_NAME (CURRENT_CLASS_NAME));
				end;
			end;
			call RELEASE_SCOPE_NODE (THIS_SCOPE);
		end;
		else	THIS_SCOPE = CURRENT_GLOBAL_OR_LOCAL_SCOPE;
	end;
	else	THIS_SCOPE = CURRENT_SCOPE;

	/* Check the storage class (et.al.) for anonymous unions */

	if ANONYMOUS_UNION then do;
		if THIS_SCOPE = CURRENT_GLOBAL_SCOPE then do;
			if CURRENT_STORAGE_CLASS ^= STATIC_ST then do;
				/*
				/* Error; a global anonymous union must
				/* be declared as "static" (C++ARM, 9.5).
				/**/
				call SEMANTIC_ERROR (ERR_GLOBAL_ANON_UNION);
				CURRENT_STORAGE_CLASS = STATIC_ST;
			end;
		end;
		else if CURRENT_STORAGE_CLASS ^= NULL_ST then do;
			/*
			/* Strictly, this is an error, but it really seems
			/* to make sense to allow an anonymous union to have
			/* an "auto" or "static" specifier if it's local
			/* (warning for "register"), and a "static" specifier
			/* if it's a member.
			/**/
			if (CURRENT_STORAGE_CLASS = EXTERN_ST) |
			   (CURRENT_STORAGE_CLASS = TYPEDEF_ST) then do;
				/*
				/* Error; an anonoymous union may only have
				/* the storaage class "static" (for a member
				/* or local declaration) or "auto" (for a
				/* local declaration).
				/**/
				call SEMANTIC_ERROR (ERR_ANON_UNION_STORAGE);
				CURRENT_STORAGE_CLASS = NULL_ST;
			end;
			else if (CURRENT_STORAGE_CLASS = REGISTER_ST) &
				((CURRENT_SCOPE_TYPE = BLOCK_SCOPE) |
				 (CURRENT_SCOPE_TYPE = FUNCTION_SCOPE)) then do;
				/*
				/* Warning; ignoring "register" for
				/* local anonymous union declaration.
				/**/
				call SEMANTIC_ERROR (ERR_ANON_UNION_REGISTER);
				CURRENT_STORAGE_CLASS = AUTO_ST;
			end;
		end;
		if (CURRENT_BASE_TYPE_QUALIFIER ^= NULL_TQ) |
		   CURRENT_FRIEND | CURRENT_INLINE |
		   CURRENT_VIRTUAL | CURRENT_OVERLOAD then do;
			/*
			/* Error; type-qualifiers and function specifiers
			/* may not be applied to anonymous unions.
			/**/
			call SEMANTIC_ERROR (ERR_ANON_UNION_SPEC);
		end;
		goto MAKE_TAG_SYMBOL;
	end;

	/*
	/* See if this (tag) name has already been previously declared.
	/* For a class-specifier which is *not* merely a reference to
	/* a class (which exists or which should be implicitly declared),
	/* i.e. if the class body is being defined or the tag is followed
	/* by a semi-colon, see ANSI-C, sec.3.5.2.3), search only the
	/* current scope, since if it's been declared in an enclosing
	/* scope then this is redeclaring it.  Otherwise, search the
	/* current as well as the enclosing scopes, since this is just a
	/* reference to it; if it's not found then implicitly declare it.
	/**/

	CURRENT_BASE_TYPE_ID = NULL_NID;

	if CURRENT_NAME ^= NULL_NID then do;
		if REFERENCE | CURRENT_FRIEND then
			CURRENT_BASE_TYPE_ID =
			LOOKUP_TYPE_NAME_QUIETLY (CURRENT_NAME, THIS_SCOPE);
		else	CURRENT_BASE_TYPE_ID =
			SEARCH_SCOPE_FOR_TYPE (THIS_SCOPE, CURRENT_NAME);
	end;

	if CURRENT_BASE_TYPE_ID = NULL_NID then
		goto MAKE_TAG_SYMBOL;

	/* Here, the current name refers to a tag (it may be a typedef) */

	if SYM_NODE.NAME ^= CURRENT_NAME then do;
		/*
		/* Here we have (e.g) typedef struct X Y; struct Y *P;
		/* which is illegal C++ but legal Classic C (in which
		/* case Y get declared as a new tag).
		/**/
		if ^SW_X_NAME_SPACE then do;
			/*
			/* Error; this tag name has been previously
			/* defined as a "typedef" name in this scope.
			/**/
			call SEMANTIC_ERROR_II
			     (ERR_TYPEDEF_TAG_REDEF,
			      SYMBOL_NAME (CURRENT_BASE_TYPE_ID),
			      SYMBOL_LOCATION_NAME (CURRENT_BASE_TYPE_ID));
		end;
		goto MAKE_TAG_SYMBOL;
	end;

	/* See if this name has been previously declared as a typedef */

	if ^SYM_NODE.IS_TAG then do;
		/*
		/* Here we have (e.g) typedef int s; struct s;
		/* which is illegal C++ but legal Classic C.
		/**/
		if ^SW_X_NAME_SPACE then do;
			/*
			/* Error; this tag name has been previously
			/* defined as a "typedef" name in this scope.
			/**/
			call SEMANTIC_ERROR_II
			     (ERR_TYPEDEF_TAG_REDEF,
			      SYMBOL_NAME (CURRENT_BASE_TYPE_ID),
			      SYMBOL_LOCATION_NAME (CURRENT_BASE_TYPE_ID));
			goto MAKE_TAG_SYMBOL;
		end;
	end;

	else if SYM_NODE.TOP_TYPE.CODE ^= byte (CURRENT_BASE_TYPE) then do;
		/*
		/* Error; this tag name has been  previously defined as a
		/* different kind (i.e. class, struct, union, enum) of tag
		/* in this scope; e.g. "struct s { int m; }; union s x;"
		/* Note that, strangely enoough, this is *not* an error if
		/* the difference is between struct and class, C++ARM 7.1.6.
		/**/
		if ((SYM_NODE.TOP_TYPE.CODE ^= byte (STRUCT_BT)) &
		    (SYM_NODE.TOP_TYPE.CODE ^= byte (CLASS_BT))) |
		   ((CURRENT_BASE_TYPE ^= STRUCT_BT) &
		    (CURRENT_BASE_TYPE ^= CLASS_BT)) then do;
			call SEMANTIC_ERROR_II
			     (ERR_TAG_TAG_REDEF,
			      QUALIFIED_SYMBOL_NAME (CURRENT_BASE_TYPE_ID),
			      SYMBOL_LOCATION_NAME (CURRENT_BASE_TYPE_ID));
			CURRENT_BASE_TYPE = rank (SYM_NODE.TOP_TYPE.CODE);
		end;
		else if ^SYM_NODE.DEFINED then do;
			if CURRENT_BASE_TYPE = STRUCT_BT then do;
				SYM_NODE.TOP_TYPE.CODE = byte (STRUCT_BT);
				SYM_NODE.IS_CLASS_TAG = FALSE;
				SYM_NODE.IS_STRUCT_TAG = TRUE;
				call GET_TYPE_NODE_R (SYM_NODE.TYPE, P);
				P->TYPE_NODE.DATA (0).CODE = byte (STRUCT_BT);
				call RELEASE_TYPE_NODE (SYM_NODE.TYPE);
			end;
			else do;
				SYM_NODE.TOP_TYPE.CODE = byte (CLASS_BT);
				SYM_NODE.IS_CLASS_TAG = TRUE;
				SYM_NODE.IS_STRUCT_TAG = FALSE;
				call GET_TYPE_NODE_R (SYM_NODE.TYPE, P);
				P->TYPE_NODE.DATA (0).CODE = byte (CLASS_BT);
				call RELEASE_TYPE_NODE (SYM_NODE.TYPE);
			end;
		end;
	end;

	else if SYM_NODE.IS_ENUM_TAG then do;
		if ^CURRENT_ENUM_NO_BASE_TYPE then do;
			if SYM_NODE.ENUM_INTEGRAL_TYPE ^=
			   byte (CURRENT_ENUM_BASE_TYPE) then do;
				call SEMANTIC_ERROR_IIII
				     (ERR_DIFF_ENUM_INT_TYPE,
				      QUALIFIED_SYMBOL_NAME
				      (CURRENT_BASE_TYPE_ID),
				      MAP_TYPE_CODE_NAME
				      (CURRENT_ENUM_BASE_TYPE),
				      MAP_TYPE_CODE_NAME
				      (rank (SYM_NODE.ENUM_INTEGRAL_TYPE)),
				      SYMBOL_LOCATION_NAME
				      (CURRENT_BASE_TYPE_ID));
			end;
			if ^SYM_NODE.HAS_ENUM_INTEGRAL_TYPE then do;
				SYM_NODE.HAS_ENUM_INTEGRAL_TYPE = TRUE;
				SYM_NODE.ENUM_INTEGRAL_TYPE =
					byte (CURRENT_ENUM_BASE_TYPE);
				call SIMPLE_TYPE_SIZE (CURRENT_ENUM_BASE_TYPE,
						       SYM_NODE.SIZE,
						       SIZE_UNITS, BOUNDARY);
				SYM_NODE.SIZE_UNITS = byte (SIZE_UNITS);
				SYM_NODE.BOUNDARY   = byte (BOUNDARY);
			end;
		end;
	end;

	return;

	/* Make a new tag sym-node */

	MAKE_TAG_SYMBOL:

	if CURRENT_FRIEND then do;
		/*
		/* What to do here is unclear.  See the C++ARM, 11.4.
		/* "If a class or a function mentioned as a friend
		/* has not been declared its name is entered in the
		/* same scope as the name of the class containing
		/* the friend declaration.
		/**/
		THIS_SCOPE = CURRENT_GLOBAL_SCOPE;
	end;

	if (THIS_SCOPE = CURRENT_PROTOTYPE_SCOPE) & SW_C_PLUS_PLUS then do;
		/*
		/* Warning; a tag is being first declared in prototype scope.
		/* Actually, I'm not entirely sure where C++ stands on this
		/* since there isn't yet the notion of a prototype scope,
		/* but the C++ARM (8.2.5) suggests that there is.
		/**/
		if CURRENT_NAME ^= NULL_NID then
			call SEMANTIC_ERROR_I
			     (ERR_PROTO_TAG_DCL, TOKEN_NAME (CURRENT_NAME));
	end;

	CURRENT_BASE_TYPE_ID = BUILD_SYMBOL (THIS_KIND);

	if IN_NEW_EXPRESSION_LEVEL > 0 then do;
		if SYM_NODE.IS_ENUM_TAG then
			call SEMANTIC_ERROR (ERR_NEW_ENUM_DCL);
	end;
	else if IN_CONVERSION_FUNCTION_DCL then do;
		if SYM_NODE.IS_ENUM_TAG then
			call SEMANTIC_ERROR (ERR_CNVFUN_ENUM_DCL);
	end;

	SYM_NODE.ENCLOSING_CLASS = NON_NESTED_CLASS_ENCLOSING_CLASS;

	/* Install this tag symbol into the symbol table */

	call INSTALL_SYMBOL (CURRENT_BASE_TYPE_ID, THIS_SCOPE);

	/* Return with the new tag symbol paged in */

end SET_TAG_DECLARATION;

/* ---------------------------------------------------------------------
/* BEGIN_CLASS_DERIVATION
/* ------------------------------------------------------------------- */

BEGIN_CLASS_DERIVATION: procedure external (X_BEGIN_CLASS_DERIVATION);

	if ^SW_C_PLUS_PLUS then
		call SEMANTIC_ERROR (ERR_NO_INHERITANCE_ALLOWED);

	/* Save the tag name (restored in SET_CLASS_DERIVATION) */

	call PUSH_NODE (CURRENT_NAME);

	/* Sanity check and set up to read the base class list */

	if CURRENT_BASE_TYPE = UNION_BT then do;
		/*
		/* Error; a union may not have base classes.
		/**/
		call SEMANTIC_ERROR (ERR_DERIVED_UNION);
		return;
	end;

	/*
	/* Clear the base class list data (CURRENT_NBASE_CLASSES and
	/* CURRENT_BASE_CLASSES were cleared in BEGIN_CLASS_DECLARATION).
	/**/

	CURRENT_BASE_CLASS_ACCESS  = NULL_ACCESS;
	CURRENT_BASE_CLASS_VIRTUAL = FALSE;
	CURRENT_LAST_BASE_CLASS	   = NULL_NID;

end BEGIN_CLASS_DERIVATION;

/* ---------------------------------------------------------------------
/* SET_PUBLIC_BASE_CLASS
/* ------------------------------------------------------------------- */

SET_PUBLIC_BASE_CLASS: procedure external (X_SET_PUBLIC_BASE_CLASS);

	if CURRENT_BASE_CLASS_ACCESS ^= NULL_ACCESS then do;
		/*
		/* Warning; confilicting or duplicate
		/* base class specifiers; ignored.
		/**/
		call SEMANTIC_ERROR (ERR_INCONSISTENT_BASE_CLASS_SPEC);
	end;
	else	CURRENT_BASE_CLASS_ACCESS = PUBLIC_ACCESS;

end SET_PUBLIC_BASE_CLASS;

/* ---------------------------------------------------------------------
/* SET_PRIVATE_BASE_CLASS
/* ------------------------------------------------------------------- */

SET_PRIVATE_BASE_CLASS: procedure external (X_SET_PRIVATE_BASE_CLASS);

	if CURRENT_BASE_CLASS_ACCESS ^= NULL_ACCESS then do;
		/*
		/* Warning; confilicting or duplicate
		/* base class specifiers; ignored.
		/**/
		call SEMANTIC_ERROR (ERR_INCONSISTENT_BASE_CLASS_SPEC);
	end;
	else	CURRENT_BASE_CLASS_ACCESS = PRIVATE_ACCESS;

end SET_PRIVATE_BASE_CLASS;

/* ---------------------------------------------------------------------
/* SET_PROTECTED_BASE_CLASS
/* ------------------------------------------------------------------- */

SET_PROTECTED_BASE_CLASS: procedure external (X_SET_PROTECTED_BASE_CLASS);

	if CURRENT_BASE_CLASS_ACCESS ^= NULL_ACCESS then do;
		/*
		/* Warning; confilicting or duplicate
		/* base class specifiers; ignored.
		/**/
		call SEMANTIC_ERROR (ERR_INCONSISTENT_BASE_CLASS_SPEC);
	end;
	else	CURRENT_BASE_CLASS_ACCESS = PROTECTED_ACCESS;

end SET_PROTECTED_BASE_CLASS;

/* ---------------------------------------------------------------------
/* SET_VIRTUAL_BASE_CLASS
/* ------------------------------------------------------------------- */

SET_VIRTUAL_BASE_CLASS: procedure external (X_SET_VIRTUAL_BASE_CLASS);

	if CURRENT_BASE_CLASS_VIRTUAL then do;
		/*
		/* Warning; duplicate "virtual"
		/* base class specifier; ignored.
		/**/
		call SEMANTIC_ERROR (ERR_DUP_VIRTUAL_BASE_CLASS_SPEC);
	end;
	else	CURRENT_BASE_CLASS_VIRTUAL = TRUE;

end SET_VIRTUAL_BASE_CLASS;

/* ---------------------------------------------------------------------
/* SET_BASE_CLASS
/* ------------------------------------------------------------------- */

SET_BASE_CLASS: procedure external (X_SET_BASE_CLASS);

	declare
		BASE_CLASS		type (NID_T),
		BASE_CLASS_SYMBOL	type (NID_T),
		BCP			type (POINTER_T);

	if CURRENT_BASE_TYPE = UNION_BT then do;
		/*
		/* Error; a union may not have base classes.
		/* Diagnostic given in BEGIN_CLASS_DERIVATION.
		/**/
		goto DONE_SET_BASE_CLASS;
	end;

	/* Make sure the named base class is a visible/accessible class type */

	BASE_CLASS_SYMBOL = LOOKUP_CURRENT_QUALIFIED_TYPE ();

	if BASE_CLASS_SYMBOL = NULL_NID then do;
		/*
		/* Error; a class (tag) name is expected.
		/**/
		if CURRENT_NAME_SCOPE_SYMBOL ^= NULL_NID then
			call SEMANTIC_ERROR_I
			     (ERR_UNDEF_BASE_CLASS,
			      MAKE_QUALIFIED_NAME
			      (CURRENT_NAME_SCOPE_SYMBOL, CURRENT_NAME));
		else	call SEMANTIC_ERROR_I
			     (ERR_UNDEF_BASE_CLASS,
			      TOKEN_NAME (CURRENT_NAME));
		return;
	end;
	else if BASE_CLASS_SYMBOL = CURRENT_BASE_TYPE_ID then do;
		/*
		/* Error; attempt to derive a class from itself!
		/**/
		call SEMANTIC_ERROR (ERR_SELF_REF_BASE_CLASS);
		return;
	end;
	else if SYM_NODE.IS_UNION_TAG then do;
		/*
		/* Error; a union may not be used as a base class.
		/**/
		call SEMANTIC_ERROR (ERR_BASE_CLASS_UNION);
		return;
	end;
	else if ^SYM_NODE.IS_AGGREGATE_TAG then do;
		if IS_AGGREGATE_TAG_TYPE (rank (SYM_NODE.TOP_TYPE.CODE)) &
		   SYM_NODE.IS_TYPE then do;
			/*
			/* E.g. typedef class A {} T; class B : A {};
			/* This is perfectly legal; see C++ARM, 7.1.3.
			/*
			/* if ^SW_ALLOW_TYPEDEF_AS_BASE_CLASS then do;
			/*	/*
			/*	/* Violation; a class name should be used
			/*	/* directly as the name of a base class,
			/*	/* not a typedef name which refers to it.
			/*	/**/
			/*	call SEMANTIC_ERROR_II
			/*	     (ERR_TYPEDEF_BASE_CLASS,
			/*	      QUALIFIED_SYMBOL_NAME
			/*	      (SYM_NODE.TOP_TYPE.TAG_SYMBOL),
			/*	      QUALIFIED_SYMBOL_NAME
			/*	      (BASE_CLASS_SYMBOL));
			/* end;
			/**/
			BASE_CLASS_SYMBOL = SYM_NODE.TOP_TYPE.TAG_SYMBOL;
			call SET_SYM_NODE_R (BASE_CLASS_SYMBOL);
		end;
		else do;
			/*
			/* Error; a defined base class name is expected.
			/**/
			call SEMANTIC_ERROR_I (ERR_UNDEF_BASE_CLASS,
					       QUALIFIED_SYMBOL_NAME
					       ((CURRENT_NODE_ID)));
			return;
		end;
	end;
	if SYM_NODE.DEFINED_SCOPE = NULL_NID then do;
		/*
		/* Error; a base class must be previously defined.
		/**/
		call SEMANTIC_ERROR_I (ERR_UNDEF_BASE_CLASS,
				       QUALIFIED_SYMBOL_NAME
				       ((CURRENT_NODE_ID)));
		return;
	end;
	else if SEARCH_BASE_CLASS_LIST
		(CURRENT_BASE_CLASSES, BASE_CLASS_SYMBOL) ^= NULL_NID then do;
		/*
		/* Error; this base class has already been listed
		/* as a base class of this derived class definition.
		/**/
		call SEMANTIC_ERROR (ERR_DUP_BASE_CLASS);
		return;
	end;


	/* Default to private class derivation if none given */

	if CURRENT_BASE_CLASS_ACCESS = NULL_ACCESS then do;
		/*
		/* Note; no base class access specifier given;
		/* defaulting to private for a derived class;
		/* defaulting to public for a derived struct;
		/**/
		if CURRENT_BASE_TYPE = CLASS_BT then do;
			if SW_LINT then
				call SEMANTIC_ERROR
				     (ERR_DEFAULT_PRIVATE_DERIVATION);
			CURRENT_BASE_CLASS_ACCESS = PRIVATE_ACCESS;
		end;
		else do;
			if SW_LINT then
				call SEMANTIC_ERROR
				     (ERR_DEFAULT_PUBLIC_DERIVATION);
			CURRENT_BASE_CLASS_ACCESS = PUBLIC_ACCESS;
		end;
	end;

	/* Ok, all's well; allocate a base class node */

	call NEW_BASE_CLASS_NODE (BASE_CLASS, BCP);

	/* Fill in the base class node */

	BCP->BASE_CLASS_NODE.SYMBOL  = BASE_CLASS_SYMBOL;
	BCP->BASE_CLASS_NODE.ACCESS  = byte (CURRENT_BASE_CLASS_ACCESS);
	BCP->BASE_CLASS_NODE.VIRTUAL = CURRENT_BASE_CLASS_VIRTUAL;

	if SYM_NODE.ABSTRACT then do;
		BCP->BASE_CLASS_NODE.ABSTRACT = TRUE;
		CURRENT_CLASS_ABSTRACTLY_DERIVED = TRUE;
	end;

	call RELEASE_BASE_CLASS_NODE (BASE_CLASS);

	/* Link the base class node into the current base class node list */

	if CURRENT_LAST_BASE_CLASS ^= NULL_NID then do;
		call SET_BASE_CLASS_NODE (CURRENT_LAST_BASE_CLASS);
		BASE_CLASS_NODE.NEXT = BASE_CLASS;
	end;
	else	CURRENT_BASE_CLASSES = BASE_CLASS;

	CURRENT_LAST_BASE_CLASS = BASE_CLASS;
	CURRENT_NBASE_CLASSES = CURRENT_NBASE_CLASSES + 1;

	DONE_SET_BASE_CLASS:

	/* Re-initialize the base class specifiers */

	CURRENT_BASE_CLASS_ACCESS  = NULL_ACCESS;
	CURRENT_BASE_CLASS_VIRTUAL = FALSE;

end SET_BASE_CLASS;

/* ---------------------------------------------------------------------
/* SET_CLASS_DERIVATION
/* ------------------------------------------------------------------- */

SET_CLASS_DERIVATION: procedure external (X_SET_CLASS_DERIVATION);

	/* Restore the tag name (saved in BEGIN_CLASS_DERIVATION) */

	CURRENT_NAME = POP_NODE ();

	/*
	/* Check to see if there are any direct base classes 
	/* classes which are also indirect base classes.
	/**/

	call CHECK_DUPLICATE_BASE_CLASSES
		(CURRENT_BASE_CLASSES, CURRENT_NAME);

end SET_CLASS_DERIVATION;

/* ---------------------------------------------------------------------
/* SET_DEFAULT_STRUCT_ALIGNMENT
/*
/* Handle -pack option
/* ------------------------------------------------------------------- */

SET_DEFAULT_STRUCT_ALIGNMENT: procedure (N)
			      external  (X_SET_DEFAULT_STRUCT_ALIGNMENT);

	declare N type (SHORT_T);

	if      N = 1 then DEFAULT_STRUCT_ALIGNMENT = BYTES;
	else if N = 2 then DEFAULT_STRUCT_ALIGNMENT = HALF_WORDS;
	else if N = 4 then DEFAULT_STRUCT_ALIGNMENT = WORDS;
	CURRENT_STRUCT_ALIGNMENT = DEFAULT_STRUCT_ALIGNMENT;

end SET_DEFAULT_STRUCT_ALIGNMENT;

/* ---------------------------------------------------------------------
/* SET_STRUCT_ALIGNMENT
/*
/* Handle #pragma pack
/* ------------------------------------------------------------------- */

SET_STRUCT_ALIGNMENT: procedure (N) external (X_SET_STRUCT_ALIGNMENT);

	declare N type (SHORT_T);

	if      N = 0 then CURRENT_STRUCT_ALIGNMENT = DEFAULT_STRUCT_ALIGNMENT;
	else if N = 1 then CURRENT_STRUCT_ALIGNMENT = BYTES;
	else if N = 2 then CURRENT_STRUCT_ALIGNMENT = HALF_WORDS;
	else if N = 4 then CURRENT_STRUCT_ALIGNMENT = WORDS;

end SET_STRUCT_ALIGNMENT;

/* ---------------------------------------------------------------------
/* BEGIN_CLASS_BODY
/* ------------------------------------------------------------------- */

BEGIN_CLASS_BODY: procedure external (X_BEGIN_CLASS_BODY);

	declare
		THIS_SCOPE	type (NID_T);

	/* Declare this named or unnamed tag */

	call SET_TAG_DECLARATION (FALSE);

	/* Make sure this tag has not been previously *defined* */

	call SET_SYM_NODE_R (CURRENT_BASE_TYPE_ID);

	/* Set the base class list of the class symbol */

	SYM_NODE.BASE_CLASSES  = CURRENT_BASE_CLASSES;
	SYM_NODE.NBASE_CLASSES = CURRENT_NBASE_CLASSES;

	/* For CodeWatch only, maintain a derived class list */

	if SYMBOL_TABLE then
		call UPDATE_DERIVED_CLASS_LISTS ();

	/* Make sure this class hasn't been previously defined */

	if SYM_NODE.DEFINED_SCOPE ^= NULL_NID then do;
		/*
		/* Error; this class has already been defined.
		/**/
		call SEMANTIC_ERROR_II
		     (ERR_REDEF_CLASS,
		      QUALIFIED_SYMBOL_NAME (CURRENT_BASE_TYPE_ID),
		      SYMBOL_LOCATION_NAME (CURRENT_BASE_TYPE_ID));
	end;

	/*
	/* See if a class, struct, union, or enum is being defined in:
	/*
	/* 1. A "new" expression.
	/*    This is illegal in C++ (5.3.3).
	/* 3. A conversion operator.
	/*    This is illegal in C++ (12.3.2)
	/* 3. A "sizeof" expression.  
	/*    This is illegal in C++ (5.3.3), but legal (apparently) in C.
	/* 4. A cast expression.  
	/*    This is illegal in C++ (5.4), but legal (apparently) in C.
	/* 5. Prototype scope (i.e. in a formal argument type).
	/*    This is illegal C++ (8.2.5), but legal (apparently) in C.
	/*
	/* N.B. The check for a class, struct, union, or enum being defined
	/* in a function return type, which is illegal in C++ (8.2.5) but
	/* legal (apparently) in C,  is done in VALID_BASE_TYPE using the
	/* global CURRENT_BASE_TYPE_TAG_DEFINITION set to TRUE here
	/**/

	if ^CURRENTLY_DOING_INTERNAL_PARSE then do;
		if IN_NEW_EXPRESSION_LEVEL > 0 then                   /* 1 */
			call SEMANTIC_ERROR (ERR_NEW_TAG_DEF);
		else if IN_CONVERSION_FUNCTION_DCL then               /* 2 */
			call SEMANTIC_ERROR (ERR_CNVFUN_TAG_DEF);
		else if IN_SIZEOF > 0 then do;                        /* 3 */
			if SW_C_PLUS_PLUS then
				call SEMANTIC_ERROR (ERR_SIZEOF_TAG_DEF);
		end;
		else if IN_PAREN_TYPE_NAME_LEVEL > 0 then do;         /* 4 */
			if SW_C_PLUS_PLUS then
				call SEMANTIC_ERROR (ERR_CAST_TAG_DEF);
		end;
		else if CURRENT_SCOPE_TYPE = PROTOTYPE_SCOPE then do; /* 5 */
			/*
			/* Error; a tag may not be defined within
			/* a prototype scope (C++ARM, 8.2.5).
			/**/
			if SW_C_PLUS_PLUS then
				call SEMANTIC_ERROR (ERR_PROTO_TAG_DEF);
		end;
	end;

	/*
	/* Note that the current type is a tag definition; this is only
	/* used to enforce the (strange) restriction that the (base) return
	/* type of a function may not be a tag definition (C++ARM, 8.2.5).
	/**/

	CURRENT_BASE_TYPE_TAG_DEFINITION = TRUE;

	/* Create a class scope for this class definition */

	call BEGIN_CLASS_SCOPE (CURRENT_BASE_TYPE_ID);

	/* Save the current class definition state, if any (nested) */

	call SAVE_CLASS_STATE ();

	/* Save the current declaration state */

	/*
	/* This is just for storage class or type qualifier I think;
	/* e.g.  class A { static class B { ... } b; ... };
	/**/

	call SAVE_DECLARATION_STATE ();

	/*
	/* The following is to ensure the this is legal:
	/*     extern "C" class A { static int m; } x;
	/* but this is not legal:
	/*     extern "C" extern x;
	/**/

	CURRENT_SIMPLE_LINKAGE_SPECIFIER = FALSE;

	/* Get ready to process the member list */

	CURRENT_CLASS		= CURRENT_BASE_TYPE_ID;
	CURRENT_CLASS_NAME	= SYM_NODE.NAME;
	CURRENT_CLASS_TYPE	= rank (SYM_NODE.TOP_TYPE.CODE);
	CURRENT_CLASS_DERIVED	= (CURRENT_NBASE_CLASSES > 0);

	/* Set the default access specifier */

	if CURRENT_CLASS_TYPE = CLASS_BT then
		CURRENT_MEMBER_ACCESS = PRIVATE_ACCESS;
	else	CURRENT_MEMBER_ACCESS = PUBLIC_ACCESS;

	/* Initialize the rest of the member data */

	CURRENT_BIT_FIELD      = -1;    /* bit-field members only */
	CURRENT_PURE_SPECIFIER = FALSE; /* member functions only */

	/* Initialize the class needs bits */

	call INITIALIZE_CLASS_NEEDS (CURRENT_CLASS,
				     CURRENT_NBASE_CLASSES,
				     CURRENT_BASE_CLASSES);

	/* Allocate space in this class for any base classes */

	call INITIALIZE_CLASS_SIZE (CURRENT_CLASS);

	/* Set other pertinent class data */

	if CURRENT_CLASS_ABSTRACTLY_DERIVED then
		SYM_NODE.HAS_ABSTRACT_BASE = TRUE;

	return;

/* ---------------------------------------------------------------------
/* INITIALIZE_CLASS_NEEDS
/*
/* Initialize the class's NEEDS_xxx flags, taking into account the base
/* classes.  NEEDS_INIT, NEEDS_COPY, NEEDS_ASSIGN, & NEEDS_DESTRUCTION
/* indicate the substantiality of the class's default constructor, copy
/* constructor, assignment member function, and destructor respectively.
/* If these are not set, then the default constructor and destructor do
/* nothing, while the copy constructor and assignment merely perform a
/* bitwise copy.  Preserves current-node-id.
/* ------------------------------------------------------------------- */

INITIALIZE_CLASS_NEEDS: procedure (CLASS, NBASE_CLASSES, BASE_CLASSES)
			internal;
	declare
		CLASS		type (NID_T),
		NBASE_CLASSES	type (SHORT_T),
		BASE_CLASSES	type (NID_T);
	declare
		(BC, NEXT_BC)	type (NID_T),
		(CP, BCP, P)	type (POINTER_T);

	if BASE_CLASSES = NULL_NID then
		return;

	call GET_SYM_NODE (CLASS, CP);

	if NBASE_CLASSES > 1 then do;
		CP->NEEDS_INIT = TRUE;
		CP->NEEDS_COPY = TRUE;
	end;

	do BC = BASE_CLASSES repeat (NEXT_BC) while (BC ^= NULL_NID);

		call GET_BASE_CLASS_NODE_R (BC, BCP);

		call GET_SYM_NODE_R (BCP->BASE_CLASS_NODE.SYMBOL, P);

		if P->SYM_NODE.HAS_CONST_MEMBER then
			CP->SYM_NODE.HAS_CONST_MEMBER	= TRUE;
		if P->SYM_NODE.NEEDS_INIT then
			CP->SYM_NODE.NEEDS_INIT		= TRUE;
		if P->SYM_NODE.NEEDS_COPY then
			CP->SYM_NODE.NEEDS_COPY		= TRUE;
		if P->SYM_NODE.NEEDS_ASSIGN then
			CP->SYM_NODE.NEEDS_ASSIGN	= TRUE;
		if P->SYM_NODE.NEEDS_DESTRUCTION then
			CP->SYM_NODE.NEEDS_DESTRUCTION	= TRUE;

		call RELEASE_SYM_NODE (BCP->BASE_CLASS_NODE.SYMBOL);

		if BCP->BASE_CLASS_NODE.VIRTUAL then do;
			CP->SYM_NODE.NEEDS_INIT   = TRUE;
			CP->SYM_NODE.NEEDS_COPY   = TRUE;
			CP->SYM_NODE.NEEDS_ASSIGN = TRUE;
		end;

		NEXT_BC = BCP->BASE_CLASS_NODE.NEXT;

		call RELEASE_BASE_CLASS_NODE (BC);
	end;

	call RELEASE_SYM_NODE (CLASS);

end INITIALIZE_CLASS_NEEDS;

/* ---------------------------------------------------------------------
/* UPDATE_DERIVED_CLASS_LIST
/*
/* Update the derived class lists of each of the base classes on the
/* base class list of the class symbol represented by the currently
/* paged in sym-node, to include said symbol as a derived class.
/* Preserves current-node-id.
/*
/* This is ostensibly only for CodeWatch.
/* ------------------------------------------------------------------- */

UPDATE_DERIVED_CLASS_LISTS: procedure internal;

	declare
		DERIVED_CLASS		type (NID_T),
		(BC, NEXT_BC)		type (NID_T),
		(DC, NEXT_DC)		type (NID_T),
		(BCP, BSP, DCP)		type (POINTER_T);

	do BC = SYM_NODE.BASE_CLASSES
	repeat (NEXT_BC) while (BC ^= NULL_NID);
		call NEW_DERIVED_CLASS_NODE (DERIVED_CLASS, DCP);
		DCP->DERIVED_CLASS_NODE.SYMBOL = CURRENT_NODE_ID;
		DCP->DERIVED_CLASS_NODE.NEXT = NULL_NID;
		call RELEASE_DERIVED_CLASS_NODE (DERIVED_CLASS);
		call GET_BASE_CLASS_NODE_R (BC, BCP);
		call GET_SYM_NODE (BCP->BASE_CLASS_NODE.SYMBOL, BSP);
		if BSP->SYM_NODE.DERIVED_CLASSES ^= NULL_NID then do;
			do DC = BSP->SYM_NODE.DERIVED_CLASSES
			repeat (NEXT_DC) while (DC ^= NULL_NID);
				call GET_DERIVED_CLASS_NODE (DC, DCP);
				if DCP->DERIVED_CLASS_NODE.NEXT = NULL_NID
				then do;
					DCP->DERIVED_CLASS_NODE.NEXT
						= DERIVED_CLASS;
					NEXT_DC = NULL_NID;
				end;
				else	NEXT_DC = DCP->DERIVED_CLASS_NODE.NEXT;
				call RELEASE_DERIVED_CLASS_NODE (DC);
			end;
		end;
		else	BSP->SYM_NODE.DERIVED_CLASSES = DERIVED_CLASS;
		call RELEASE_SYM_NODE (BCP->BASE_CLASS_NODE.SYMBOL);
		NEXT_BC = BCP->BASE_CLASS_NODE.NEXT;
		call RELEASE_BASE_CLASS_NODE (BC);
	end;

end UPDATE_DERIVED_CLASS_LISTS;

end BEGIN_CLASS_BODY;

/* ---------------------------------------------------------------------
/* SET_PUBLIC_MEMBER_ACCESS
/* ------------------------------------------------------------------- */

SET_PUBLIC_MEMBER_ACCESS: procedure external (X_SET_PUBLIC_MEMBER_ACCESS);

	CURRENT_MEMBER_ACCESS = PUBLIC_ACCESS;

end SET_PUBLIC_MEMBER_ACCESS;

/* ---------------------------------------------------------------------
/* SET_PRIVATE_MEMBER_ACCESS
/* ------------------------------------------------------------------- */

SET_PRIVATE_MEMBER_ACCESS: procedure external (X_SET_PRIVATE_MEMBER_ACCESS);

	CURRENT_MEMBER_ACCESS = PRIVATE_ACCESS;

end SET_PRIVATE_MEMBER_ACCESS;

/* ---------------------------------------------------------------------
/* SET_PROTECTED_MEMBER_ACCESS
/* ------------------------------------------------------------------- */

SET_PROTECTED_MEMBER_ACCESS: procedure external (X_SET_PROTECTED_MEMBER_ACCESS);

	CURRENT_MEMBER_ACCESS = PROTECTED_ACCESS;

end SET_PROTECTED_MEMBER_ACCESS;

/* ---------------------------------------------------------------------
/* BEGIN_BIT_FIELD
/* ------------------------------------------------------------------- */

BEGIN_BIT_FIELD: procedure external (X_BEGIN_BIT_FIELD);

	/*
	/* Save the current bit-field name in case the bit-field specifier
	/* is a constant expression containing an identifier; this was not
	/* possible in C, but it is in C++, for example:
	/*
	/*	const int bf_size = 12;
	/*	struct A { int x : bf_size; };
	/**/

	call SAVE_NAME_STATE ();

end BEGIN_BIT_FIELD;

/* ---------------------------------------------------------------------
/* SET_BIT_FIELD
/* ------------------------------------------------------------------- */

SET_BIT_FIELD: procedure external (X_SET_BIT_FIELD);

	call RESTORE_NAME_STATE ();

	/* Check the bit-field specifier constant */

	if CURRENT_CONSTANT_NON_CONSTANT |
	   (CURRENT_CONSTANT_VALUE < 0) then do;
		/*
		/* Error; the size of a bit-field must specified
		/* as a non-negative-valued constant expression.
		/**/
		call SEMANTIC_ERROR (ERR_BIT_FIELD_SIZE);
		CURRENT_BIT_FIELD = 1;
	end;
	else	CURRENT_BIT_FIELD = CURRENT_CONSTANT_VALUE;

end SET_BIT_FIELD;

/* ---------------------------------------------------------------------
/* SET_PURE_SPECIFIER
/* ------------------------------------------------------------------- */

SET_PURE_SPECIFIER: procedure external (X_SET_PURE_SPECIFIER);

	if CURRENT_DERIVED_TYPE_LEVEL <= 0 then do;
		/*
		/* Error; cannot initialize data members.
		/**/
		call SEMANTIC_ERROR (ERR_INIT_DATA_MEM);
	end;
	else if TOP_DERIVED_TYPE
		(CURRENT_DERIVED_TYPE_LEVEL) ^= FUNCTION_DT then do;
		/*
		/* Error; cannot initialize data members.
		/**/
		call SYNTAX_ERROR (ERR_INIT_DATA_MEM);
	end;
	else if (CURRENT_CONSTANT_VALUE ^= 0) |
		CURRENT_CONSTANT_NON_CONSTANT then do;
		/*
		/* Error; a pure virtual function specifier must
		/* specify a zero-valued constant expression; ignored.
		/**/
		call SEMANTIC_ERROR (ERR_NON_ZERO_PURE_SPEC);
		return;
	end;
	else	CURRENT_PURE_SPECIFIER = TRUE;

end SET_PURE_SPECIFIER;

/* ---------------------------------------------------------------------
/* SET_MEMBER_DECLARATION
/* ------------------------------------------------------------------- */

SET_MEMBER_DECLARATION: procedure external (X_SET_MEMBER_DECLARATION);

	declare
		THIS_MEMBER		type (NID_T),
		THIS_KIND		type (LONG_BITS_T),
		THIS_SCOPE		type (NID_T),
		PREV_SYMBOL		type (NID_T),
		PREV_OVERLOAD		type (NID_T),
		STATUS			type (INT_T),
		VIRTUAL_INDEX		type (SHORT_T),
		VIRTUAL_COUNT		type (SHORT_T),
		ID			type (NID_T),
		P			type (POINTER_T),
		OCM			type (OCM_T),
		(S, NEXT_S)		type (NID_T),
		IS_CONST_MEMBER		type (BOOL_T),
		IS_REFERENCE_MEMBER	type (BOOL_T),
		CURRENT_CLASS_PTR	type (POINTER_T),
		THIS_TAG		type (NID_T);

	call RESTORE_DECLARATOR_SCOPE ();

	/*
	/* First, process in *order*, the following:
	/*
	/* 1. friend declarations
	/* 2. typedef declarations
	/* 3. member access adjustment declarations
	/* 4. bit-field declarations
	/* 5. null declarator declarations (error check only)
	/**/

	/* 1. Handle a "friend" declaration */

	if CURRENT_FRIEND then do;
		call SET_FRIEND_DECLARATION ();
		return;
	end;

	/* 2. Handle a "typedef" declaration */

	if CURRENT_STORAGE_CLASS = TYPEDEF_ST then do;
		call SET_TYPEDEF_DECLARATION ();
		return;
	end;

	/* 3. Handle a bit-field declaration */

	if CURRENT_BIT_FIELD >= 0 then do;
		call SET_BIT_FIELD_DECLARATION ();
		return;
	end;

	/* 4. Handle a member access (adjustment) declaration */

	if HAVE_MEMBER_ACCESS_DECLARATION () then do;
		call SET_MEMBER_ACCESS_DECLARATION ();
		return;
	end;

	/* 5. Handle a null declarator declaration (error check only) */

	if CURRENT_NAME = NULL_NID then do;
		call CHECK_NULL_DECLARATOR ();
		return;
	end;

	/* ---------------------------------------------------------
	/* Here, we have neither a a friend declaration, a member
	/* access declaration, a bit-field declaration, a typedef
	/* declaration, nor a null declarator declaration.
	/* ------------------------------------------------------- */

	/* Page in the parent class sym-node for the duration */

	call GET_SYM_NODE (CURRENT_CLASS, CURRENT_CLASS_PTR);

	/*
	/* Build a type-node for this member declaration from the current
	/* declaration data; sets CURRENT_TYPE & CURRENT_TOP_TYPE, and
	/* leaves the current declaration specifier and name data intact.
	/**/

	call BUILD_CURRENT_MEMBER_TYPE ();
	if ^AT_FUNCTION_DEFINITION () then
		call FREE_CURRENT_PROTOTYPE_SCOPE ();

	/*
	/* Process the declarator name for this (non-friend, non-typedef,
	/* non-bit-field, non-access-adjustment) member declaration.
	/**/

	if ^VALID_DECLARATOR_NAME (MEMBER_DCL) then
		goto ERROR_SET_MEMBER_DECLARATION;

	/* Perform various sanity checks on the base type */

	if ^VALID_BASE_TYPE () then
		goto ERROR_SET_MEMBER_DECLARATION;

	/* Member functions are only allowed in C++ mode */

	if ^SW_C_PLUS_PLUS then do;
		if CURRENT_TOP_TYPE.CODE = byte (FUNCTION_DT) then
			call SEMANTIC_ERROR (ERR_NO_MEMBER_FUN);
	end;

	/* Check the storage class; it may only be "static" */

	if CURRENT_STORAGE_CLASS = STATIC_ST then do;
		if ^SW_C_PLUS_PLUS then do;
			call SEMANTIC_ERROR (ERR_BAD_C_MEMBER_STORAGE);
			CURRENT_STORAGE_CLASS = NULL_ST;
		end;
		/*
		/* If this is a static data member, then make sure it does
		/* not have the same name is its enclosing class tag name
		/* (C++ARM, 9.2); e.g. "class A { static int A; };".
		/**/
		else if CURRENT_TOP_TYPE.CODE ^= byte (FUNCTION_DT) then do;
			if (CURRENT_NAME_KIND = VANILLA_NK) &
			   (CURRENT_NAME = CURRENT_CLASS_NAME) then do;
				/*
				/* Error; a static data member may not have
				/* the same name as its enclosing class
				/* (C++ARM, 9.2).
				/**/
				call SEMANTIC_ERROR_I
				     (ERR_MEMBER_NAME,
				      TOKEN_NAME (CURRENT_NAME));
				goto ERROR_SET_MEMBER_DECLARATION;
			end;
			if CURRENT_FUNCTION_SCOPE ^= NULL_NID then do;
				/*
				/* Error; local classes may not have
				/* static data members (C++ARM, 9.9).
				/**/
				call SEMANTIC_ERROR (ERR_LOCAL_STATIC_DATA_MEM);
			end;
			if CURRENT_CLASS_TYPE = UNION_BT then do;
				/*
				/* Error; a union may not have
				/* static data members.
				/**/
				call SEMANTIC_ERROR (ERR_STATIC_UNION_MEMBER);
				CURRENT_STORAGE_CLASS = NULL_ST;
			end;
		end;

		call CHECK_QUALIFIED_SIGNATURE (CURRENT_TOP_TYPE);
	end;
	else if CURRENT_STORAGE_CLASS ^= NULL_ST then do;
		/*
		/* Error; "static" is the only legal
		/* storage class specifier for members.
		/**/
		if ^SW_C_PLUS_PLUS then
			call SEMANTIC_ERROR (ERR_BAD_C_MEMBER_STORAGE);
		else	call SEMANTIC_ERROR (ERR_BAD_MEMBER_STORAGE);
		CURRENT_STORAGE_CLASS = NULL_ST;
	end;

	/* Check any function specifiers */

	if CURRENT_OVERLOAD then do;
		if CURRENT_TOP_TYPE.CODE ^= byte (FUNCTION_DT) then
			goto ERROR_SET_MEMBER_DECLARATION;
	end;
	if CURRENT_VIRTUAL then do;
		if CURRENT_TOP_TYPE.CODE ^= byte (FUNCTION_DT) then do;
			/*
			/* Error; the "virtual" specifier may only
			/* only be used within a class definition
			/* for a member function declaration.
			/**/
			call SEMANTIC_ERROR (ERR_BAD_VIRTUAL);
			CURRENT_VIRTUAL = FALSE;
		end;
		if CURRENT_CLASS_TYPE = UNION_BT then do;
			/*
			/* Error; a union may not have virtual members.
			/**/
			call SEMANTIC_ERROR (ERR_VIRTUAL_UNION_MEMBER);
			CURRENT_VIRTUAL = FALSE;
		end;
		if CURRENT_STORAGE_CLASS = STATIC_ST then do;
			/*
			/* Error; a virtual function may not be static.
			/**/
			call SEMANTIC_ERROR (ERR_VIRTUAL_STATIC);
			CURRENT_STORAGE_CLASS = NULL_ST;
		end;
	end;
	if CURRENT_INLINE then do;
		if CURRENT_TOP_TYPE.CODE ^= byte (FUNCTION_DT) then do;
			/*
			/* Error; the "inline" specifier may
			/* only be used with function types.
			/**/
			call SEMANTIC_ERROR (ERR_BAD_INLINE);
			CURRENT_INLINE = FALSE;
		end;
	end;
	if CURRENT_PURE_SPECIFIER then do;
		if (CURRENT_TOP_TYPE.CODE ^= byte (FUNCTION_DT)) |
		   ^CURRENT_VIRTUAL then do;
			/*
			/* Error; a pure specifier may only be
			/* applied to virtual member functions.
			/**/
			call SEMANTIC_ERROR (ERR_PURE_SPEC);
			CURRENT_VIRTUAL = TRUE;
		end;
	end;
	if CURRENT_VIRTUAL then do;
		CURRENT_CLASS_PTR->SYM_NODE.NEEDS_INIT   = TRUE;
		CURRENT_CLASS_PTR->SYM_NODE.NEEDS_COPY   = TRUE;
		CURRENT_CLASS_PTR->SYM_NODE.NEEDS_ASSIGN = TRUE;
		if CURRENT_PURE_SPECIFIER then
			CURRENT_CLASS_PTR->SYM_NODE.ABSTRACT = TRUE;
	end;

	/* Check special member functions */

	if CURRENT_TOP_TYPE.CODE = byte (FUNCTION_DT) then do;
		if ^VALID_SPECIAL_FUNCTION () then
			goto ERROR_SET_MEMBER_DECLARATION;
	end;

	if (CURRENT_STORAGE_CLASS ^= STATIC_ST) &
	   (CURRENT_TOP_TYPE.CODE ^= byte (FUNCTION_DT)) then do;
		IS_CONST_MEMBER = CURRENT_TOP_TYPE.CONST;
		IS_REFERENCE_MEMBER = 
			(rank (CURRENT_TOP_TYPE.CODE) = REFERENCE_DT);
	end;
	else do;
		IS_CONST_MEMBER = FALSE;
		IS_REFERENCE_MEMBER = FALSE;
	end;

	/* Check a class/struct/union (object) type member */

	THIS_TAG = CHECK_TYPE_TAG_SYMBOL (CURRENT_TYPE);
	if THIS_TAG ^= NULL_NID then do;
		call SET_SYM_NODE_R (THIS_TAG);
		if CURRENT_STORAGE_CLASS ^= STATIC_ST then do;
			if SYM_NODE.HAS_CONST_MEMBER then
				IS_CONST_MEMBER = TRUE;
			if SYM_NODE.NEEDS_INIT then
				CURRENT_CLASS_PTR->
				SYM_NODE.NEEDS_INIT		= TRUE;
			if SYM_NODE.NEEDS_COPY then
				CURRENT_CLASS_PTR->
				SYM_NODE.NEEDS_COPY		= TRUE;
			if SYM_NODE.NEEDS_ASSIGN then
				CURRENT_CLASS_PTR->
				SYM_NODE.NEEDS_ASSIGN		= TRUE;
			if SYM_NODE.NEEDS_DESTRUCTION then
				CURRENT_CLASS_PTR->
				SYM_NODE.NEEDS_DESTRUCTION	= TRUE;
		end;
		if CURRENT_CLASS_TYPE = UNION_BT then do;
			if   SYM_NODE.NEEDS_INIT
			   | SYM_NODE.NEEDS_DESTRUCTION
			   | SYM_NODE.NEEDS_ASSIGN	then do;
				/*
				/* Error; an object of a class with a
				/* constructor, destructor, or assignment
				/* operator may not be a member of a union
				/* (C++ARM, 9.5).
				/**/
				call SEMANTIC_ERROR (ERR_OBJECT_UNION_MEMBER);
				goto ERROR_SET_MEMBER_DECLARATION;
			end;
		end;
	end;

	/* Set the appropriate symbol kind */

	THIS_KIND = MAP_MEMBER_KIND (CURRENT_CLASS_TYPE);

	if CURRENT_TOP_TYPE.CODE ^= byte (FUNCTION_DT) then do;
		if CURRENT_STORAGE_CLASS ^= STATIC_ST then
			THIS_KIND = THIS_KIND | NON_STATIC_DATA_MEMBER_SK;
		else	THIS_KIND = THIS_KIND | DATA_SK;
	end;
	else	THIS_KIND = THIS_KIND | MAP_FUNCTION_KIND (CURRENT_NAME_KIND);

	/* Check anonymous union members */

	if CURRENT_CLASS_PTR->SYM_NODE.IS_ANON_UNION_TAG then do;
		THIS_KIND = THIS_KIND | ANON_UNION_MEMBER_SK;
		if CURRENT_TOP_TYPE.CODE = byte (FUNCTION_DT) then do;
			/*
			/* Error; an anonymous union may
			/* not have function members.
			/**/
			call SEMANTIC_ERROR_I (ERR_ANON_UNION_FUN_MEMBER,
					       TOKEN_NAME (CURRENT_NAME));
		end;
		if CURRENT_MEMBER_ACCESS ^= PUBLIC_ACCESS then do;
			/*
			/* Error; an anonymous union may not
			/* have private or protected members.
			/**/
			call SEMANTIC_ERROR_I (ERR_PRIVY_ANON_UNION_MEMBER,
					       TOKEN_NAME (CURRENT_NAME));
			CURRENT_MEMBER_ACCESS = PUBLIC_ACCESS;
		end;
		if SEARCH_SCOPE (CURRENT_CLASS_PTR->SYM_NODE.ENCLOSING_SCOPE,
				 CURRENT_NAME,
				 VANILLA_SK) ^= NULL_NID then do;
			/*
			/* Error; this anonymous union member name has been
			/* previously declared in the scope containing the
			/* anonymous union as a non-type (types are handled
			/* later in INSTALL_SYMBOL).
			/**/
			call SEMANTIC_ERROR_II
			     (ERR_ANON_UNION_MEMBER_REDCL,
			      TOKEN_NAME (CURRENT_NAME),
			      SYMBOL_LOCATION_NAME ((CURRENT_NODE_ID)));
		end;
	end;

	/* See if this member symbol has been previously declared */

	PREV_SYMBOL = SEARCH_SCOPE (CURRENT_SCOPE, CURRENT_NAME, VANILLA_SK);

	/* Check for overloaded member functions or redeclaration error */

	if PREV_SYMBOL ^= NULL_NID then do;
		/*
		/* Here, this member name has previously
		/* declared; its sym-node is now paged in.
		/**/
		if CURRENT_TOP_TYPE.CODE ^= byte (FUNCTION_DT) then do;
			/*
			/* Error; this (non-function) member
			/* has been previously declared.
			/**/
			call SEMANTIC_ERROR_II
			     (ERR_REDEF_DATA_MEMBER,
			      QUALIFIED_SYMBOL_NAME (PREV_SYMBOL),
			      SYMBOL_LOCATION_NAME (PREV_SYMBOL));
			goto ERROR_SET_MEMBER_DECLARATION;
		end;
		else if SYM_NODE.TOP_TYPE.CODE ^= byte (FUNCTION_DT) then do;
			/*
			/* Error; this (function) member has been
			/* previously declared (as a non-function member).
			/**/
			call SEMANTIC_ERROR_II
			     (ERR_REDEF_MEMBER,
			      QUALIFIED_SYMBOL_NAME (PREV_SYMBOL),
			      SYMBOL_LOCATION_NAME (PREV_SYMBOL));
			goto ERROR_SET_MEMBER_DECLARATION;
		end;
		/*
		/* Here, this member function has been previously declared
		/* as a member function; see if it's correctly overloaded.
		/**/
		if CURRENT_STORAGE_CLASS = STATIC_ST then
			OCM = DEFAULT_OCM;
		else	OCM = TOP_QUALIFIERS_SIGNIFICANT_OCM;
		STATUS = CHECK_OVERLOAD
			 (PREV_SYMBOL, CURRENT_TYPE, NULL_NID, OCM);
		if STATUS ^= DISTINCT_TCS then do;
			/*
			/* Error; this member function declaration is
			/* not sufficiently different from previous
			/* member function declaration(s) (of the same
			/* name) to be overloaded.
			/**/
			call SEMANTIC_ERROR_II
			     (ERR_REDEF_FUN_MEMBER,
			      QUALIFIED_SYMBOL_NAME (PREV_SYMBOL),
			      SYMBOL_LOCATION_NAME (PREV_SYMBOL));
			goto ERROR_SET_MEMBER_DECLARATION;
		end;
	end;

	/* ---------------------------------
	/* Build a sym-node for this member.
	/* ------------------------------- */

	THIS_MEMBER = BUILD_SYMBOL (THIS_KIND);

	/*
	/* See if we have an overriding virtual function,
	/* and set the virtual function index/count if so.
	/**/

	if CURRENT_TOP_TYPE.CODE = byte (FUNCTION_DT) then
		call PROCESS_VIRTUAL_FUNCTION
		     ((CURRENT_NODE_ID), (NODE_PTR), CURRENT_CLASS_PTR);

	/*
	/* Install this member into the symbol table.
	/* If it is overloaded, then overload it, otherwise
	/* install it into the current (class) scope normally.
	/**/

	if PREV_SYMBOL ^= NULL_NID then
		call OVERLOAD_SYMBOL (PREV_SYMBOL, THIS_MEMBER);
	else	call INSTALL_SYMBOL (THIS_MEMBER, CURRENT_SCOPE);

	/* ------------------------------------------------------------
	/* Now, set other pertinent class/member data.
	/* This is done after installation because some of these items
	/* need to be, e.g. VALID_COPY_CONSTRUCTOR assumes the member
	/* enclosing-scope has been set (which is by installation).
	/* ---------------------------------------------------------- */

	/*
	/* If we have "const" (non-static data) member,
	/* then pass this up to each/every parent.
	/*
	/* If we have "const" (non-static data) member, or a member
	/* which needs initialization, special copy, special assignment,
	/* or destruction, then pass the const-ness up to each/every parent.
	/**/

	if IS_CONST_MEMBER then do;
		CURRENT_CLASS_PTR->SYM_NODE.HAS_CONST_MEMBER = TRUE;
		if SW_C_PLUS_PLUS & CURRENT_CLASS_TYPE ^= UNION_BT then
			CURRENT_CLASS_PTR->SYM_NODE.NEEDS_INIT = TRUE;
	end;

	if IS_REFERENCE_MEMBER & CURRENT_CLASS_TYPE ^= UNION_BT then
		CURRENT_CLASS_PTR->SYM_NODE.NEEDS_INIT = TRUE;

	/* 
	/* If the member is a non-static data member
	/* which is not public, record this for the parent.
	/**/

	if SYM_NODE.IS_NON_STATIC_DATA_MEMBER &
	   (SYM_NODE.ACCESS ^= byte (PUBLIC_ACCESS)) then
		CURRENT_CLASS_PTR->SYM_NODE.HAS_NON_PUBLIC_MEMBER = TRUE;

	/*
	/* Determine the linkage (C++ARM, 3.3, 7.1.1, 9.4):
	/*
	/* - static members have external linkage.
	/* - non-inline member functions have external linkage.
	/* - static member functions of a local class have no linkage.
	/*
	/* A class has external linkage iff it has at least one static
	/* member, OR it has been used in the declaration of at least
	/* one external linkage object, function, or class (?).
	/*
	/* Or conversly, a class has internal linkage iff it has no
	/* static members, AND it has not been used in the declaration
	/* of any external linkage objects, functions, or classes (?).
	/**/

	if CURRENT_INLINE then
		SYM_NODE.INTERNAL_LINKAGE = TRUE;

	else if ((CURRENT_STORAGE_CLASS = STATIC_ST) &
		 (CURRENT_FUNCTION_SCOPE = NULL_NID)) |
		(CURRENT_TOP_TYPE.CODE = byte (FUNCTION_DT)) then do;
		SYM_NODE.EXTERNAL_LINKAGE = TRUE;
		CURRENT_CLASS_PTR->SYM_NODE.EXTERNAL_LINKAGE = TRUE;
	end;

	/* Set the class constructor/destructor symbol if necessary */

	if CURRENT_NAME_KIND = CONSTRUCTOR_NK then do;
		if CURRENT_CLASS_PTR->SYM_NODE.CONSTRUCTOR = NULL_NID then do;
			CURRENT_CLASS_PTR->SYM_NODE.CONSTRUCTOR = THIS_MEMBER;
			CURRENT_CLASS_PTR->SYM_NODE.NEEDS_INIT = TRUE;
		end;
		if VALID_COPY_CONSTRUCTOR (THIS_MEMBER) then do;
			CURRENT_CLASS_PTR->
			SYM_NODE.NEEDS_COPY = TRUE;
			CURRENT_CLASS_PTR->
			SYM_NODE.COPY_CONSTRUCTOR = THIS_MEMBER;
		end;
		SYM_NODE.HAS_FLAG
			= CURRENT_CLASS_PTR->SYM_NODE.HAS_VIRTUAL_BASES;
	end;
	else if CURRENT_NAME_KIND = DESTRUCTOR_NK then do;
		if CURRENT_CLASS_PTR->SYM_NODE.DESTRUCTOR = NULL_NID then do;
			CURRENT_CLASS_PTR->SYM_NODE.DESTRUCTOR = THIS_MEMBER;
			CURRENT_CLASS_PTR->SYM_NODE.NEEDS_DESTRUCTION = TRUE;
		end;
		SYM_NODE.HAS_FLAG = TRUE;
	end;
	else if CURRENT_NAME_KIND = CONVERSION_NK then do;
		if CURRENT_CLASS_PTR->SYM_NODE.CONVERSION = NULL_NID then
			CURRENT_CLASS_PTR->SYM_NODE.CONVERSION = THIS_MEMBER;
	end;

	/* Make sure a member function of a local class is defined */

	if CURRENT_TOP_TYPE.CODE = byte (FUNCTION_DT) then do;
		if CURRENT_FUNCTION_SCOPE ^= NULL_NID then do;
			/*
			/* Here, we have a declaration of a member-function
			/* function within function definition (i.e. at
			/* local scope); in this case, the member-function
			/* *must* defined inline here.
			/**/
			if ^SYM_NODE.IS_DUMMY then do;
				if ^AT_FUNCTION_DEFINITION () then do;
					call SEMANTIC_ERROR_I
					     (ERR_LOCAL_MEMBER_FUN_UNDEF,
					      COMPLETE_QUALIFIED_SYMBOL_NAME
					      (THIS_MEMBER));
				end;
			end;
		end;
	end;

	/* Return with CURRENT_SYMBOL set to this symbol */

	CURRENT_SYMBOL = THIS_MEMBER;

	/* Done */

	DONE_SET_MEMBER_DECLARATION:
	CURRENT_PURE_SPECIFIER = FALSE;			/* reset */
	call RELEASE_SYM_NODE (CURRENT_CLASS);
	return;

	/* Error */

	ERROR_SET_MEMBER_DECLARATION:
	CURRENT_PURE_SPECIFIER = FALSE;			/* reset */
	call RELEASE_SYM_NODE (CURRENT_CLASS);
	CURRENT_SYMBOL = NULL_NID;
	return;

/* ---------------------------------------------------------------------
/* SET_BIT_FIELD_DECLARATION
/* ------------------------------------------------------------------- */

SET_BIT_FIELD_DECLARATION: procedure internal;

	declare
		THIS_KIND	type (LONG_BITS_T),
		THIS_MEMBER	type (NID_T),
		PREV_MEMBER	type (SHORT_T),
		REMAINING_BITS	type (SHORT_T);

	/*
	/* Build a type-node for this bit-field declaration from the current
	/* declaration data; sets CURRENT_TYPE & CURRENT_TOP_TYPE, and
	/* leaves the current declaration specifier and name data intact.
	/**/

	call BUILD_CURRENT_TYPE ();

	/* Process the declarator name for this bit-field declaration */

	/* TODO: put this in VALID_DECLARATOR_NAME */

	if CURRENT_NAME_KIND ^= VANILLA_NK then do;
		/*
		/* Error; a bit-field declaration must
		/* specify a plain old-fashioned vanilla name.
		/**/
		call SEMANTIC_ERROR (ERR_BIT_FIELD_NAME);
		CURRENT_NAME = NULL_NID;
	end;
	if CURRENT_NAME_SCOPE ^= NULL_NID then do;
		/*
		/* Error; a bit-field declaration must
		/* specify a plain old-fashioned vanilla name.
		/**/
		call SEMANTIC_ERROR (ERR_BIT_FIELD_NAME);
		call CLEAR_SCOPE_QUALIFIER ();
	end;

	/* Check the type of this bit-field */

	if ^VALID_BIT_FIELD_TYPE () then
		call SET_CURRENT_TYPE (GET_INT_TYPE ());

	/* Check that no invalid specifiers were used for this bit-field */

	if CURRENT_STORAGE_CLASS ^= NULL_ST then do;
		/*
		/* Error; a bit-field declaration may not
		/* specify any storage class specifiers; ignored.
		/**/
		call SEMANTIC_ERROR (ERR_STORAGE_BIT_FIELD);
		CURRENT_STORAGE_CLASS = NULL_ST;
	end;
	if CURRENT_FRIEND then do;
		/*
		/* Error; a bit-field declaration may not
		/* specify a friend specifier; ignored.
		/**/
		call SEMANTIC_ERROR (ERR_FRIEND_BIT_FIELD);
		CURRENT_FRIEND = FALSE;
	end;
	if CURRENT_INLINE | CURRENT_VIRTUAL then do;
		/*
		/* Error; a bit-field declaration may not
		/* specify any function specifiers; ignored.
		/**/
		call SEMANTIC_ERROR (ERR_FUN_BIT_FIELD);
		CURRENT_INLINE   = FALSE;
		CURRENT_VIRTUAL  = FALSE;
	end;

	if CURRENT_BIT_FIELD = 0 then do;
		if CURRENT_NAME ^= NULL_NID then do;
			/*
			/* Error; a zero-width bit-field must be unnamed.
			/**/
			call SEMANTIC_ERROR (ERR_ZERO_WIDTH_BIT_FIELD);
			CURRENT_NAME = NULL_NID;
		end;
	end;

	/* See if this bit-field symbol has been previously declared */

	if CURRENT_NAME ^= NULL_NID  then do;
		if SEARCH_SCOPE (CURRENT_SCOPE,
				 CURRENT_NAME,
				 VANILLA_SK) ^= NULL_NID then do;
			/*
			/* Error; a member with this name
			/* has already been declared.
			/**/
			call SEMANTIC_ERROR_I (ERR_DUP_BIT_FIELD_MEMBER,
					       QUALIFIED_SYMBOL_NAME
					       ((CURRENT_NODE_ID)));
			goto ERROR_SET_BIT_FIELD_DECLARATION;
		end;
	end;

	/* Set the appropriate symbol kind */

	THIS_KIND = MAP_MEMBER_KIND (CURRENT_CLASS_TYPE) | BIT_FIELD_SK;

	call SET_SYM_NODE_R (CURRENT_CLASS);

	if SYM_NODE.IS_ANON_UNION_TAG then
		THIS_KIND = THIS_KIND | ANON_UNION_MEMBER_SK;

	/* Ok, make a symbol node for this bit-field member */

	THIS_MEMBER = BUILD_SYMBOL (THIS_KIND);

	/* Link this bit-field symbol into the tag current scope */

	call INSTALL_SYMBOL (THIS_MEMBER, CURRENT_SCOPE);

	/* Return with CURRENT_SYMBOL set to this symbol */

	CURRENT_SYMBOL = THIS_MEMBER;

	/* Done; reset */

	CURRENT_BIT_FIELD = -1;
	CURRENT_NAME = NULL_NID;   /* Handle: struct A { int a : 1, : 2; }; */
	return;

	/* Error; reset */

	ERROR_SET_BIT_FIELD_DECLARATION:
	CURRENT_BIT_FIELD = -1;
	CURRENT_NAME = NULL_NID;
	CURRENT_SYMBOL = NULL_NID;
	return;

/* ---------------------------------------------------------------------
/* VALID_BIT_FIELD_TYPE
/*
/* If the current top-type is not a valid type for a bit-field, then
/* emit an appropriate diagnostic message and return FALSE, otherwise
/* return TRUE.
/* ------------------------------------------------------------------- */

VALID_BIT_FIELD_TYPE: procedure returns (type (BOOL_T)) internal;

	/* Warn for an unspecified base type */

	if CURRENT_BASE_TYPE_UNSPECIFIED then
		call CHECK_UNSPECIFIED_BASE_TYPE ();

	if IS_DERIVED_TYPE (rank (CURRENT_TOP_TYPE.CODE)) then do;
		/*
		/* Error; this bit-field is a derived type!
		/**/
		call SEMANTIC_ERROR (ERR_BAD_BIT_FIELD);
		return (FALSE);
	end;
	else if ^IS_INTEGRAL_TYPE (rank (CURRENT_TOP_TYPE.CODE)) then do;
		/*
		/* Error; this bit-field is not an integral type.
		/**/
		call SEMANTIC_ERROR (ERR_BIT_FIELD_TYPE);
		return (FALSE);
	end;
	else if SW_X_BIT_FIELDS then do;
		if ^IS_INT_TYPE (rank (CURRENT_TOP_TYPE.CODE)) |
		   (CURRENT_TOP_TYPE.CODE = byte (ENUM_BT)) then do;
			/*
			/* Warning; this bit-field is not an "int" type.
			/**/
			call SEMANTIC_ERROR (ERR_BIT_FIELD_TYPE_WARN);
		end;
	end;
	return (TRUE);

end VALID_BIT_FIELD_TYPE;

end SET_BIT_FIELD_DECLARATION;

/* ---------------------------------------------------------------------
/* HAVE_MEMBER_ACCESS_DECLARATION
/* ------------------------------------------------------------------- */

HAVE_MEMBER_ACCESS_DECLARATION: procedure returns (type (BOOL_T));

	if (CURRENT_NAME ^= NULL_NID) &
	   (CURRENT_NAME_SCOPE ^= NULL_NID) &
	    CURRENT_BASE_TYPE_UNSPECIFIED &
	   (CURRENT_BASE_TYPE_QUALIFIER = NULL_TQ) &
	   (CURRENT_STORAGE_CLASS = NULL_ST) &
	   ^CURRENT_FRIEND &
	   ^CURRENT_VIRTUAL &
	   ^CURRENT_INLINE &
	   ^CURRENT_OVERLOAD &
	   (CURRENT_DERIVED_TYPE_LEVEL <= 0) &
	   (CURRENT_BIT_FIELD < 0) then
		return (TRUE);
	else	return (FALSE);

end HAVE_MEMBER_ACCESS_DECLARATION;

/* ---------------------------------------------------------------------
/* SET_MEMBER_ACCESS_DECLARATION
/*
/* Determine if the current member declaration is a member access
/* (adjustment) declaration, if so then process it.
/* Trashes current-node-id.
/* ------------------------------------------------------------------- */

SET_MEMBER_ACCESS_DECLARATION: procedure internal;

	declare
		P		type (POINTER_T),
		KIND		type (LONG_BITS_T),
		MEMBER		type (NID_T),
		BASE_CLASS	type (NID_T),
		BASE_MEMBER	type (NID_T),
		AMBIGUOUS	type (BOOL_T),
		THIS_ACCESS	type (SHORT_T),
		(THIS, NEXT)	type (NID_T);

	if CURRENT_NAME_KIND = CONVERSION_NK then	/* hackish */
		call BUILD_CURRENT_CONVERSION_TYPE ();

	if ^VALID_DECLARATOR_NAME (MEMBER_ACCESS_DCL) then
		return;

	if ^CURRENT_CLASS_DERIVED then do;
		/*
		/* Error; member access adjustment declarations
		/* may be used only in a derived class definition.
		/**/
		call SEMANTIC_ERROR (ERR_DERIVED_ACCESS_DCL);
		return;
	end;
	else if CURRENT_MEMBER_ACCESS = PRIVATE_ACCESS then do;
		/*
		/* Error; member access adjustment declarations are
		/* only allowed within "public" or "protected" sections.
		/**/
		call SEMANTIC_ERROR (ERR_ACCESS_DCL);
		return;
	end;
	else if ^IS_ANY_BASE_CLASS_OF
		 (CURRENT_NAME_SCOPE_SYMBOL, CURRENT_CLASS) then do;
		/*
		/* Error; the base class qualifier is not
		/* a base class of this enclosing class.
		/**/
		call SEMANTIC_ERROR_II
		     (ERR_NOT_BASE_CLASS_OF,
		      SYMBOL_NAME (CURRENT_NAME_SCOPE_SYMBOL),
		      SYMBOL_NAME (CURRENT_CLASS));
		return;
	end;

	if CURRENT_NAME_KIND = CONVERSION_NK then
		KIND = CONVERSION_FUNCTION_SK;
	else	KIND = ANY_SK;

	MEMBER = SEARCH_CLASS (CURRENT_NAME_SCOPE_SYMBOL, CURRENT_NAME, KIND);

	if MEMBER = NULL_NID then do;
		/*
		/* Error; this qualified name is not
		/* a member of the class qualifier.
		/**/
		call UNDECLARED_MEMBER_ERROR ();
		return;
	end;

	/*
	/* Make sure the name to be adjusted is not also the
	/* name of a member in this class (C++ARM, 11.3).
	/**/

	if SEARCH_SCOPE (CURRENT_CLASS, CURRENT_NAME, KIND) ^= NULL_NID then do;
		/*
		/* Error; access to a base class member may not be adjusted
		/* in a derived class also defines a member of that name.
		/**/
		call SEMANTIC_ERROR (ERR_ACCESS_DERIVED);
	end;

	do THIS = MEMBER repeat NEXT while (THIS ^= NULL_NID);
		/*
		/* Access declaration may not change the access to be different
		/* from the effective access which the member has in the
		/* present class.  Since one access declaration covers all
		/* overloaded variants, they must all be checked.
		/**/
		call GET_SYM_NODE_R (THIS, P);
		THIS_ACCESS = EFFECTIVE_ACCESS
			      (THIS,
			       P->SYM_NODE.ENCLOSING_SCOPE_OWNER,
			       CURRENT_NAME_SCOPE_SYMBOL,
			       rank (P->SYM_NODE.ACCESS));
		if P->SYM_NODE.IS_FUNCTION then
			NEXT = P->SYM_NODE.NEXT_OVERLOAD;
		else	NEXT = NULL_NID;
		call RELEASE_SYM_NODE (THIS);
		if CURRENT_MEMBER_ACCESS < THIS_ACCESS then do;
			/*
			/* Error; attempt to enable
			/* access beyond what is available.
			/**/
			call SEMANTIC_ERROR_I (ERR_ACCESS_ENABLE,
					       FULL_SYMBOL_NAME (THIS));
		end;
		else if CURRENT_MEMBER_ACCESS > THIS_ACCESS then do;
			/*
			/* Error; attempt to restrict access further
			/* than what the user can get by permitted
			/* pointer conversions.
			/**/
			call SEMANTIC_ERROR_I (ERR_ACCESS_RESTRICTION,
					       FULL_SYMBOL_NAME (THIS));
		end;
	end;

	/* Adjust the access rights */

	call NEW_BASE_MEMBER_NODE (BASE_MEMBER, P);
	P->BASE_MEMBER_NODE.ACCESS = byte (CURRENT_MEMBER_ACCESS);
	P->BASE_MEMBER_NODE.CLASS  = CURRENT_NAME_SCOPE_SYMBOL;
	P->BASE_MEMBER_NODE.MEMBER = MEMBER;

	call SET_SYM_NODE (CURRENT_CLASS);

	P->BASE_MEMBER_NODE.NEXT = SYM_NODE.BASE_MEMBERS;
	SYM_NODE.BASE_MEMBERS    = BASE_MEMBER;

	call RELEASE_BASE_MEMBER_NODE (BASE_MEMBER);

end SET_MEMBER_ACCESS_DECLARATION;

/* ---------------------------------------------------------------------
/* SET_FRIEND_DECLARATION
/* ------------------------------------------------------------------- */

SET_FRIEND_DECLARATION: procedure internal;

	declare
		THIS_KIND	type (LONG_BITS_T),
		THIS_SCOPE	type (NID_T),
		THIS_FRIEND	type (NID_T),
		PREV_SYMBOL	type (NID_T),
		OCM		type (OCM_T),
		P		type (POINTER_T);

	/*
	/* Build a type-node for this friend declaration from the current
	/* declaration data; sets CURRENT_TYPE & CURRENT_TOP_TYPE, and
	/* leaves the current declaration specifier and name data intact.
	/**/

	call BUILD_CURRENT_FRIEND_TYPE ();
	if ^AT_FUNCTION_DEFINITION () then
		call FREE_CURRENT_PROTOTYPE_SCOPE ();

	/* Process the declarator name for this friend declaration */

	if ^VALID_DECLARATOR_NAME (FRIEND_DCL) then
		goto ERROR_SET_FRIEND_DECLARATION;

	/* Perform various sanity checks on the base type */

	if ^VALID_BASE_TYPE () then
		goto ERROR_SET_FRIEND_DECLARATION;

	/* Check that no storage class was specified for this friend */

	if CURRENT_STORAGE_CLASS ^= NULL_ST then do;
		/*
		/* Error; a friend declaration may not specify
		/* any storage class specifiers; ignored.
		/**/
		call SEMANTIC_ERROR (ERR_FRIEND_STORAGE);
		CURRENT_STORAGE_CLASS = NULL_ST;
	end;
	if CURRENT_BIT_FIELD >= 0 then do;
		/*
		/* Error; a friend declaration may not
		/* be specified as a bit-field; ignored.
		/**/
		call SEMANTIC_ERROR (ERR_FRIEND_BIT_FIELD);
	end;
	if CURRENT_VIRTUAL then do;
		/*
		/* Error; the "virtual" specifier may only only be used
		/* in a class definition for a member function declaration.
		/**/
		call SEMANTIC_ERROR (ERR_BAD_VIRTUAL);
		CURRENT_VIRTUAL = FALSE;
	end;

	/* Check special functions */

	if CURRENT_NAME_KIND = OPERATOR_NK then do;
		if ^VALID_SPECIAL_FUNCTION () then
			goto ERROR_SET_FRIEND_DECLARATION;
	end;

	if (CURRENT_TOP_TYPE.CODE ^= byte (FUNCTION_DT)) &
	   (^IS_AGGREGATE_TAG_TYPE (rank (CURRENT_TOP_TYPE.CODE)) |
	    (CURRENT_NAME ^= NULL_NID)) then do;
		/*
		/* Error; only function or class (not object)
		/* types may be declared as friends.
		/**/
		call SEMANTIC_ERROR (ERR_FRIEND_TYPE);
		goto ERROR_SET_FRIEND_DECLARATION;
	end;

	/*
	/* See if we're befriending a class type; this is easy
	/* since we already looked the class name as a part of
	/* the type-specifiers.
	/**/

	if CURRENT_TOP_TYPE.CODE ^= byte (FUNCTION_DT) then do;
		call GET_SYM_NODE_R (CURRENT_TOP_TYPE.TAG_SYMBOL, P);
		if P->SYM_NODE.NAME = NULL_NID then do;
			call SEMANTIC_ERROR (ERR_FRIEND_TYPE);
			call RELEASE_SYM_NODE (CURRENT_TOP_TYPE.TAG_SYMBOL);
			goto ERROR_SET_FRIEND_DECLARATION;
		end;
		call RELEASE_SYM_NODE (CURRENT_TOP_TYPE.TAG_SYMBOL);
		THIS_FRIEND = CURRENT_TOP_TYPE.TAG_SYMBOL;
		goto BEFRIEND_THIS_FRIEND;
	end;

	/*
	/* Here, we are befriending a function (not a class).
	/* Determine the scope in which to *look* for the friend.
	/**/

	if CURRENT_NAME_SCOPE = NULL_NID then do;
		call SET_SYM_NODE_R (CURRENT_CLASS);
		THIS_SCOPE = SYM_NODE.ENCLOSING_SCOPE;
	end;
	else if CURRENT_NAME_SCOPE = CURRENT_GLOBAL_SCOPE then do;
		THIS_SCOPE = CURRENT_GLOBAL_SCOPE;
	end;
	else do;
		THIS_FRIEND = SEARCH_CLASS (CURRENT_NAME_SCOPE_SYMBOL,
					    CURRENT_NAME,
					    ANY_SK);
		if THIS_FRIEND = NULL_NID then do;
			/*
			/* Error; this qualified name is
			/* not a member of the named class.
			/**/
			call UNDECLARED_MEMBER_ERROR ();
			goto ERROR_SET_FRIEND_DECLARATION;
		end;
		else if SYM_NODE.IS_TYPE then do;
			call SEMANTIC_ERROR_II
			     (ERR_TYPE_NON_TYPE_REDCL,
			      FULL_QUALIFIED_SYMBOL_NAME (THIS_FRIEND),
			      SYMBOL_LOCATION_NAME (THIS_FRIEND));
			goto ERROR_SET_FRIEND_DECLARATION;
		end;
		THIS_FRIEND = MATCH_OVERLOAD (THIS_FRIEND, CURRENT_TYPE);
		if THIS_FRIEND = NULL_NID then do;
			call UNDECLARED_MEMBER_ERROR ();
			goto ERROR_SET_FRIEND_DECLARATION;
		end;
		goto BEFRIEND_THIS_FRIEND;
	end;

	/* See if this symbol has been previously declared */

	PREV_SYMBOL = LOOKUP_NAME_QUIETLY (CURRENT_NAME, ANY_SK, THIS_SCOPE);

	if PREV_SYMBOL = NULL_NID then do;
		/*
		/* There is no previous visible declaration
		/* of this (non-member) name; declare it.
		/**/
		goto MAKE_AND_INSTALL_THIS_FRIEND;
	end;
	else if ^SYM_NODE.IS_FUNCTION then do;
		if SYM_NODE.IS_TYPE then do;
			if SYM_NODE.CONSTRUCTOR ^= NULL_NID then do;
				call SEMANTIC_ERROR_II
				     (ERR_TAG_NON_TYPE_REDCL,
				      QUALIFIED_SYMBOL_NAME (PREV_SYMBOL),
				      SYMBOL_LOCATION_NAME (PREV_SYMBOL));
				goto ERROR_SET_FRIEND_DECLARATION;
			end;
			else	PREV_SYMBOL = NULL_NID;
		end;
		else do;
			/*
			/* Error; this member function declaration is
			/* neither compatible with, nor sufficiently
			/* distinct from, a previous function
			/* declaration of the same name.
			/**/
			call SEMANTIC_ERROR_II
			     (ERR_REDCL_FUN,
			      FULL_QUALIFIED_SYMBOL_NAME (PREV_SYMBOL),
			      SYMBOL_LOCATION_NAME (PREV_SYMBOL));
			goto ERROR_SET_FRIEND_DECLARATION;
		end;
	end;

	OCM = TOP_QUALIFIERS_SIGNIFICANT_OCM;

	/*
	/* If the current declaration is a function with no explicit
	/* linkage specifier, then only look at previous declarations
	/* of this name which are either prototyped and/or defined;
	/* i.e. do not look at function declarations which are both
	/* non-prototyped ("C" linkage, obviously) and undefined;
	/* note that this same sort of check needs to be done in
	/* CHECK_OVERLOAD.
	/**/

	if CURRENT_LINKAGE_KIND = DEFAULT_LINKAGE then do;
		if (^SYM_NODE.PROTOTYPED) &
		   (^SYM_NODE.DEFINED) &
		   (SYM_NODE.LINKAGE_KIND = byte (C_LINKAGE)) &
		   (SYM_NODE.NEXT_OVERLOAD = NULL_NID) then
			goto MAKE_AND_INSTALL_THIS_FRIEND;
		else	OCM = OCM | NO_OLD_STYLE_UNDEFINED_OCM;
	end;

	/*
	/* If the current declaration is a function with "C" linkage
	/* and is not prototyped and is not a definition, then only
	/* look at a previous "C" linkage declaration (if any);
	/* i.e.  do not look at function declarations which are
	/* "C++" linkage (prototyped (obviously)) or defined.
	/**/

	else if (CURRENT_LINKAGE_KIND = C_LINKAGE) &
		(^CURRENT_OLD_FUNCTION_DEFINITION) then do;
		call GET_SIG_NODE_R (CURRENT_TOP_TYPE.SIGNATURE, P);
		if ^P->SIG_NODE.PROTOTYPED then do;
			if SYM_NODE.LINKAGE_KIND ^= byte (C_LINKAGE) then do;
				if SYM_NODE.C_OVERLOAD ^= NULL_NID then do;
					PREV_SYMBOL = SYM_NODE.C_OVERLOAD;
					call SET_SYM_NODE (PREV_SYMBOL);
				end;
				else	goto MAKE_AND_INSTALL_THIS_FRIEND;
			end;
			else	OCM = OCM | ONLY_C_LINKAGE_OCM;
		end;
		call RELEASE_SIG_NODE (CURRENT_TOP_TYPE.SIGNATURE);
	end;

	STATUS = CHECK_OVERLOAD (PREV_SYMBOL, CURRENT_TYPE, THIS_FRIEND, OCM);

	if STATUS = COMPATIBLE_TCS then
		goto BEFRIEND_THIS_FRIEND;

	else if STATUS ^= DISTINCT_TCS then do;
		/*
		/* Error; this member function declaration is
		/* neither compatible with, nor sufficiently
		/* distinct from (for overloading), a previous
		/* function declaration of the same name.
		/**/
		call SEMANTIC_ERROR_II
		     (ERR_REDCL_FUN,
		      FULL_QUALIFIED_SYMBOL_NAME (PREV_SYMBOL),
		      SYMBOL_LOCATION_NAME (PREV_SYMBOL));
		goto ERROR_SET_FRIEND_DECLARATION;
	end;

	MAKE_AND_INSTALL_THIS_FRIEND:

	/*
	/* If this function has not yet been declared, then declare it.
	/*
	/* Hmm, the C++ARM (11.4 - page 234) says that a friend is
	/* scoped at the scope of the containing class, but what about
	/* nested classes?  That would imply that a member function of
	/* an enclosing class can be declared in a nested class, which
	/* seems strange.  However, in sec.9.7, page 177, there is an
	/* example which indicates that friends are always scoped at
	/* global scope; I like this better; also see sec.7.1.1, page 95.
	/*
	/* See SET_TAG_NAME for the same problem in befriending classes.
	/**/

	THIS_SCOPE = CURRENT_GLOBAL_OR_LOCAL_SCOPE;

	/* Determine the kind of function symbol */

	THIS_KIND = MAP_FUNCTION_KIND (CURRENT_NAME_KIND);

	/* Build a function sym-node */

	THIS_FRIEND = BUILD_SYMBOL (THIS_KIND);

	/* Fill in the rest of this sym-node */

	call GET_SIG_NODE (SYM_NODE.TOP_TYPE.SIGNATURE, P);
	SYM_NODE.PROTOTYPED = P->SIG_NODE.PROTOTYPED;
	call RELEASE_SIG_NODE (SYM_NODE.TOP_TYPE.SIGNATURE);

	if CURRENT_INLINE then
		SYM_NODE.INTERNAL_LINKAGE = TRUE;
	else	SYM_NODE.EXTERNAL_LINKAGE = TRUE;

	/* Install this symbol */

	if PREV_SYMBOL ^= NULL_NID then
		call OVERLOAD_SYMBOL (PREV_SYMBOL, THIS_FRIEND);
	else	call INSTALL_SYMBOL (THIS_FRIEND, THIS_SCOPE);

	/* Ok, try to befriend this class or function */

	BEFRIEND_THIS_FRIEND:

	/* See if this symbol has been previously befriended by this class */

	if IS_FRIEND_OF (THIS_FRIEND, CURRENT_CLASS) then do;
		if SW_LINT then do;
			/*
			/* Warning; this symbol was already
			/* declared to be a friend of this class.
			/**/
			call SEMANTIC_ERROR_II
			     (ERR_DUP_FRIEND,
			      QUALIFIED_SYMBOL_NAME (CURRENT_CLASS),
			      FULL_QUALIFIED_SYMBOL_NAME (THIS_FRIEND));
		end;
		goto DONE_SET_FRIEND_DECLARATION;
	end;

	/* Ok, all's well, befriend this symbol */

	call BEFRIEND_SYMBOL (CURRENT_CLASS, THIS_FRIEND);

	/* Return with CURRENT_SYMBOL set to this symbol */

	DONE_SET_FRIEND_DECLARATION:
	CURRENT_SYMBOL = THIS_FRIEND;
	return;

	/* Error */

	ERROR_SET_FRIEND_DECLARATION:
	CURRENT_SYMBOL = NULL_NID;
	return;

end SET_FRIEND_DECLARATION;

end SET_MEMBER_DECLARATION;

/* ---------------------------------------------------------------------
/* END_CLASS_BODY
/* ------------------------------------------------------------------- */

END_CLASS_BODY: procedure external (X_END_CLASS_BODY);

	declare
		THIS_CLASS		type (NID_T),
		THIS_CLASS_PTR		type (POINTER_T),
		THIS_MEMBERS		type (NID_T),
		(FB, NEXT_FB)		type (NID_T),
		DO_DEFAULT_CTOR		type (BOOL_T),
		IS_NOT_AGGREGATE	type (BOOL_T),
		EXPLICIT_CONSTRUCTOR	type (NID_T),
		EXPLICIT_DESTRUCTOR	type (NID_T),
		P			type (POINTER_T);

	if ^SW_C_PLUS_PLUS then do;
		call END_CLASS_BODY_FOR_C ();
		return;
	end;

	THIS_CLASS = CURRENT_CLASS;
	call GET_SYM_NODE (THIS_CLASS, THIS_CLASS_PTR);

	EXPLICIT_CONSTRUCTOR = THIS_CLASS_PTR->SYM_NODE.CONSTRUCTOR;
	EXPLICIT_DESTRUCTOR = THIS_CLASS_PTR->SYM_NODE.DESTRUCTOR;

	/*
	/* Moved this to after the possible implicit generation of
	/* a default destructor or an assignment operator so that the
	/* virtual function table and pointer (if any) will be set up
	/* appropriately in the case that one of these implicitly
	/* generated functions will override a corresponding virtual
	/* in a (virtual) base class.  This fixed the following:
	/*
	/*   struct V { virtual ~V () ; };
	/*   class A : virtual public V { A (); };
	/*   A :: A () { }
	/*
	/* which caused an internal compiler error in SET_VFT_POINTERS.
	/*
	/* call FINISH_CLASS_SIZE (THIS_CLASS);
	/* THIS_CLASS_PTR->SYM_NODE.DEFINED = TRUE;
	/**/

	/*
	/* Determine whether aggregate style initialization (with {})
	/* is to be allowed.
	/**/

	THIS_CLASS_PTR->SYM_NODE.PERMITS_AGGREGATE_INIT =
		  (EXPLICIT_CONSTRUCTOR = NULL_NID) &
		  ^THIS_CLASS_PTR->SYM_NODE.HAS_NON_PUBLIC_MEMBER &
		  (THIS_CLASS_PTR->SYM_NODE.NBASE_CLASSES = 0) &
		  (THIS_CLASS_PTR->SYM_NODE.VIRTUAL_FUNCTION_COUNT = 0);

	/*
	/* See if we need to implicitly declare a default constructor.
	/* Do this in the class's scope for proper access to base classes.
	/**/

	DO_DEFAULT_CTOR = FALSE;
	if THIS_CLASS_PTR->SYM_NODE.NEEDS_INIT &
	   (EXPLICIT_CONSTRUCTOR = NULL_NID) then do;
		if DEFAULT_CONSTRUCTOR_OK (THIS_CLASS, FALSE, TRUE) then
			DO_DEFAULT_CTOR = TRUE;
	end;

	/*
	/* See if we need to implicitly declare a default destructor.
	/* Do this in the class's scope for proper access to base
	/* classes.  Declare a default destructor if appropriate.
	/**/

	if THIS_CLASS_PTR->SYM_NODE.NEEDS_DESTRUCTION then
		call DECLARE_DEFAULT_DESTRUCTOR (THIS_CLASS_PTR);

	/* Declare a default constructor if appropriate */

	if DO_DEFAULT_CTOR then
		call DECLARE_DEFAULT_CONSTRUCTOR (THIS_CLASS_PTR);

	/* See if we need to implicitly declare a copy constructor */

	if THIS_CLASS_PTR->SYM_NODE.NEEDS_INIT then
		call DECLARE_COPY_CONSTRUCTOR (THIS_CLASS_PTR);

	/*
	/* See if we need to implicitly declare an assign operator.
	/* Don't declare it for an ordinary class in C mode, because
	/* value of assignment must not be an lvalue.
	/**/
 
	if ^THIS_CLASS_PTR->SYM_NODE.IS_ENUM_TAG &
	   ^THIS_CLASS_PTR->SYM_NODE.IS_ANON_UNION_TAG then
		call DECLARE_ASSIGNMENT_OPERATOR (THIS_CLASS);

	/*
	/* Declare a function to help initialize
	/* arrays of this class, if necessary.
	/**/

	if NEEDS_ARRAY_CONSTRUCTOR (THIS_CLASS) then
		call DECLARE_ARRAY_CONSTRUCTOR (THIS_CLASS_PTR);

	/* Inherite any pure virtual functions */

	call INHERITE_VIRTUAL_FUNCTIONS (THIS_CLASS_PTR);

	/* Set the final class size (allocates any virtual base classes) */

	call FINISH_CLASS_SIZE (THIS_CLASS);		/* 100 */

	THIS_CLASS_PTR->SYM_NODE.DEFINED = TRUE;	/* 100 */

	/* Now, parse each function which was defined within this class */

	if SW_DEFER_FUNCTIONS then do;
		if THIS_CLASS_PTR->
		   SYM_NODE.SAVED_FUNCTION_BODIES ^= NULL_NID then
			call NOTE_DEFERRED_MEMBER_FUNCTIONS
			     (THIS_CLASS, THIS_CLASS_PTR);
	end;
	else do FB = THIS_CLASS_PTR->SYM_NODE.SAVED_FUNCTION_BODIES
		     repeat (NEXT_FB) while (FB ^= NULL_NID);
		call SET_SYM_NODE (FB);
		NEXT_FB = SYM_NODE.SAVED_FUNCTION_BODY.NEXT;
		call CLEAR_DECLARATION ();
		CURRENT_SYMBOL = FB;
		call PARSE_FUNCTION_BODY
			(SYM_NODE.SAVED_FUNCTION_BODY.FIRST_TOKEN,
			 SYM_NODE.SAVED_FUNCTION_BODY.LAST_TOKEN,
			 SYM_NODE.SAVED_FUNCTION_BODY.SOURCE_STATE);
	end;

	/* Terminate this class scope */

	call END_CLASS_SCOPE ();

	/*
	/* See if this class name has been previously declared as a
	/* non-type; it's ok if it has (C++ *does* actually maintain
	/* a separate name space for type names and non-type names)
	/* *except* if this class/struct/union has a constructor!
	/**/

	if EXPLICIT_CONSTRUCTOR ^= NULL_NID then do;
		if SEARCH_SCOPE (CURRENT_SCOPE,
				 THIS_CLASS_PTR->SYM_NODE.NAME,
				 VANILLA_SK) ^= NULL_NID then do;
			/*
			/* Error; the name of this class (which has a
			/* constructor) was previously declared as a non-type.
			/**/
			call SEMANTIC_ERROR_II
			     (ERR_NON_TYPE_TYPE_REDCL,
			      QUALIFIED_SYMBOL_NAME (THIS_CLASS),
			      SYMBOL_LOCATION_NAME (THIS_CLASS));
		end;
	end;
	else do;
		if (EXPLICIT_DESTRUCTOR ^= NULL_NID) &
		   ^THIS_CLASS_PTR->SYM_NODE.ABSTRACT then do;
			/*
			/* Note; this class defined an explicit
			/* destructor but no explicit constructor.
			/**/
			call SEMANTIC_ERROR_I
			     (ERR_DTOR_BUT_NO_CTOR,
			      QUALIFIED_SYMBOL_NAME (THIS_CLASS));
		end;
		if  THIS_CLASS_PTR->SYM_NODE.NEEDS_INIT &
		   ^THIS_CLASS_PTR->SYM_NODE.PERMITS_AGGREGATE_INIT then do;
			if (EXPLICIT_CONSTRUCTOR = NULL_NID) &
			   ^DO_DEFAULT_CTOR then do;
				/* 
				/* Error; this class needs a declared
				/* constructor because one of its bases
				/* or members has no default constructor.
				/* The class may have a generated copy
				/* constructor, but what object could it copy?
				/**/
				call SEMANTIC_ERROR_I
				     (ERR_UNCONSTRUCTIBLE,
				      QUALIFIED_SYMBOL_NAME (THIS_CLASS));
			end;
		end;
	end;

	/* Special handling for anonymous unions */

	if THIS_CLASS_PTR->SYM_NODE.IS_ANON_UNION_TAG then
		call INSTALL_ANONYMOUS_UNION (THIS_CLASS_PTR);

	/* Warn if nested types have not been defined. */

	call CHECK_NESTED_TYPES (THIS_CLASS_PTR);

	/* Release this class sym-node */

	call RELEASE_SYM_NODE (THIS_CLASS);

	/* Restore the previous declaration state */

	call RESTORE_DECLARATION_STATE ();

	/* Restore the previous class definition state (if any) */

	call RESTORE_CLASS_STATE ();

	if CURRENT_CLASS_SCOPE = NULL_NID then
		CURRENT_CLASS = NULL_NID;

/* ---------------------------------------------------------------------
/* END_CLASS_BODY_FOR_C
/* ------------------------------------------------------------------- */

END_CLASS_BODY_FOR_C: procedure;

	THIS_CLASS = CURRENT_CLASS;

	call FINISH_CLASS_SIZE (THIS_CLASS);

	call GET_SYM_NODE (THIS_CLASS, THIS_CLASS_PTR);

	THIS_CLASS_PTR->SYM_NODE.PERMITS_AGGREGATE_INIT = TRUE;
	THIS_CLASS_PTR->SYM_NODE.DEFINED = TRUE;

	call GET_SCOPE_NODE_R (THIS_CLASS_PTR->SYM_NODE.DEFINED_SCOPE, P);
	if P->SCOPE_NODE.NSYMBOLS = 0 then do;
		if THIS_CLASS_PTR->SYM_NODE.IS_ENUM_TAG then
			call SEMANTIC_ERROR (ERR_EMPTY_ENUM);
		else	call SEMANTIC_ERROR (ERR_EMPTY_STRUCT);
	end;
	call RELEASE_SCOPE_NODE (THIS_CLASS_PTR->SYM_NODE.DEFINED_SCOPE);

	call END_CLASS_SCOPE ();

	call RELEASE_SYM_NODE (THIS_CLASS);

	call RESTORE_DECLARATION_STATE ();

	call RESTORE_CLASS_STATE ();

	if CURRENT_CLASS_SCOPE = NULL_NID then
		CURRENT_CLASS = NULL_NID;

end END_CLASS_BODY_FOR_C;

end END_CLASS_BODY;

/* ---------------------------------------------------------------------
/* SET_CLASS_DECLARATION
/* ------------------------------------------------------------------- */

SET_CLASS_DECLARATION: procedure external (X_SET_CLASS_DECLARATION);

	;

end SET_CLASS_DECLARATION;

/* ---------------------------------------------------------------------
/* BEGIN_ENUM_DECLARATION
/* ------------------------------------------------------------------- */

BEGIN_ENUM_DECLARATION: procedure external (X_BEGIN_ENUM_DECLARATION);

	call BEGIN_CLASS_DECLARATION ();

	CURRENT_BASE_TYPE = NULL_BT;

end BEGIN_ENUM_DECLARATION;

/* ---------------------------------------------------------------------
/* SET_ENUM_BASE_TYPE
/* ------------------------------------------------------------------- */

SET_ENUM_BASE_TYPE: procedure external  (X_SET_ENUM_BASE_TYPE);

	if CURRENT_BASE_TYPE ^= NULL_BT then do;
		/*
		/* Here we have "enum <elementary-type-specifier>"
		/* which is an LPI-C++ extension.
		/**/
		if ^SW_ALLOW_ENUM_INTEGRAL_TYPE then
			call SEMANTIC_ERROR (ERR_NO_ENUM_INTEGRAL_TYPE);
		if ^IS_INTEGRAL_TYPE (CURRENT_BASE_TYPE) then do;
			/*
			/* Error; an *integral* type (if any) must
			/* be specified after "enum" -- this is
			/* an LPI-C++ extension.
			/**/
			call SEMANTIC_ERROR (ERR_ENUM_BASE_TYPE);
			CURRENT_ENUM_BASE_TYPE = INT_BT;
		end;
		else	CURRENT_ENUM_BASE_TYPE = CURRENT_BASE_TYPE;
		CURRENT_ENUM_NO_BASE_TYPE = FALSE;
	end;
	else do;
		CURRENT_ENUM_NO_BASE_TYPE	= TRUE;
		CURRENT_ENUM_BASE_TYPE		= INT_BT;
	end;

	CURRENT_BASE_TYPE		= ENUM_BT;
	CURRENT_BASE_TYPE_UNSPECIFIED	= FALSE;

end SET_ENUM_BASE_TYPE;

/* ---------------------------------------------------------------------
/* BEGIN_ENUM_BODY
/*
/* Set up to process an enumerator list.  We treat enumeration definitions
/* very much like class definitions; set up a class (enum) scope, *but*
/* enumerators (i.e. enum members) are installed in this scope using
/* INSTALL_ENUMERATOR_SYMBOL rather than INSTALL_SYMBOL so that the the
/* FATHER field of the enumerator symbol is set to the enclosing scope
/* of the enum tag rather than the scope defined by the enum tag.  This
/* is necessary since enumerators exist at the same scope as their parent
/* enum tags.  For completeness, the base type id field of the type-node
/* referred to by each enumerator symbol (via SYM_NODE.TYPE) is set to
/* the symbol node id of its parent enum tag. 
/* ------------------------------------------------------------------- */

BEGIN_ENUM_BODY: procedure external (X_BEGIN_ENUM_BODY);

	call BEGIN_CLASS_BODY ();

	CURRENT_ENUM_TYPE		= SYM_NODE.TYPE;
	CURRENT_ENUM_TOP_TYPE		= SYM_NODE.TOP_TYPE;

	CURRENT_ENUM_NO_BASE_TYPE	= ^SYM_NODE.HAS_ENUM_INTEGRAL_TYPE;
	CURRENT_ENUM_BASE_TYPE		= rank (SYM_NODE.ENUM_INTEGRAL_TYPE);

	call SET_SCOPE_NODE_R (CURRENT_SCOPE);

	CURRENT_ENUM_PARENT_SCOPE	= SCOPE_NODE.ENCLOSING_SCOPE;

	if (SCOPE_NODE.ENCLOSING_SCOPE_TYPE = byte (CLASS_SCOPE)) &
	   ^SW_NO_NESTED_ENUMERATOR_NAMES then do;
		call SET_SCOPE_NODE_R (CURRENT_ENUM_PARENT_SCOPE);
		call SET_SYM_NODE_R (SCOPE_NODE.OWNER);
		CURRENT_ENUM_PARENT_SCOPE_NAME = SYM_NODE.NAME;
	end;
	else	CURRENT_ENUM_PARENT_SCOPE_NAME = NULL_NID;

	CURRENT_ENUMERATOR_VALUE	= 0;
	CURRENT_ENUMERATOR_LARGE_VALUE	= 0;
	CURRENT_ENUMERATOR_SMALL_VALUE	= 0;
	CURRENT_ENUMERATOR_COUNT	= 0;

end BEGIN_ENUM_BODY;

/* ---------------------------------------------------------------------
/* SET_ENUMERATOR_DECLARATION
/* ------------------------------------------------------------------- */

SET_ENUMERATOR_DECLARATION: procedure
			    external  (X_SET_ENUMERATOR_DECLARATION);

	/*
	/* Make sure this enumerator hasn't already
	/* been declared within this enumeration.
	/**/

	if SEARCH_SCOPE (CURRENT_SCOPE,
			 CURRENT_NAME,
			 VANILLA_SK) ^= NULL_NID then do;
		/*
		/* Error; this (enumerator) name has been
		/* previously declared in this enumeration.
		/**/
		call SEMANTIC_ERROR_I
		     (ERR_DUP_ENUMERATOR,
		      QUALIFIED_SYMBOL_NAME ((CURRENT_NODE_ID)));
		return;
	end;

	/*
	/* Make sure this enumerator hasn't already been declared
	/* in the scope in which it really semantically resides.
	/**/

	if SEARCH_SCOPE (CURRENT_ENUM_PARENT_SCOPE,
			 CURRENT_NAME,
			 VANILLA_SK) ^= NULL_NID then do;
		/*
		/* Error; this (enumerator) name has
		/* been previously declared in this scope.
		/**/
		call SEMANTIC_ERROR_II
		     (ERR_ENUMERATOR_REDCL,
		      QUALIFIED_SYMBOL_NAME ((CURRENT_NODE_ID)),
		      SYMBOL_LOCATION_NAME ((CURRENT_NODE_ID)));
		return;
	end;

	/*
	/* If this enumerator is nested within a class, then make sure it
	/* doesn't have the same name is its enclosing class tag name
	/* (C++ARM, 9.2); e.g. "class A { enum { A }; };".
	/**/

	if CURRENT_ENUM_PARENT_SCOPE_NAME = CURRENT_NAME then do;
		/*
		/* Error; a nested enumerator may not have the
		/* same name as its enclosing class (C++ARM, 9.2).
		/**/
		call SEMANTIC_ERROR_I (ERR_MEMBER_NAME,
				       TOKEN_NAME (CURRENT_NAME));
		return;
	end;

	/*
	/* Build a type-node for this enumerator declaration from the current
	/* declaration data; sets CURRENT_TYPE & CURRENT_TOP_TYPE, and
	/* leaves the current declaration specifier and name data intact.
	/**/

	CURRENT_TYPE		  = CURRENT_ENUM_TYPE;
	CURRENT_TOP_TYPE	  = CURRENT_ENUM_TOP_TYPE;
	CURRENT_TYPE_FROM_TYPEDEF = FALSE;

	/* Build an enumerator (enum member) sym-node */ 

	CURRENT_ENUMERATOR = BUILD_SYMBOL (ENUM_MEMBER_SK);

	/*
	/* Link this symbol into the current (class (enum)) scope;
	/* In C++ mode, we install the enumerator immediately after
	/* its name has been seen; note that using it however yields a
	/* technically undefined value (we choose zero); see C++ARM, 3.2.
	/* In ANSI or Classic C mode, we install the enumerator after
	/* the initializer (if any) has been specified.  This is an
	/* exceedingly minor point, undeserving of even this comment.
	/**/

	if SW_C_PLUS_PLUS then
		call INSTALL_SYMBOL (CURRENT_ENUMERATOR, CURRENT_SCOPE);

	/* Initialize enumerator related data */

	CURRENT_ENUMERATOR_INITIAL = FALSE;

	/* Return with the enumerator sym-node paged in */

	return;

end SET_ENUMERATOR_DECLARATION;

/* ---------------------------------------------------------------------
/* SET_ENUMERATOR_INITIALIZED
/* ------------------------------------------------------------------- */

SET_ENUMERATOR_INITIALIZED: procedure
			    external  (X_SET_ENUMERATOR_INITIALIZED);

	CURRENT_ENUMERATOR_INITIAL = TRUE;

end SET_ENUMERATOR_INITIALIZED;

/* ---------------------------------------------------------------------
/* SET_ENUMERATOR_VALUE
/* ------------------------------------------------------------------- */

SET_ENUMERATOR_VALUE: procedure external (X_SET_ENUMERATOR_VALUE);

	declare
		NEGATIVE	type (BOOL_T),
		LARGE_UNSIGNED	type (BOOL_T),
		OVERFLOW	type (BOOL_T);

	if ^SW_C_PLUS_PLUS then
		call INSTALL_SYMBOL (CURRENT_ENUMERATOR, CURRENT_SCOPE);

	OVERFLOW = FALSE;

	/* Handle an explicit enumerator initializer */

	if CURRENT_ENUMERATOR_INITIAL then do;

		if CURRENT_CONSTANT_NON_CONSTANT then do;
			/*
			/* Error; an enumerator initializer must
			/* specify a constant expression; ignored.
			/**/
			call SEMANTIC_ERROR (ERR_NON_CONSTANT_ENUM);
			goto DONE_SET_ENUMERATOR_VALUE;
		end;

		/* Check for overflow */

		NEGATIVE = (CURRENT_CONSTANT_VALUE < 0) &
			   (CURRENT_CONSTANT_INTEGRAL_TYPE ^= UCHAR_BT) &
			   (CURRENT_CONSTANT_INTEGRAL_TYPE ^= USHORT_BT) &
			   (CURRENT_CONSTANT_INTEGRAL_TYPE ^= UINT_BT) &
			   (CURRENT_CONSTANT_INTEGRAL_TYPE ^= ULONG_BT);

		LARGE_UNSIGNED = (CURRENT_CONSTANT_VALUE < 0) & ^NEGATIVE;

		if (CURRENT_ENUM_BASE_TYPE = CHAR_BT) |
		   (CURRENT_ENUM_BASE_TYPE = SCHAR_BT) then do;
			if (CURRENT_CONSTANT_VALUE > MAX_CHAR) |
			   (CURRENT_CONSTANT_VALUE < MIN_CHAR) |
			    LARGE_UNSIGNED then
				OVERFLOW = TRUE;
		end;
		else if CURRENT_ENUM_BASE_TYPE = SHORT_BT then do;
			if (CURRENT_CONSTANT_VALUE > MAX_SHORT_INT) |
			   (CURRENT_CONSTANT_VALUE < MIN_SHORT_INT) |
			    LARGE_UNSIGNED then
				OVERFLOW = TRUE;
		end;
		else if CURRENT_ENUM_BASE_TYPE = INT_BT then do;
			if (CURRENT_CONSTANT_VALUE > MAX_INT) |
			   (CURRENT_CONSTANT_VALUE < MIN_INT) |
			    LARGE_UNSIGNED then
				OVERFLOW = TRUE;
		end;
		else if CURRENT_ENUM_BASE_TYPE = LONG_BT then do;
			if (CURRENT_CONSTANT_VALUE > MAX_LONG) |
			   (CURRENT_CONSTANT_VALUE < MIN_LONG) |
			    LARGE_UNSIGNED then
				OVERFLOW = TRUE;
		end;
		else if NEGATIVE then
			OVERFLOW = TRUE;
		else if CURRENT_ENUM_BASE_TYPE = UCHAR_BT then do;
			if (CURRENT_CONSTANT_VALUE > MAX_UCHAR) |
			    LARGE_UNSIGNED then
				OVERFLOW = TRUE;
		end;
		else if CURRENT_ENUM_BASE_TYPE = USHORT_BT then do;
			if ((CURRENT_CONSTANT_VALUE > MAX_USHORT_INT) &
			    (MAX_USHORT_INT > 0)) |
			   (LARGE_UNSIGNED & (MAX_USHORT_INT > 0)) then
				OVERFLOW = TRUE;
		end;
		else if CURRENT_ENUM_BASE_TYPE = UINT_BT then do;
			if ((CURRENT_CONSTANT_VALUE > MAX_UINT) &
			    (MAX_UINT > 0)) |
			   (LARGE_UNSIGNED & (MAX_UINT > 0)) then
				OVERFLOW = TRUE;
		end;
		else if CURRENT_ENUM_BASE_TYPE = ULONG_BT then do;
			if ((CURRENT_CONSTANT_VALUE > MAX_ULONG) &
			    (MAX_ULONG > 0)) |
			   (LARGE_UNSIGNED & (MAX_ULONG > 0)) then
				OVERFLOW = TRUE;
		end;

		/* Get the enumerator initializer value */

		CURRENT_ENUMERATOR_VALUE = CURRENT_CONSTANT_VALUE;
	end;

	/* No explicit enumerator initializer; increment by 1 */

	else if CURRENT_ENUMERATOR_COUNT > 0 then do;

		/* Check for overflow */

		if (CURRENT_ENUM_BASE_TYPE = CHAR_BT) |
		   (CURRENT_ENUM_BASE_TYPE = SCHAR_BT) then do;
			if CURRENT_ENUMERATOR_VALUE = MAX_CHAR then
				OVERFLOW = TRUE;
		end;
		else if CURRENT_ENUM_BASE_TYPE = UCHAR_BT then do;
			if CURRENT_ENUMERATOR_VALUE = MAX_UCHAR then
				OVERFLOW = TRUE;
		end;
		else if CURRENT_ENUM_BASE_TYPE = SHORT_BT then do;
			if CURRENT_ENUMERATOR_VALUE = MAX_SHORT_INT then
				OVERFLOW = TRUE;
		end;
		else if CURRENT_ENUM_BASE_TYPE = USHORT_BT then do;
			if CURRENT_ENUMERATOR_VALUE = MAX_USHORT_INT then
				OVERFLOW = TRUE;
		end;
		else if CURRENT_ENUM_BASE_TYPE = INT_BT then do;
			if CURRENT_ENUMERATOR_VALUE = MAX_INT then
				OVERFLOW = TRUE;
		end;
		else if CURRENT_ENUM_BASE_TYPE = UINT_BT then do;
			if CURRENT_ENUMERATOR_VALUE = MAX_UINT then
				OVERFLOW = TRUE;
		end;
		else if CURRENT_ENUM_BASE_TYPE = LONG_BT then do;
			if CURRENT_ENUMERATOR_VALUE = MAX_LONG then
				OVERFLOW = TRUE;
		end;
		else if CURRENT_ENUM_BASE_TYPE = ULONG_BT then do;
			if CURRENT_ENUMERATOR_VALUE = MAX_ULONG then
				OVERFLOW = TRUE;
		end;

		/* Increment the enumerator value by 1 */

		CURRENT_ENUMERATOR_VALUE = CURRENT_ENUMERATOR_VALUE + 1;

	end;

	if OVERFLOW then do;
		/*
		/* Error; enumerator overflow.
		/**/
		if CURRENT_CLASS_NAME = NULL_NID then
			call SEMANTIC_ERROR_II
			     (ERR_BIG_UNNAMED_ENUM,
			      QUALIFIED_SYMBOL_NAME (CURRENT_ENUMERATOR),
			      MAP_TYPE_CODE_NAME (CURRENT_ENUM_BASE_TYPE));
		else	call SEMANTIC_ERROR_III
			     (ERR_BIG_ENUM,
			      QUALIFIED_SYMBOL_NAME (CURRENT_ENUMERATOR),
			      QUALIFIED_SYMBOL_NAME (CURRENT_CLASS),
			      MAP_TYPE_CODE_NAME (CURRENT_ENUM_BASE_TYPE));
		CURRENT_ENUMERATOR_VALUE = 0;
	end;

	/* Track the largest/smallest enumerator value */

	if CURRENT_ENUMERATOR_VALUE < CURRENT_ENUMERATOR_SMALL_VALUE then
		CURRENT_ENUMERATOR_SMALL_VALUE = CURRENT_ENUMERATOR_VALUE;
	else if CURRENT_ENUMERATOR_VALUE > CURRENT_ENUMERATOR_LARGE_VALUE then
		CURRENT_ENUMERATOR_LARGE_VALUE = CURRENT_ENUMERATOR_VALUE;

	DONE_SET_ENUMERATOR_VALUE:

	/* Set the enumerator value and mark it as being defined */

	call SET_SYM_NODE (CURRENT_ENUMERATOR);

	SYM_NODE.LOCATION	= CURRENT_ENUMERATOR_VALUE;
	SYM_NODE.DEFINED	= TRUE;

	/* If desired, lint-check for duplicate valued enumerators */

	if SW_WARN_DUP_ENUMERATOR_VALUE then
		call CHECK_FOR_DUP_ENUMERATOR_VALUE ();

	/* Increment the number of enumerators */

	CURRENT_ENUMERATOR_COUNT = CURRENT_ENUMERATOR_COUNT + 1;

/* ---------------------------------------------------------------------
/* CHECK_FOR_DUP_ENUMERATOR_VALUE
/* ------------------------------------------------------------------- */

CHECK_FOR_DUP_ENUMERATOR_VALUE: procedure internal;

	declare (S, NEXT_S) type (NID_T);

	if CURRENT_ENUMERATOR_COUNT <= 0 then
		return;

	call SET_SYM_NODE_R (CURRENT_SCOPE);
	do S = SCOPE_NODE.SYMBOLS repeat (NEXT_S) while (S ^= NULL_NID);
		if S = CURRENT_ENUMERATOR then
			return;
		call SET_SYM_NODE_R (S);
		if SYM_NODE.LOCATION = CURRENT_ENUMERATOR_VALUE then do;
			/*
			/* Warning; the value (N) of this enumerator
			/* "X" is the same as the value of the
			/* enumerator "Y" declared on line L.
			/**/
			call SEMANTIC_ERROR_IIII
			     (ERR_DUP_ENUM_VALUE,
			      trim (char (CURRENT_ENUMERATOR_VALUE)),
			      QUALIFIED_SYMBOL_NAME (CURRENT_ENUMERATOR),
			      QUALIFIED_SYMBOL_NAME (S),
			      SYMBOL_LOCATION_NAME (S));
			return;
		end;
		NEXT_S = SYM_NODE.NEXT_SYMBOL;
	end;

end CHECK_FOR_DUP_ENUMERATOR_VALUE;

end SET_ENUMERATOR_VALUE;

/* ---------------------------------------------------------------------
/* END_ENUM_BODY
/* ------------------------------------------------------------------- */

END_ENUM_BODY: procedure external (X_END_ENUM_BODY);

	declare
		TYPE		type (NID_T),
		SIZE_UNITS	type (SHORT_T),
		BOUNDARY	type (SHORT_T);

	call END_CLASS_BODY ();

	/*
	/* If this enumeration had an associated integral type specified
	/* with it, then the size has already been set (in BUILD_SYMBOL).
	/**/

	if ^CURRENT_ENUM_NO_BASE_TYPE then
		return;

	/* Determine the size (optimal if desired) of this enumeration */

	if SW_USE_SHORTEST_POSSIBLE_ENUM then do;
		if CURRENT_ENUMERATOR_SMALL_VALUE < 0 then do;
			if CURRENT_ENUMERATOR_LARGE_VALUE > MAX_SHORT_INT then
	 			TYPE = LONG_BT;
			else if CURRENT_ENUMERATOR_LARGE_VALUE > MAX_CHAR then
				TYPE = SHORT_BT;
			else	TYPE = CHAR_BT;
		end;
		else if CURRENT_ENUMERATOR_LARGE_VALUE > MAX_USHORT_INT then
			TYPE = LONG_BT;
		else if CURRENT_ENUMERATOR_LARGE_VALUE > MAX_UCHAR then
			TYPE = USHORT_BT;
		else	TYPE = UCHAR_BT;

		call SET_SYM_NODE (CURRENT_ENUM_TOP_TYPE.TAG_SYMBOL);

		call SIMPLE_TYPE_SIZE
		     (TYPE, SYM_NODE.SIZE, SIZE_UNITS, BOUNDARY);

		SYM_NODE.SIZE_UNITS		= byte (SIZE_UNITS);
		SYM_NODE.BOUNDARY		= byte (BOUNDARY);
		SYM_NODE.ENUM_INTEGRAL_TYPE	= byte (TYPE);
	end;
	else do;
		call SET_SYM_NODE (CURRENT_ENUM_TOP_TYPE.TAG_SYMBOL);
		SYM_NODE.ENUM_INTEGRAL_TYPE = byte (CURRENT_ENUM_BASE_TYPE);
		SYM_NODE.HAS_ENUM_INTEGRAL_TYPE = TRUE;
		call SIMPLE_TYPE_SIZE (CURRENT_ENUM_BASE_TYPE,
				       SYM_NODE.SIZE,
				       SIZE_UNITS, BOUNDARY);
		SYM_NODE.SIZE_UNITS = byte (SIZE_UNITS);
		SYM_NODE.BOUNDARY   = byte (BOUNDARY);
	end;

end END_ENUM_BODY;

/* ---------------------------------------------------------------------
/* SET_ENUM_DECLARATION
/* ------------------------------------------------------------------- */

SET_ENUM_DECLARATION: procedure external (X_SET_ENUM_DECLARATION);

	call SET_CLASS_DECLARATION ();

end SET_ENUM_DECLARATION;

/* ---------------------------------------------------------------------
/* SET_DERIVED_TYPE_QUALIFIER
/* ------------------------------------------------------------------- */

SET_DERIVED_TYPE_QUALIFIER: procedure
			    external  (X_SET_DERIVED_TYPE_QUALIFIER);

	/*
	/* Push the type qualifier; poped by
	/* SET_POINTER_TYPE or SET_REFERENCE_TYPE.
	/**/

	call PUSH_TYPE_QUALIFIER (CURRENT_TYPE_QUALIFIER);

	/* Clear for possible subsequent type qualifiers */

	CURRENT_TYPE_QUALIFIER = NULL_TQ;

end SET_DERIVED_TYPE_QUALIFIER;

/* ---------------------------------------------------------------------
/* SET_DERIVED_CLASS_QUALIFIER
/*
/* Sets the class qualifier for the (presumably pointer) derived type;
/* i.e. sets up a member pointer.
/* ------------------------------------------------------------------- */

SET_DERIVED_CLASS_QUALIFIER: procedure
			     external  (X_SET_DERIVED_CLASS_QUALIFIER);

	/* Push the class qualifier; popped in SET_MEMBER_POINTER_TYPE */

	call PUSH_CLASS_QUALIFIER (CURRENT_NAME_SCOPE_SYMBOL);

end SET_DERIVED_CLASS_QUALIFIER;

/* ---------------------------------------------------------------------
/* SET_MEMBER_POINTER_TYPE
/* ------------------------------------------------------------------- */

SET_MEMBER_POINTER_TYPE: procedure external (X_SET_MEMBER_POINTER_TYPE);

	declare T type (TYPE_DATA_T);

	T.CODE		= byte (MEMBER_POINTER_DT);
	T.QUALIFIERS	= POP_TYPE_QUALIFIER ();
	T.TAG_SYMBOL	= POP_CLASS_QUALIFIER ();

	call PUSH_DERIVED_TYPE (T);

	CURRENT_DERIVED_TYPE_LEVEL = CURRENT_DERIVED_TYPE_LEVEL + 1;

end SET_MEMBER_POINTER_TYPE;

/* ---------------------------------------------------------------------
/* SET_MEMBER_REFERENCE_TYPE
/*
/* This is used only to support the strange cfront
/* member-function-reference type extension.  E.g.:
/*
/*   struct A *ap;
/*   typedef void A::T();
/*   T *mp; // Same as: void (A::*mp)();
/* ------------------------------------------------------------------- */

SET_MEMBER_REFERENCE_TYPE: procedure internal;

	declare T type (TYPE_DATA_T);

	T.CODE		= byte (MEMBER_REFERENCE_DT);
	T.QUALIFIERS	= NULL_TQ;
	T.TAG_SYMBOL	= CURRENT_NAME_SCOPE_SYMBOL;

	call POKE_DERIVED_TYPE (T, CURRENT_DERIVED_TYPE_LEVEL);

	CURRENT_DERIVED_TYPE_LEVEL = CURRENT_DERIVED_TYPE_LEVEL + 1;

end SET_MEMBER_REFERENCE_TYPE;

/* ---------------------------------------------------------------------
/* SET_POINTER_TYPE
/* ------------------------------------------------------------------- */

SET_POINTER_TYPE: procedure external (X_SET_POINTER_TYPE);

	declare T type (TYPE_DATA_T);

	T.CODE		= byte (POINTER_DT);
	T.QUALIFIERS	= POP_TYPE_QUALIFIER ();
	T.NID		= NULL_NID;

	call PUSH_DERIVED_TYPE (T);

	CURRENT_DERIVED_TYPE_LEVEL = CURRENT_DERIVED_TYPE_LEVEL + 1;

end SET_POINTER_TYPE;

/* ---------------------------------------------------------------------
/* SET_REFERENCE_TYPE
/* ------------------------------------------------------------------- */

SET_REFERENCE_TYPE: procedure external (X_SET_REFERENCE_TYPE);

	declare T type (TYPE_DATA_T);

	T.CODE		= byte (REFERENCE_DT);
	T.QUALIFIERS	= POP_TYPE_QUALIFIER ();
	T.NID		= NULL_NID;

	call PUSH_DERIVED_TYPE (T);

	CURRENT_DERIVED_TYPE_LEVEL = CURRENT_DERIVED_TYPE_LEVEL + 1;

end SET_REFERENCE_TYPE;

/* ---------------------------------------------------------------------
/* BEGIN_ARRAY_TYPE
/* ------------------------------------------------------------------- */

BEGIN_ARRAY_TYPE: procedure external (X_BEGIN_ARRAY_TYPE);

	/*
	/* Save the current declaration context while we parse
	/* the dimension specifier (since "declarations" in the
	/* form of type casts could syntactically occur here.
	/**/

	call SAVE_DECLARATION_STATE ();

end BEGIN_ARRAY_TYPE;

/* ---------------------------------------------------------------------
/* SET_ARRAY_TYPE
/* ------------------------------------------------------------------- */

SET_ARRAY_TYPE: procedure external (X_SET_ARRAY_TYPE);

	declare
		T		type (TYPE_DATA_T),
		IS_INCOMPLETE	type (BOOL_T);

	/* Set this derived array type data */

	T.CODE		= byte (ARRAY_DT);
	T.QUALIFIERS	= CURRENT_TYPE_QUALIFIER;
	T.DIMENSION	= CREATE_DIMENSION (CURRENT_VALUE, IS_INCOMPLETE);
	T.INCOMPLETE	= IS_INCOMPLETE;

	/* Push this derived array type data (popped in BUILD_TYPE) */

	call PUSH_DERIVED_TYPE (T);

	/* Restore the previous declaration state */

	call RESTORE_DECLARATION_STATE ();

	/* Clear the current expression value */

	CURRENT_VALUE = NULL_CXX_VID;

	/* Increment the derived type level */

	CURRENT_DERIVED_TYPE_LEVEL = CURRENT_DERIVED_TYPE_LEVEL + 1;

end SET_ARRAY_TYPE;

/* ---------------------------------------------------------------------
/* SET_INCOMPLETE_ARRAY_TYPE
/*
/* TODO: use SET_ARRAY_TYPE -- clear CURRENT_VALUE in BEGIN_ARRAY_TYPE.
/* ------------------------------------------------------------------- */

SET_INCOMPLETE_ARRAY_TYPE: procedure external (X_SET_INCOMPLETE_ARRAY_TYPE);

	declare
		T		type (TYPE_DATA_T),
		IS_INCOMPLETE	type (BOOL_T);

	/* Set this derived array type data */

	T.CODE		= byte (ARRAY_DT);
	T.QUALIFIERS	= CURRENT_TYPE_QUALIFIER;
	T.DIMENSION	= CREATE_DIMENSION (NULL_CXX_VID, IS_INCOMPLETE);
	T.INCOMPLETE	= IS_INCOMPLETE;

	/* Push this derived array type data (popped in BUILD_TYPE) */

	call PUSH_DERIVED_TYPE (T);

	/* Increment the derived type level */

	CURRENT_DERIVED_TYPE_LEVEL = CURRENT_DERIVED_TYPE_LEVEL + 1;

end SET_INCOMPLETE_ARRAY_TYPE;

/* ---------------------------------------------------------------------
/* BEGIN_FUNCTION_TYPE
/* ------------------------------------------------------------------- */

BEGIN_FUNCTION_TYPE: procedure external (X_BEGIN_FUNCTION_TYPE);

	/*
	/* Save the current declaration context
	/* while we parse the parameter declarations.
	/**/

	call SAVE_DECLARATION_STATE ();
	call SAVE_SIGNATURE_STATE ();

	/*
	/* The following is to ensure the this is legal and
	/* is also a *declaration* rather than a *definition.
	/*
	/*     extern "C" int (*f) (register int);
	/**/

	CURRENT_SIMPLE_LINKAGE_SPECIFIER = FALSE;

	/* Save the current scope and set up a prototype scope */

	if (CURRENT_NAME ^= NULL_NID) &
	   (CURRENT_NAME_SCOPE ^= NULL_NID) &
	   (CURRENT_DERIVED_TYPE_LEVEL = 0) then do;
		/*
		/* Here, we have a prototype scope for a (top level)
		/* function whose name is qualified; in this case we
		/* will set the enclosing scope of the prototype scope
		/* to be that of the name qualifier.  This is to so that
		/* default arguments of a member function are correctly
		/* looked up in the scope of the containing class.
		/**/
		call BEGIN_PROTOTYPE_SCOPE (CURRENT_NAME_SCOPE);
	end;
	else	call BEGIN_PROTOTYPE_SCOPE (NULL_NID);

	/* Initialize the function (signature) declaration data */

	CURRENT_ELLIPSIS		= FALSE;
	CURRENT_PROTOTYPED		= TRUE;

	/*
	/* See if want to interpret "void f ()" as an old-style
	/* (non-prototyped) function declaration (i.e. taking
	/* an unknown number/type of arguments) rather than as
	/* a function taking no arguments (i.e. as in normal C++).
	/**/

	if SW_X_OLD_STYLE_FUNCTIONS then do;
		if AT_END_OF_FUNCTION_DECLARATOR () then
			CURRENT_PROTOTYPED = FALSE;
	end;

end BEGIN_FUNCTION_TYPE;

/* ---------------------------------------------------------------------
/* BEGIN_OLD_FUNCTION_TYPE
/* ------------------------------------------------------------------- */

BEGIN_OLD_FUNCTION_TYPE: procedure external (X_BEGIN_OLD_FUNCTION_TYPE);

	if ^CURRENTLY_DOING_INTERNAL_PARSE &
	   ^SW_X_OLD_STYLE_FUNCTIONS then
		call SEMANTIC_ERROR (ERR_OLD_STYLE_FUN);
	call BEGIN_FUNCTION_TYPE ();
	CURRENT_PROTOTYPED = FALSE;

end BEGIN_OLD_FUNCTION_TYPE;

/* ---------------------------------------------------------------------
/* SET_FUNCTION_TYPE
/* ------------------------------------------------------------------- */

SET_FUNCTION_TYPE: procedure external (X_SET_FUNCTION_TYPE);

	declare
		T				type (TYPE_DATA_T),
		CONTAINS_INCOMPLETE		type (BOOL_T),
		CONTAINS_DEFAULT_ARGUMENT	type (BOOL_T);

	/* Set this derived function type data */

	T.CODE		   = byte (FUNCTION_DT);
	T.QUALIFIERS	   = NULL_TQ;
	T.SIGNATURE	   = CREATE_SIGNATURE (CURRENT_SCOPE,
					       (CURRENT_ELLIPSIS),
					       (CURRENT_PROTOTYPED),
					       (CURRENT_TYPE_QUALIFIER),
					       CONTAINS_INCOMPLETE,
					       CONTAINS_DEFAULT_ARGUMENT);
	T.INCOMPLETE	   = CONTAINS_INCOMPLETE;
	T.DEFAULT_ARGUMENT = CONTAINS_DEFAULT_ARGUMENT;

	/* Push this derived function type data (popped in BUILD_TYPE) */

	call PUSH_DERIVED_TYPE (T);

	/* Clear the current type qualifier */

	CURRENT_TYPE_QUALIFIER = NULL_TQ;

	/* End this prototype scope */

	call END_PROTOTYPE_SCOPE ();

	/* Restore the previous declaration state */

	call RESTORE_SIGNATURE_STATE ();
	call RESTORE_DECLARATION_STATE ();

	/* Increment the derived type level */

	CURRENT_DERIVED_TYPE_LEVEL = CURRENT_DERIVED_TYPE_LEVEL + 1;

	/*
	/* See if this is an old-style function definition with no
	/* parameters; e.g. extern "CC" f () { }.  This should be
	/* handled in the grammar but sadly is not; it's a special
	/* case becauase it looks like a prototyped function definition.
	/**/

	if SW_X_OLD_STYLE_FUNCTIONS then do;
		if (CURRENT_OLD_PARAMETERS = NULL_NID) &
		   (CURRENT_SCOPE_TYPE = GLOBAL_SCOPE) then do;
			if AT_FUNCTION_DEFINITION () then
				CURRENT_OLD_FUNCTION_DEFINITION = TRUE;
		end;
	end;

end SET_FUNCTION_TYPE;

/* ---------------------------------------------------------------------
/* SET_PARAMETER_DECLARATION
/* ------------------------------------------------------------------- */

SET_PARAMETER_DECLARATION: procedure
			   external  (X_SET_PARAMETER_DECLARATION);

	declare THIS_PARAMETER	type (NID_T);

	/* Check the storage class; only "register" or "auto" */

	if (CURRENT_STORAGE_CLASS ^= NULL_ST) &
	   (CURRENT_STORAGE_CLASS ^= REGISTER_ST) then do;
		if CURRENT_STORAGE_CLASS ^= AUTO_ST then
			call SEMANTIC_ERROR (ERR_BAD_PARAM_STORAGE);
		else if ^SW_C_PLUS_PLUS then
			call SEMANTIC_ERROR (ERR_BAD_C_PARAM_STORAGE);
		CURRENT_STORAGE_CLASS = AUTO_ST;
	end;
	else if CURRENT_STORAGE_CLASS = NULL_ST then
		CURRENT_STORAGE_CLASS = AUTO_ST;

	/* Make sure this isn't a friend (only within class definitions) */

	if CURRENT_FRIEND then do;
		/*
		/* Error; a parameter declaration may
		/* not be specified as a friend; ignored.
		/**/
		call SEMANTIC_ERROR (ERR_BAD_FRIEND);
		CURRENT_FRIEND = FALSE;
	end;

	/* Make sure no function specifiers are given */

	if CURRENT_INLINE | CURRENT_OVERLOAD | CURRENT_VIRTUAL then do;
		/*
		/* Error; a parameter declaration may not
		/* specify any function specifiers; ignored.
		/**/
		call SEMANTIC_ERROR (ERR_FUN_SPEC_PARAM);
	end;

	/* Make sure this is not a duplicate parameter declaration */

	if SEARCH_SCOPE (CURRENT_SCOPE,
			 CURRENT_NAME,
			 VANILLA_SK) ^= NULL_NID then do;
		/*
		/* Error; this parameter has already been declared.
		/**/
		call SEMANTIC_ERROR_I (ERR_DUP_PARAM_NAME,
				       TOKEN_NAME (CURRENT_NAME));
		CURRENT_NAME = NULL_NID;
	end;

	/*
	/* Build a type-node for this parameter declaration from the current
	/* declaration data; sets CURRENT_TYPE & CURRENT_TOP_TYPE, and
	/* leaves the current declaration specifier and name data intact.
	/**/

	call BUILD_CURRENT_PARAMETER_TYPE ();
	
	/* Make sure it's not a "const" function */

	call CHECK_QUALIFIED_SIGNATURE (CURRENT_TOP_TYPE);

	/* Build a parameter symbol node */

	THIS_PARAMETER = BUILD_SYMBOL (PARAMETER_SK);

	/* Link this symbol into the current (prototype) scope */

	call INSTALL_SYMBOL (THIS_PARAMETER, CURRENT_SCOPE);

	/* Return with CURRENT_SYMBOL set to this symbol */

	CURRENT_SYMBOL = THIS_PARAMETER;

end SET_PARAMETER_DECLARATION;

/* ---------------------------------------------------------------------
/* SET_PARAMETER_INITIALIZER
/* ------------------------------------------------------------------- */

SET_PARAMETER_INITIALIZER: procedure
			   external (X_SET_PARAMETER_INITIALIZER);

	declare INITIALIZED_PARAMETER type (NID_T);

	/*
	/* Give this initial value to the appropriate
	/* (i.e. last) parameter declaration symbol.
	/**/

	call SET_SCOPE_NODE_R (CURRENT_SCOPE);
	INITIALIZED_PARAMETER = SCOPE_NODE.LAST_SYMBOL;
	call SET_SYM_NODE_R (INITIALIZED_PARAMETER);

	/* Get the initial value */

	SYM_NODE.EXPRESSION	= CURRENT_VALUE;
	SYM_NODE.INITIAL_AT	= TRUE;

	call CHECK_DEFAULT_ARGUMENT (INITIALIZED_PARAMETER);

end SET_PARAMETER_INITIALIZER;

/* ---------------------------------------------------------------------
/* SET_ELLIPSIS
/* ------------------------------------------------------------------- */

SET_ELLIPSIS: procedure external (X_SET_ELLIPSIS);

	if CURRENT_ELLIPSIS then
		call SEMANTIC_ERROR (ERR_DUP_ELLIPSIS);
	else if ^AT_END_OF_FUNCTION_DECLARATOR () then
		call SEMANTIC_ERROR (ERR_DUP_ELLIPSIS);
	CURRENT_ELLIPSIS = TRUE;

end SET_ELLIPSIS;

/* ---------------------------------------------------------------------
/* SET_OLD_PARAMETER_NAME
/*
/* Processes a parameter name for an old-style function definition.
/* ------------------------------------------------------------------- */

SET_OLD_PARAMETER_NAME: procedure
			external  (X_SET_OLD_PARAMETER_NAME);

	declare THIS_PARAMETER type (NID_T);

	/* Make sure this parameter hasn't already been specified */

	if SEARCH_SCOPE (CURRENT_SCOPE,
			 CURRENT_NAME,
			 VANILLA_SK) ^= NULL_NID then do;
		/*
		/* Error; this parameter has already been declared.
		/**/
		call SEMANTIC_ERROR_I (ERR_DUP_PARAM_NAME,
				       TOKEN_NAME (CURRENT_NAME));
		return;
	end;

	/* Build a parameter symbol node containing *only* the name */

	THIS_PARAMETER = BUILD_OLD_PARAMETER_SYMBOL ();

	/* Link this symbol into the current (prototype) scope */

	call INSTALL_SYMBOL (THIS_PARAMETER, CURRENT_SCOPE);

	if CURRENT_OLD_PARAMETERS = NULL_NID then do;
		call SET_SCOPE_NODE_R (CURRENT_SCOPE);
		CURRENT_OLD_PARAMETERS = SCOPE_NODE.SYMBOLS;
	end;

end SET_OLD_PARAMETER_NAME;

/* ---------------------------------------------------------------------
/* BEGIN_OLD_PARAMETER_LIST
/* ------------------------------------------------------------------- */

BEGIN_OLD_PARAMETER_LIST: procedure external (X_BEGIN_OLD_PARAMETER_LIST);

end BEGIN_OLD_PARAMETER_LIST;

/* --------------------------------------------------------------------
/* SET_OLD_PARAMETER_DECLARATION
/*
/* Processes a parameter name for an old-style function definition.
/* ------------------------------------------------------------------- */

SET_OLD_PARAMETER_DECLARATION: procedure
			       external  (X_SET_OLD_PARAMETER_DECLARATION);

	declare (P, NEXT_P) type (NID_T);

	/*
	/* Build a type-node for this parameter declaration from the current
	/* declaration data; sets CURRENT_TYPE & CURRENT_TOP_TYPE, and
	/* leaves the current declaration specifier and name data intact.
	/**/

	call BUILD_CURRENT_PARAMETER_TYPE ();

	/* Check the name kind */

	if CURRENT_NAME_KIND ^= VANILLA_NK then do;
		/*
		/* Error; a parameter must be a plain old-fashioned name.
		/**/
		call SEMANTIC_ERROR (ERR_PARAM_NAME);
		return;
	end;

	/* Check for an old-style parameter of unpromoted type */

	if rank (CURRENT_TOP_TYPE.CODE) = FLOAT_BT then do;
		/*
		/* This old-style parameter is of the unpromoted
		/* type "float" and will be implicitly promoted
		/* to the promoted type "double".
		/**/
		call SEMANTIC_ERROR_I (ERR_PROMOTE_PARAM,
				       TOKEN_NAME (CURRENT_NAME));
		/*
                /* Perform the actual formal parameter widening here only
		/* for float-to-double type widening.  Other (integral)
		/* types are subsequently narrowed in EXPAND_VALUE (REF_VO).
		/* We don't do the same for float type basically because its
		/* harder (involves explicit conversion), it probably doesn't
		/* come up that often, and PCC doesn't do it either.  So,
		/* problems will only happen when taking the address of an
		/* old-style float parameter, in which case it will *really*
		/* be the address of a double and will be treated as such.
		/**/
		call SET_CURRENT_TYPE (GET_BASIC_TYPE (DOUBLE_BT));
	end;

	/* Check the storage class */

	if (CURRENT_STORAGE_CLASS ^= NULL_ST) &
	   (CURRENT_STORAGE_CLASS ^= REGISTER_ST) then do;
		if CURRENT_STORAGE_CLASS ^= AUTO_ST then
			call SEMANTIC_ERROR (ERR_BAD_PARAM_STORAGE);
		else if ^SW_C_PLUS_PLUS then
			call SEMANTIC_ERROR (ERR_BAD_C_PARAM_STORAGE);
	end;

	/* Make sure no other specifiers are given */

	if CURRENT_FRIEND then do;
		/*
		/* Error; a parameter declaration may
		/* not be specified as a friend; ignored.
		/**/
		call SEMANTIC_ERROR (ERR_BAD_FRIEND);
		CURRENT_FRIEND = FALSE;
	end;
	if CURRENT_INLINE | CURRENT_OVERLOAD | CURRENT_VIRTUAL then do;
		/*
		/* Error; a parameter declaration may not
		/* specify any function specifiers; ignored.
		/**/
		call SEMANTIC_ERROR (ERR_FUN_SPEC_PARAM);
		CURRENT_INLINE   = FALSE;
		CURRENT_OVERLOAD = FALSE;
		CURRENT_VIRTUAL  = FALSE;
	end;

	/*
	/* Make sure this symbol was specified in
	/* the old-style parameter identifier list.
	/**/

	do P = CURRENT_OLD_PARAMETERS repeat (NEXT_P) while (P ^= NULL_NID);
		call SET_SYM_NODE_R (P);
		if SYM_NODE.NAME = CURRENT_NAME then
			leave;
		NEXT_P = SYM_NODE.NEXT_SYMBOL;
	end;
	if P = NULL_NID then do;
		/*
		/* Error; this parameter did not appear in
		/* the old-style parameter identifier list.
		/**/
		call SEMANTIC_ERROR_I (ERR_BAD_AUTO_DCL_NAME,
				       TOKEN_NAME (CURRENT_NAME));
		return;
	end;

	/* Set the type/size of this old-style parameter symbol */

	call FINISH_OLD_PARAMETER_SYMBOL ();

end SET_OLD_PARAMETER_DECLARATION;

/* ---------------------------------------------------------------------
/* SET_OLD_PARAMETER_LIST
/* ------------------------------------------------------------------- */

SET_OLD_PARAMETER_LIST: procedure external (X_SET_OLD_PARAMETER_LIST);

	declare
		(PSYM, NEXT_PSYM)		type (NID_T),
		SAVE_CURRENT_LINKAGE_KIND	type (SHORT_T),
		OLD_PARAMETERS			type (NID_T),
		TYPE_DATA			type (TYPE_DATA_T),
		SIGP				type (POINTER_T),
		(PARAM, NEXT_PARAM)		type (NID_T),
		PARAM_PTR			type (POINTER_T);

	/*
	/* Be paranoid and catch the parameter list now,
	/* before restoring declaration state to the time of
	/* the first aborted call to SET_DECLARATION.
	/**/
	OLD_PARAMETERS = CURRENT_OLD_PARAMETERS;
	CURRENT_OLD_PARAMETERS = NULL_NID;
	call RESTORE_DECLARATION_STATE ();

	/* Find the beginning of the corresponding parameter node list. */
	call TOP_DERIVED_TYPE_DATA (CURRENT_DERIVED_TYPE_LEVEL, TYPE_DATA);
	call GET_SIG_NODE_R (TYPE_DATA.SIGNATURE, SIGP);
	PARAM = SIGP->SIG_NODE.EXPLICIT_PARAMETERS;
	call RELEASE_SIG_NODE (TYPE_DATA.SIGNATURE); 

	/*
	/* Check for undeclared old-style parameters,
	/* and fix up the type in the parameter node list.
	/**/
	do PSYM = OLD_PARAMETERS repeat (NEXT_PSYM) while (PSYM ^= NULL_NID);
		call SET_SYM_NODE_R (PSYM);
		NEXT_PSYM = SYM_NODE.NEXT_SYMBOL;
		if SYM_NODE.TYPE = NULL_NID then
			call SET_IMPLICIT_OLD_PARAMETER_TYPE ();

		call GET_PARAMETER_NODE (PARAM, PARAM_PTR);
		PARAM_PTR->PARAMETER_NODE.TYPE = SYM_NODE.TYPE;
		PARAM_PTR->PARAMETER_NODE.TOP_TYPE = SYM_NODE.TOP_TYPE;
		NEXT_PARAM = PARAM_PTR->PARAMETER_NODE.NEXT;
		call RELEASE_PARAMETER_NODE (PARAM);
		PARAM = NEXT_PARAM;
	end;

	/*
	/* Now, finally, declare the actual function symbol associated
	/* with this old-style parameter declaration list.  This was
	/* delayed until this point (in SET_DECLARATION, hooked on
	/* CURRENT_OLD_PARAMETERS ^= NULL_NID) to handle cases like:
	/*
	/*     int f (int (*)[]);
	/*     int f (a) int (*a)[3]; { }
	/**/

	/*
	/* We will declare old-style functions implicitly with
	/* extern "C" unless explicitly specified otherwise.
	/**/

	SAVE_CURRENT_LINKAGE_KIND = CURRENT_LINKAGE_KIND;

	if CURRENT_LINKAGE_KIND = DEFAULT_LINKAGE then
		CURRENT_LINKAGE_KIND = C_LINKAGE;

	CURRENT_OLD_FUNCTION_DEFINITION = TRUE;

	call SET_DECLARATION ();

	CURRENT_OLD_FUNCTION_DEFINITION = FALSE;

	CURRENT_LINKAGE_KIND = SAVE_CURRENT_LINKAGE_KIND;

	return;

/* ---------------------------------------------------------------------
/* SET_IMPLICIT_OLD_PARAMETER_TYPE
/*
/* Sets the type of the currently paged in sym-node to "auto int" -- to
/* implicitly declare undeclared parameters in an old-style function
/* definition, e.g. "f (a,b) int a; { }".  Preserves current-node-id.
/* ------------------------------------------------------------------- */

SET_IMPLICIT_OLD_PARAMETER_TYPE: procedure internal;

	declare
		SIZE_UNITS	type (SHORT_T),
		BOUNDARY	type (SHORT_T);

	if SW_NO_BASE_TYPE_WARN then do;
		/*
		/* Note; this old-style parameter name has not been
		/* explicitly declared; set its type implicitly.
		/**/
		call SEMANTIC_ERROR_I (ERR_IMPLICIT_OLD_PARAM_DCL,
				       TOKEN_NAME (SYM_NODE.NAME));
	end;

	SYM_NODE.TYPE			= GET_INT_TYPE ();
	SYM_NODE.TOP_TYPE.CODE		= byte (INT_BT);
	SYM_NODE.TOP_TYPE.QUALIFIERS	= NULL_TQ;
	SYM_NODE.TOP_TYPE.NID		= NULL_NID;
	SYM_NODE.STORAGE_CLASS		= byte (AUTO_ST);
	call SIMPLE_TYPE_SIZE (INT_BT, SYM_NODE.SIZE, SIZE_UNITS, BOUNDARY);
	SYM_NODE.SIZE_UNITS		= byte (SIZE_UNITS);
	SYM_NODE.BOUNDARY		= byte (BOUNDARY);

end SET_IMPLICIT_OLD_PARAMETER_TYPE;

end SET_OLD_PARAMETER_LIST;

/* ---------------------------------------------------------------------
/* SAVE_FUNCTION_BODY
/* ------------------------------------------------------------------- */

SAVE_FUNCTION_BODY: procedure external (X_SAVE_FUNCTION_BODY);

	/* Get the sym-node of the function symbol being defined */

	if CURRENT_SYMBOL = NULL_NID then do;
		/*
		/* Error; a function body definition must be
		/* preceeded by a function type declaration.
		/**/
                call SEMANTIC_ERROR (ERR_FUN_BODY_PLACEMENT);
		call COLLECT_FUNCTION_BODY (null(), null(), null());
		return;
	end;

	/* Get the current function sym-node */

	call SET_SYM_NODE_R (CURRENT_SYMBOL);

	/* Make sure it's really a function */

	if ^SYM_NODE.IS_FUNCTION then do;
		/*
		/* Error; a function body definition must be
		/* preceeded by a function type declaration.
		/**/
                call SEMANTIC_ERROR (ERR_FUN_BODY_PLACEMENT);
		call COLLECT_FUNCTION_BODY (null(), null(), null());
		return;
	end;

	if SYM_NODE.DEFINED |
	   (SYM_NODE.SAVED_FUNCTION_BODY.FIRST_TOKEN ^= null ()) then do;
		if SYM_NODE.IS_MEMBER then do;
			/*
			/* Error; this member function has already been
			/* defined; ignore this duplicate definition.
			/**/
			call SEMANTIC_ERROR_II
			     (ERR_DUP_MEMBER_FUN_DEF,
			      FULL_QUALIFIED_SYMBOL_NAME (CURRENT_SYMBOL),
			      SYMBOL_LOCATION_NAME (CURRENT_SYMBOL));
		end;
		else do;
			/*
			/* Error; this function has already been
			/* defined; ignore this duplicate definition.
			/**/
			call SEMANTIC_ERROR_II
			     (ERR_DUP_FUN_DEF,
			      FULL_QUALIFIED_SYMBOL_NAME (CURRENT_SYMBOL),
			      SYMBOL_LOCATION_NAME (CURRENT_SYMBOL));
		end;
		call COLLECT_FUNCTION_BODY (null(), null(), null());
		return;
	end;

	/* Get (collect) the function body tokens and the source state */

	call COLLECT_FUNCTION_BODY
		(SYM_NODE.SAVED_FUNCTION_BODY.FIRST_TOKEN,
		 SYM_NODE.SAVED_FUNCTION_BODY.LAST_TOKEN,
		 SYM_NODE.SAVED_FUNCTION_BODY.SOURCE_STATE);

	/* Place this function on the deferred function list */

	call NOTE_DEFERRED_CURRENT_FUNCTION ();

end SAVE_FUNCTION_BODY;

/* ---------------------------------------------------------------------
/* SAVE_MEMBER_FUNCTION_BODY
/*
/* Collect up and save the body of a member function defined within
/* a class definition; we will parse it later from END_CLASS_BODY.
/* ------------------------------------------------------------------- */

SAVE_MEMBER_FUNCTION_BODY: procedure external (X_SAVE_MEMBER_FUNCTION_BODY);

	declare
		(FIRST, LAST)	type (NID_T),
		(CP, FP, LP)	type (POINTER_T);

	/* Get the sym-node of the function symbol being defined */

	if CURRENT_SYMBOL = NULL_NID then do;
		/*
		/* Error; a function body definition must be
		/* preceeded by a function type declaration.
		/*
		/* -TODO- In this case, skip past the body, otherwise
		/* we could blow up later while processing a statement
		/* because the current function scope is not set up.
		/**/
                call SEMANTIC_ERROR (ERR_FUN_BODY_PLACEMENT);
		call COLLECT_FUNCTION_BODY (null(), null(), null());
		return;
	end;

	/* Get the current member function sym-node */

	call SET_SYM_NODE_R (CURRENT_SYMBOL);

	/* Make sure it's really a function */

	if ^SYM_NODE.IS_FUNCTION then do;
		/*
		/* Error; a function body definition must be
		/* preceeded by a function type declaration.
		/*
		/* -TODO- In this case, skip past the body, otherwise
		/* we could blow up later while processing a statement
		/* because the current function scope is not set up.
		/**/
                call SEMANTIC_ERROR (ERR_FUN_BODY_PLACEMENT);
		call COLLECT_FUNCTION_BODY (null(), null(), null());
		return;
	end;

	if SYM_NODE.DEFINED |
	   (SYM_NODE.SAVED_FUNCTION_BODY.FIRST_TOKEN ^= null ()) then do;
		/*
		/* Error; this member function has already been
		/* defined; ignore this duplicate definition.
		/**/
		call SEMANTIC_ERROR_II
		     (ERR_DUP_MEMBER_FUN_DEF,
		      FULL_QUALIFIED_SYMBOL_NAME (CURRENT_SYMBOL),
		      SYMBOL_LOCATION_NAME (CURRENT_SYMBOL));
		call COLLECT_FUNCTION_BODY (null(), null(), null());
		return;
	end;

	/* Get (collect) the function body tokens and the source state */

	call COLLECT_FUNCTION_BODY
		(SYM_NODE.SAVED_FUNCTION_BODY.FIRST_TOKEN,
		 SYM_NODE.SAVED_FUNCTION_BODY.LAST_TOKEN,
		 SYM_NODE.SAVED_FUNCTION_BODY.SOURCE_STATE);

	/* Link onto the end of the saved function bodies list */

	call GET_SYM_NODE (CURRENT_CLASS, CP);

	if CP->SYM_NODE.SAVED_FUNCTION_BODIES = NULL_NID then do;
		CP->SYM_NODE.SAVED_FUNCTION_BODIES = CURRENT_SYMBOL;
		SYM_NODE.SAVED_FUNCTION_BODY.PREV = CURRENT_SYMBOL;
	end;
	else do;
		FIRST = CP->SYM_NODE.SAVED_FUNCTION_BODIES;
		call GET_SYM_NODE (FIRST, FP);
		LAST = FP->SYM_NODE.SAVED_FUNCTION_BODY.PREV;
		FP->SYM_NODE.SAVED_FUNCTION_BODY.PREV = CURRENT_SYMBOL;
		call RELEASE_SYM_NODE (FIRST);
		call GET_SYM_NODE (LAST, LP);
		LP->SYM_NODE.SAVED_FUNCTION_BODY.NEXT = CURRENT_SYMBOL;
		call RELEASE_SYM_NODE (LAST);
		SYM_NODE.SAVED_FUNCTION_BODY.PREV = LAST;
	end;

	call RELEASE_SYM_NODE (CURRENT_CLASS);

	/* Mark this as an inline function */

	SYM_NODE.INLINE = TRUE;
	SYM_NODE.INTERNAL_LINKAGE = TRUE;
	SYM_NODE.EXTERNAL_LINKAGE = FALSE;

end SAVE_MEMBER_FUNCTION_BODY;

/* ---------------------------------------------------------------------
/* BEGIN_FUNCTION_BODY
/*
/* Initialize a function body, it is assumed that CURRENT_SYMBOL is the
/* sym-node id of the function which is being defined.
/* ------------------------------------------------------------------- */

BEGIN_FUNCTION_BODY: procedure external (X_BEGIN_FUNCTION_BODY);

	declare
		P		type (POINTER_T),
		FUNCTION_SYMBOL	type (NID_T);

	/* Get the sym-node of the function symbol being defined */

	if CURRENT_SYMBOL = NULL_NID then do;
		/*
		/* Error; a function body definition must be
		/* preceeded by a function type declaration.
		/**/
                call SEMANTIC_ERROR (ERR_FUN_BODY_PLACEMENT);
		call SKIP_FUNCTION_BODY ();
		return;
	end;
	FUNCTION_SYMBOL = CURRENT_SYMBOL;

	call RESET_PSECT ();

	call SET_SYM_NODE_R (FUNCTION_SYMBOL);

	if SYM_NODE.TOP_TYPE.CODE ^= byte (FUNCTION_DT) then do;
		/*
		/* Error; a function body definition must be
		/* preceeded by a function type declaration.
		/**/
                call SEMANTIC_ERROR (ERR_FUN_BODY_PLACEMENT);
		call SKIP_FUNCTION_BODY ();
		return;
	end;

	/* Check for missing parameter list and create if necessary. */
	call REMAKE_PROTOTYPE_SCOPE (FUNCTION_SYMBOL, NULL_NID, TRUE);

	/* Check for a bogus storage class */

	if SYM_NODE.STORAGE_CLASS = byte (TYPEDEF_ST) then
		call SEMANTIC_ERROR (ERR_FCT_STOR_CLASS);

	/* Make sure this function hasn't already been defined */

	if CURRENTLY_DOING_INTERNAL_PARSE then do;
		/*
		/* Error (if any) already diagnosed.
		/**/
		;
	end;
	else if SYM_NODE.IS_DUMMY & SYM_NODE.IS_AGGREGATE_MEMBER then do;
		call SEMANTIC_ERROR_II
		     (ERR_DEF_DUMMY_MEMBER,
		      FULL_SYMBOL_NAME (FUNCTION_SYMBOL),
		      QUALIFIED_SYMBOL_NAME (SYM_NODE.ENCLOSING_SCOPE_OWNER));
	end;
	else if SYM_NODE.DEFINED then do;
		call SEMANTIC_ERROR_II
		     (ERR_REDEF_FUN,
		      FULL_QUALIFIED_SYMBOL_NAME (FUNCTION_SYMBOL),
		      SYMBOL_LOCATION_NAME (FUNCTION_SYMBOL));
	end;

	if SW_LINT then do;
		/*
		/* Give a note/warning for an external linkage
		/* function defined within a header file.
		/**/
		if SYM_NODE.EXTERNAL_LINKAGE then do;
			if CURRENT_SOURCE.INCLUDED_BY ^= null () then do;
				if (CURRENT_SOURCE.INCLUDED_BY->
				    CURRENT_SOURCE.INCLUDED_BY ^= null ()) |
				   (CURRENT_NAME_FILE_ID ^=
				    CURRENT_SOURCE.INCLUDED_BY->
				    CURRENT_SOURCE.FILE) then do;
					call SEMANTIC_ERROR_I
					     (ERR_EXTERN_LINKAGE_HEADER_FUN,
					      COMPLETE_QUALIFIED_SYMBOL_NAME
					      (FUNCTION_SYMBOL));
				end;
			end;
		end;
	end;

	SYM_NODE.DEFINED = TRUE;

	/*
	/* If this function is nested within a local scope (i.e.
	/* a member function of a local class) then we need to emit
	/* a branch-around before we enter the new function scope.
	/**/

	if CURRENT_FUNCTION_SCOPE ^= NULL_NID then do;
		call GET_SYM_NODE_R (CURRENT_FUNCTION, P);
		P->SYM_NODE.BRANCH_AROUND_LABEL =
			BRANCH_AROUND_NESTED_FUNCTION ();
		call RELEASE_SYM_NODE (CURRENT_FUNCTION);
	end;

	/* Begin a function scope */

	call BEGIN_FUNCTION_SCOPE (FUNCTION_SYMBOL);

	/* Install the parameter list of this function in the function scope */

	call INSTALL_PARAMETERS (FUNCTION_SYMBOL, CURRENT_SCOPE);

	/* TODO: call BEGIN_MEMBER_INITIAL_LIST (); instead of from grammar */

	/*
	/* The following is to ensure the this is legal:
	/*     extern "C" f () { extern int x; }
	/* but this is not legal:
	/*     extern "C" extern x;
	/**/

	CURRENT_SIMPLE_LINKAGE_SPECIFIER = FALSE;

end BEGIN_FUNCTION_BODY;

/* ---------------------------------------------------------------------
/* END_FUNCTION_BODY
/* ------------------------------------------------------------------- */

END_FUNCTION_BODY: procedure external (X_END_FUNCTION_BODY);

	declare
		P		type (POINTER_T),
		LAST_LINE_ID	type (LONG_T),
		SAVE_LINE_ID	type (LONG_T);

	if CURRENT_SCOPE_TYPE ^= FUNCTION_SCOPE then do;
		/*
		/* We just finished collecting the tokens from
		/* a member function definition within a class
		/* declaration (i.e. for which a scope was not made).
		/* TODO: does this really happen any more ??
		/**/
		return;
	end;

	/*
	/* Fudge/force the current source line to be the closing "}"
	/* of the function for any exit code which gets emitted.
	/**/

	LAST_LINE_ID		= MATCHED_TOKEN.LINE;	/* closing "}" */
	SAVE_LINE_ID		= CURRENT_SOURCE.LINE;
	CURRENT_SOURCE.LINE	= LAST_LINE_ID;
	DIAG_LINE_ID		= LAST_LINE_ID;

	/*
	/* End of a function body is equivalent to a return with no value.
	/* Do this to ensure destructor calls, and to get the warning in
	/* case this is reachable and the function needs a value to return.
	/**/

	call EMIT_IMPLICIT_RETURN ();

	/* Terminate this function scope */

	call END_FUNCTION_SCOPE ();

	/* Emit a function exit point sequence */

	call EMIT_FUNCTION_END ();

	/*
	/* If this function was nested within a local scope (i.e.
	/* a member function of a local class) then we need to emit the
	/* label for the branch-around emitted in BEGIN_FUNCTION_BODY.
	/**/

	if CURRENT_FUNCTION_SCOPE ^= NULL_NID then do;
		call GET_SYM_NODE_R (CURRENT_FUNCTION, P);
		call EMIT_LABEL_VALUE (P->SYM_NODE.BRANCH_AROUND_LABEL);
		call RELEASE_SYM_NODE (CURRENT_FUNCTION);
	end;

	/* Restore the correct current source line (fudged above) */

	CURRENT_SOURCE.LINE	= SAVE_LINE_ID;
	DIAG_LINE_ID		= SAVE_LINE_ID;

end END_FUNCTION_BODY;

/* ---------------------------------------------------------------------
/* BEGIN_BLOCK_BODY
/* ------------------------------------------------------------------- */

BEGIN_BLOCK_BODY: procedure external (X_BEGIN_BLOCK_BODY);

	call BEGIN_BLOCK_SCOPE ();

end BEGIN_BLOCK_BODY;

/* ---------------------------------------------------------------------
/* END_BLOCK_BODY
/* ------------------------------------------------------------------- */

END_BLOCK_BODY: procedure external (X_END_BLOCK_BODY);

	call END_BLOCK_SCOPE ();

end END_BLOCK_BODY;

/* ---------------------------------------------------------------------
/* SET_DECLARATION
/*
/* This routine is called at the end of a global, or function or block
/* scope, non-tag, non-label declaration; class scope, prototype scope,
/* tag, and label declarations are handled elsewhere (SET_MEMBER_DECLARATION,
/* SET_PARAMETER_DECLARATION, and SET_TAG_NAME).  Process the declaration
/* and return with CURRENT_SYMBOL set to the sym-node id of the
/* (new or redeclared) symbol.
/* ------------------------------------------------------------------- */

SET_DECLARATION: procedure external (X_SET_DECLARATION);

	declare
		THIS_KIND			type (LONG_BITS_T),
		THIS_EXTERNAL_LINKAGE		type (BOOL_T),
		THIS_INTERNAL_LINKAGE		type (BOOL_T),
		THIS_FUNCTION_IS_PROTOTYPED	type (BOOL_T),
		USE_PREV_LINKAGE		type (BOOL_T),
		USE_PREV_LINKAGE_KIND		type (BOOL_T),
		PREV_SYMBOL			type (NID_T),
		COMPLETE_SYMBOL			type (BOOL_T),
		STATUS				type (SHORT_T),
		OCM				type (OCM_T),
		P				type (POINTER_T),
		REFER_TO_PREV_SYMBOL		type (BOOL_T),
		SAVE_AND_RESTORE_SCOPE_STATE	type (BOOL_T),
		SAVE_STORAGE_CLASS		type (SHORT_T),
		SAVE_LINKAGE_KIND		type (SHORT_T);

	CURRENT_SYMBOL = NULL_NID;

	/*
	/* If we're in C mode, make sure we are neither within a
	/* for statement initializer, nor past the declaration
	/* section (i.e. if a statement has been seen).
	/**/

	if ^SW_C_PLUS_PLUS then do;
		if ^CURRENTLY_DOING_INTERNAL_PARSE then do;
			if IN_FOR_STATEMENT_INITIALIZER then
				call SEMANTIC_ERROR (ERR_FOR_STMNT_INIT_DCL);
			else if CURRENT_SCOPE_PAST_DECLARATIONS then
				call SEMANTIC_ERROR (ERR_STMNT_PRECEEDS_DCL);
		end;
	end;

	/* Check for a null declarator declaration */

	if CURRENT_NAME = NULL_NID then do;
		call CHECK_NULL_DECLARATOR ();
		return;
	end;

	call RESTORE_DECLARATOR_SCOPE ();

	/* Handle a "typedef" declaration */

	if CURRENT_STORAGE_CLASS = TYPEDEF_ST then do;
		call SET_TYPEDEF_DECLARATION ();
		return;
	end;

	/*
	/* Check for an old-style function definition; the declaration
	/* in this case is delayed until SET_OLD_PARAMETER_LIST.
	/**/

	if CURRENT_OLD_PARAMETERS ^= NULL_NID then do;
		call SAVE_DECLARATION_STATE ();
		return;
	end;

	/* Initialize */

	SAVE_STORAGE_CLASS		= CURRENT_STORAGE_CLASS;
	SAVE_LINKAGE_KIND		= CURRENT_LINKAGE_KIND;
	SAVE_AND_RESTORE_SCOPE_STATE	= FALSE;
	COMPLETE_SYMBOL			= FALSE;
	THIS_FUNCTION_IS_PROTOTYPED	= FALSE;
	OCM				= DEFAULT_OCM;
	REFER_TO_PREV_SYMBOL		= FALSE;

	/* ---------------------------------------------------
	/* Here, we have a declaration which is neither a tag,
	/* member, friend, parameter, label, nor typedef.
	/* ------------------------------------------------- */

	/*
	/* Build a type-node for this declaration from the current
	/* declaration data; SETS CURRENT_TYPE & CURRENT_TOP_TYPE, and
	/* leaves the current declaration specifier and name data intact.
	/**/

	call BUILD_CURRENT_TYPE ();
	if ^AT_FUNCTION_DEFINITION () then
		call FREE_CURRENT_PROTOTYPE_SCOPE ();

	/*
	/* Process the declarator name for this
	/* global/local (non-typedef) declaration.
	/**/

	if ^VALID_DECLARATOR_NAME (VANILLA_DCL) then
		goto ERROR_SET_DECLARATION;

	/* Perform various sanity checks on the base type */

	if ^VALID_BASE_TYPE () then
		goto ERROR_SET_DECLARATION;

	/*
	/* Sanity check the storage class.
	/*
	/* For global scope, it may be anything but "register" or "auto"
	/* (i.e. "extern", "static"; "typedef" was already handled above).
	/* 
	/* For local (function/block) scope it may be anything for
	/* non-function types (if none then assume "auto"); for function
	/* types, only "extern" is allowed; if none then assume "extern".
	/**/

	if (CURRENT_SCOPE_TYPE = GLOBAL_SCOPE) &
	   (CURRENT_STORAGE_CLASS ^= NULL_ST) &
	   (CURRENT_STORAGE_CLASS ^= EXTERN_ST) &
	   (CURRENT_STORAGE_CLASS ^= STATIC_ST) then do;
		call SEMANTIC_ERROR (ERR_BAD_EXTERN_STORAGE);
		CURRENT_STORAGE_CLASS = NULL_ST;
	end;

	if (CURRENT_SCOPE_TYPE = FUNCTION_SCOPE) |
	   (CURRENT_SCOPE_TYPE = BLOCK_SCOPE) then do;
		if CURRENT_TOP_TYPE.CODE = byte (FUNCTION_DT) then do;
			if (CURRENT_STORAGE_CLASS = REGISTER_ST) |
			   (CURRENT_STORAGE_CLASS = AUTO_ST) then
				call SEMANTIC_ERROR (ERR_BAD_FUN_STORAGE);
			else if CURRENT_STORAGE_CLASS = STATIC_ST then do;
				if ^SW_ALLOW_LOCAL_STATIC_FUN_DCL then
					call SEMANTIC_ERROR
						(ERR_STATIC_LOCAL_FUN);
			end;
			CURRENT_STORAGE_CLASS = EXTERN_ST;  /* no */
		end;
		else if CURRENT_STORAGE_CLASS = NULL_ST then
			CURRENT_STORAGE_CLASS = AUTO_ST;  /* no */
	end;

	/* Check out any other specifiers */

	if CURRENT_OVERLOAD then do;
		if CURRENT_TOP_TYPE.CODE ^= byte (FUNCTION_DT) then
			goto ERROR_SET_DECLARATION;
	end;
	if CURRENT_FRIEND then do;
		/*
		/* Error; the "friend" specifier may only
		/* be used within a class definition.
		/**/
		call SEMANTIC_ERROR (ERR_BAD_FRIEND);
		CURRENT_FRIEND = FALSE;
	end;
	if CURRENT_VIRTUAL then do;
		/*
		/* Error; the "virtual" specifier may only
		/* only be used within a class definition
		/* for a member function declaration.
		/**/
		call SEMANTIC_ERROR (ERR_BAD_VIRTUAL);
		CURRENT_VIRTUAL = FALSE;
	end;
	if CURRENT_INLINE then do;
		if CURRENT_TOP_TYPE.CODE ^= byte (FUNCTION_DT) then do;
			/*
			/* Error; the "inline" specifier may only be
			/* used with a non-extern function declaration.
			/**/
			call SEMANTIC_ERROR (ERR_BAD_INLINE);
			CURRENT_INLINE = FALSE;
		end;
		else if (CURRENT_STORAGE_CLASS ^= NULL_ST) &
			(CURRENT_STORAGE_CLASS ^= STATIC_ST) then do;
			/*
			/* Error; the "inline" specifier may only be
			/* used with a non-extern function declaration.
			/**/
			call SEMANTIC_ERROR (ERR_BAD_INLINE);
			CURRENT_INLINE = FALSE;
		end;
	end;

	/* Set pertinent function declaration data */

	if CURRENT_TOP_TYPE.CODE = byte (FUNCTION_DT) then do;
		call GET_SIG_NODE_R (CURRENT_TOP_TYPE.SIGNATURE, P);
		if CURRENT_OLD_FUNCTION_DEFINITION then do;
			/*
			/* We set this about as early as possible, here,
			/* because the compatibility check done here uses it.
			/**/
			P->SIG_NODE.DEFINED_FUNCTION = TRUE;
		end;
		else if P->SIG_NODE.PROTOTYPED then
			THIS_FUNCTION_IS_PROTOTYPED = TRUE;
		call RELEASE_SIG_NODE (CURRENT_TOP_TYPE.SIGNATURE);
	end;

	/* Set the linkage kind */

	USE_PREV_LINKAGE_KIND = FALSE;

	if CURRENT_LINKAGE_KIND = DEFAULT_LINKAGE then do;
		if ((CURRENT_TOP_TYPE.CODE = byte (FUNCTION_DT)) &
		    ^THIS_FUNCTION_IS_PROTOTYPED) |
		   SW_X_OLD_STYLE_FUNCTIONS then do;
			CURRENT_LINKAGE_KIND = C_LINKAGE;
		end;
		else do;
			CURRENT_LINKAGE_KIND  = CXX_LINKAGE;
			USE_PREV_LINKAGE_KIND = TRUE;
		end;
	end;

	/*
	/* Determine the apparent linkage; sanity check with any
	/* previous visible declarations near the end of this
	/* routine (C++ARM, 3.3, 7.1.6, 7.1.1, 7.4).
	/**/

	THIS_INTERNAL_LINKAGE	= FALSE;
	THIS_EXTERNAL_LINKAGE	= FALSE;
	USE_PREV_LINKAGE	= FALSE;

	if CURRENT_INLINE then
		THIS_INTERNAL_LINKAGE = TRUE;

	else if CURRENT_SCOPE_TYPE = GLOBAL_SCOPE then do;
		if CURRENT_STORAGE_CLASS = EXTERN_ST then do;
			USE_PREV_LINKAGE = TRUE;
			THIS_EXTERNAL_LINKAGE = TRUE;
		end;
		else if (CURRENT_STORAGE_CLASS = STATIC_ST) |
			CURRENT_INLINE then do;
			THIS_INTERNAL_LINKAGE = TRUE;
		end;
		else if CURRENT_STORAGE_CLASS = NULL_ST then do;
			if (CURRENT_TOP_TYPE.CODE = byte (FUNCTION_DT)) |
			   ^CURRENT_TOP_TYPE.CONST |
			   CURRENT_NAME_SCOPE ^= NULL_NID |
			   SW_TENTATIVE_DEFN then do;
				THIS_EXTERNAL_LINKAGE = TRUE;
				USE_PREV_LINKAGE = TRUE;
			end;
			else	THIS_INTERNAL_LINKAGE = TRUE;
		end;
	end;
	else do;
		if CURRENT_STORAGE_CLASS = EXTERN_ST then do;
			USE_PREV_LINKAGE = TRUE;
			THIS_EXTERNAL_LINKAGE = TRUE;
		end;
	end;

	/* Check special functions */

	if CURRENT_NAME_KIND = OPERATOR_NK then do;
		if ^VALID_SPECIAL_FUNCTION () then
			goto ERROR_SET_DECLARATION;
	end;

	/* --------------------------------------------
	/* Handle (class/global) scope qualified names.
	/* ------------------------------------------ */

	if CURRENT_NAME_SCOPE ^= NULL_NID then do;
		if CURRENT_STORAGE_CLASS ^= NULL_ST then
			call SEMANTIC_ERROR (ERR_STATIC_MEM_DEF_STORAGE);
		PREV_SYMBOL = SEARCH_SCOPE (CURRENT_NAME_SCOPE,
					    CURRENT_NAME,
					    VANILLA_SK);
		if PREV_SYMBOL = NULL_NID then do;
			call UNDECLARED_MEMBER_ERROR ();
			goto ERROR_SET_DECLARATION;
		end;
		else if SYM_NODE.TOP_TYPE.CODE ^= byte (FUNCTION_DT) then do;
			if ^COMPATIBLE_TYPES
			    (SYM_NODE.TYPE, CURRENT_TYPE) then do;
				/*
				/* Error; this qualified name is not
				/* compatible with any member of the
				/* of the same name of the named class.
				/**/
				call SEMANTIC_ERROR_III
				     (ERR_QUAL_DATA_MEMBER_TYPE,
				      SYMBOL_NAME (PREV_SYMBOL),
				      QUALIFIED_SYMBOL_NAME
				      (CURRENT_NAME_SCOPE_SYMBOL),
				      SYMBOL_LOCATION_NAME (PREV_SYMBOL));
				goto ERROR_SET_DECLARATION;
			end;
			if SYM_NODE.STORAGE_CLASS ^= byte (STATIC_ST) then do;
				/*
				/* Error; data members may not be redeclared
				/* (except to initial static data members).
				/**/
				call SEMANTIC_ERROR (ERR_DATA_MEM_REDCL);
				goto ERROR_SET_DECLARATION;
			end;
			goto COMPLETE_AND_RETURN_THIS_SYMBOL;
		end;
		/*
		/* Here, we are dealing with functions.
		/**/
		PREV_SYMBOL = MATCH_OVERLOAD (PREV_SYMBOL, CURRENT_TYPE);
		if PREV_SYMBOL = NULL_NID then do;
			call SEMANTIC_ERROR_III
			     (ERR_QUAL_MEMBER_FUN_TYPE,
			      SYMBOL_NAME ((CURRENT_NODE_ID)),
			      QUALIFIED_SYMBOL_NAME
			      (CURRENT_NAME_SCOPE_SYMBOL),
			      SYMBOL_LOCATION_NAME ((CURRENT_NODE_ID)));
			goto ERROR_SET_DECLARATION;
		end;
		if AT_END_OF_DECLARATION () then do;
			/*
			/* Error; member functions my not be
			/* redeclared without being defined.
			/**/
			call SEMANTIC_ERROR (ERR_MEM_FUN_REDCL);
		end;
		goto COMPLETE_AND_RETURN_THIS_SYMBOL;
	end;

	/* ------------------------------------------------
	/* Here, we have a file or block scope declaration.
	/* ---------------------------------------------- */

	/*
	/* If we have a block scope "extern" declaration,
	/* see if we want it to really take place at file scope.
	/**/

	if SW_X_EXTERN_SCOPE then do;
		if (CURRENT_STORAGE_CLASS = EXTERN_ST) &
		   (CURRENT_SCOPE_TYPE ^= GLOBAL_SCOPE) then do;
			call SAVE_SCOPE_STATE ();
			call SET_CURRENT_SCOPE (CURRENT_GLOBAL_SCOPE);
			SAVE_AND_RESTORE_SCOPE_STATE = TRUE;
		end;
	end;

	/* Set the appropriate symbol kind */

	if CURRENT_TOP_TYPE.CODE = byte (FUNCTION_DT) then
		THIS_KIND = MAP_FUNCTION_KIND (CURRENT_NAME_KIND);
	else	THIS_KIND = DATA_SK;

	/* See if this name has been previously declared as a non-type */

	PREV_SYMBOL = LOOKUP_NAME_QUIETLY
		      (CURRENT_NAME, VANILLA_SK, CURRENT_SCOPE);

	if PREV_SYMBOL = NULL_NID then do;
		/*
		/* There is no previous visible declaration
		/* of this (non-member) name; declare it.
		/**/
		goto MAKE_AND_INSTALL_THIS_SYMBOL;
	end;
	else if (CURRENT_TOP_TYPE.CODE = byte (FUNCTION_DT)) &
		(SYM_NODE.IS_FUNCTION) then do;
		/*
		/* If the current declaration is a function with no explicit
		/* linkage specifier, then only look at previous declarations
		/* of this name which are either prototyped and/or defined;
		/* i.e. do not look at function declarations which are both
		/* non-prototyped ("C" linkage, obviously) and undefined;
		/* note that this same sort of check needs to be done in
		/* CHECK_OVERLOAD.
		/**/
		if USE_PREV_LINKAGE_KIND then do;
			if (^SYM_NODE.PROTOTYPED) &
			   (^SYM_NODE.DEFINED) &
			   (SYM_NODE.LINKAGE_KIND = byte (C_LINKAGE)) &
			   (SYM_NODE.NEXT_OVERLOAD = NULL_NID) then
				goto OVERLOAD_THIS_SYMBOL;
			else	OCM = NO_OLD_STYLE_UNDEFINED_OCM;
		end;
		/*
		/* If the current declaration is a function with "C" linkage
		/* and is not prototyped and is not a definition, then only
		/* look at a previous "C" linkage declaration (if any); i.e.
		/* do not look at function declarations which are "C++"
		/* linkage (prototyped, obviously) or or defined.
		/**/
		else if (CURRENT_LINKAGE_KIND = C_LINKAGE) &
			(^CURRENT_OLD_FUNCTION_DEFINITION) &
			(^THIS_FUNCTION_IS_PROTOTYPED) then do;
			if SYM_NODE.LINKAGE_KIND ^= byte (C_LINKAGE) then do;
				if SYM_NODE.C_OVERLOAD ^= NULL_NID then do;
					PREV_SYMBOL = SYM_NODE.C_OVERLOAD;
					call SET_SYM_NODE (PREV_SYMBOL);
				end;
				else	goto OVERLOAD_THIS_SYMBOL;
			end;
			else	OCM = ONLY_C_LINKAGE_OCM;
		end;
	end;

	/*
	/* Here, we found a previous non-type declaration of this
	/* name in either this or an enclosing scope; check it out.
	/**/

	if CURRENT_NAME = MAIN_NAME then do;
		if (CURRENT_TOP_TYPE.CODE = byte (FUNCTION_DT)) &
		   (SYM_NODE.TOP_TYPE.CODE = byte (FUNCTION_DT)) then do;
			if COMPATIBLE_TYPES (SYM_NODE.TYPE, CURRENT_TYPE) then
				goto COMPLETE_AND_RETURN_THIS_SYMBOL;
			call SEMANTIC_ERROR (ERR_OVERLOAD_MAIN);
			goto RETURN_THIS_SYMBOL;
		end;
	end;

	if CURRENT_SCOPE_TYPE = GLOBAL_SCOPE then do;
		/*
		/* Here, we have a global scope non-type (i.e. neither
		/* tag nor typedef) declaration of a name which was
		/* already declared (at global scope) as a non-type;
		/* this is ok as long as they declare compatible types,
		/* and specify the same linkage.
		/**/
		if CURRENT_TOP_TYPE.CODE ^= byte (FUNCTION_DT) then do;
			if ^COMPATIBLE_TYPES
			    (SYM_NODE.TYPE, CURRENT_TYPE) then do;
				/*
				/* Error; incompatible redeclaration
				/* of a non-function type.
				/**/
				if ^SW_PRAGMA_WRAPPER_REDECLARATIONS then do;
					call SEMANTIC_ERROR_II
					     (ERR_INCOMPAT_REDCL,
					      SYMBOL_NAME (PREV_SYMBOL),
					      SYMBOL_LOCATION_NAME
					      (PREV_SYMBOL));
				end;
				goto RETURN_THIS_SYMBOL;
			end;
			goto COMPLETE_AND_RETURN_THIS_SYMBOL;
		end;
		STATUS = CHECK_OVERLOAD
			 (PREV_SYMBOL, CURRENT_TYPE, NULL_NID,  OCM);
		if STATUS = DISTINCT_TCS then
			goto OVERLOAD_THIS_SYMBOL;
		else if STATUS ^= COMPATIBLE_TCS then do;
			call FUNCTION_REDECLARATION_ERROR ();
			goto RETURN_THIS_SYMBOL;
		end;
		goto COMPLETE_AND_RETURN_THIS_SYMBOL;
	end;
	else if CURRENT_STORAGE_CLASS = EXTERN_ST then do;
		/*
		/* Here, we have a local scope non-type (i.e. neither tag nor
		/* typedef) "extern" declaration of a name which was previously
		/* declared as non-type in either this or an enclosing scope.
		/**/
		if SYM_NODE.ENCLOSING_SCOPE = CURRENT_SCOPE then do;
			if CURRENT_TOP_TYPE.CODE ^= byte (FUNCTION_DT) then do;
				/*
				/* Error; duplicate declaration at local scope.
				/*
				/* For example:  "f() { int x; extern int x; }"
				/*
				/* XYZZY
				/**/
				call SEMANTIC_ERROR_II
				     (ERR_EXTERN_LOCAL_REDCL,
				      SYMBOL_NAME (PREV_SYMBOL),
				      SYMBOL_LOCATION_NAME (PREV_SYMBOL));
				goto RETURN_THIS_SYMBOL;
			end;
			STATUS = CHECK_OVERLOAD
				 (PREV_SYMBOL, CURRENT_TYPE, NULL_NID,  OCM);
			if STATUS = DISTINCT_TCS then
				goto OVERLOAD_THIS_SYMBOL;
			else if STATUS ^= COMPATIBLE_TCS then do;
				call FUNCTION_REDECLARATION_ERROR ();
				goto RETURN_THIS_SYMBOL;
			end;
			goto COMPLETE_AND_RETURN_THIS_SYMBOL;
		end;
		/*
		/* Now, see if we have a previous global scope declaration
		/* of this local scope name (i.e. to which this "extern"
		/* declaration refers).
		/**/
		if SYM_NODE.ENCLOSING_SCOPE_TYPE ^= byte (GLOBAL_SCOPE) then
			PREV_SYMBOL = SEARCH_SCOPE (CURRENT_GLOBAL_SCOPE,
						    CURRENT_NAME,
						    VANILLA_SK);
		if PREV_SYMBOL = NULL_NID then
			goto MAKE_AND_INSTALL_THIS_SYMBOL;
		/*
		/* Here, we have a local scope non-type (i.e.  neither tag
		/* nor typedef) "extern" declaration of a name which was
		/* previously declared at global scope; this is ok as long
		/* as they declare compatible types.
		/**/
		if CURRENT_TOP_TYPE.CODE ^= byte (FUNCTION_DT) then do;
			if ^COMPATIBLE_TYPES
			    (SYM_NODE.TYPE, CURRENT_TYPE) then do;
				if ^SW_PRAGMA_WRAPPER_REDECLARATIONS then do;
					call SEMANTIC_ERROR_II
					     (ERR_INCOMPAT_REDCL,
					      SYMBOL_NAME (PREV_SYMBOL),
					      SYMBOL_LOCATION_NAME
					      (PREV_SYMBOL));
				end;
				goto RETURN_THIS_SYMBOL;
			end;
			goto COMPLETE_AND_RETURN_THIS_SYMBOL;
		end;
		else if ((SYM_NODE.LINKAGE_KIND ^= byte (CXX_LINKAGE)) |
			 (SYM_NODE.C_OVERLOAD ^= NULL_NID)) &
			((CURRENT_LINKAGE_KIND ^= CXX_LINKAGE) |
			 (USE_PREV_LINKAGE_KIND)) then do;
			if SYM_NODE.C_OVERLOAD ^= NULL_NID then do;
				PREV_SYMBOL = SYM_NODE.C_OVERLOAD;
				call SET_SYM_NODE (PREV_SYMBOL);
			end;
			if ^COMPATIBLE_TYPES
			    (SYM_NODE.TYPE, CURRENT_TYPE) then do;
				/*
				/* Error; for example:
				/*
				/* extern int f ();
				/* extern "C" int f (int);
				/* extern "C" {
				/* a () { extern int f (int, int); } }
				/**/
				call FUNCTION_REDECLARATION_ERROR ();
				goto RETURN_THIS_SYMBOL;
			end;
			/*
			/* I'm not sure how the following is should work:
			/*
			/*    extern int f (int (*)[]);
			/*    a () { extern int f (int (*)[3]); }
			/*    extern int f (int (*)[4]);
			/*
			/* I will assume that the local declaration of "f"
			/* *does* complete the first extern declaration.
			/*
			/* goto COMPLETE_AND_RETURN_THIS_SYMBOL;
			/*
			/* No, see ANSI X3.159-1989, 3.1.2.6:
			/*
			/* "For an identifier with external or internal
			/*  linkage declared in the *same* scope as another
			/*  declaration for that idenifier, the type of
			/*  the identifier becomes the compiosite type."
			/**/
			goto MAKE_AND_INSTALL_THIS_SYMBOL_BUT;
		end;
		STATUS = CHECK_OVERLOAD
			 (PREV_SYMBOL, CURRENT_TYPE, NULL_NID, OCM);
		if STATUS = NOT_DISTINCT_TCS then do;
			/*
			/* Error; incompatible function redeclaration.
			/**/
			call FUNCTION_REDECLARATION_ERROR ();
			goto MAKE_AND_INSTALL_THIS_SYMBOL;
		end;
		else if STATUS = DISTINCT_TCS then do;
			/*
			/* Check for:
			/* int f (); extern "C" { g () { int f (int); } }
			/**/
			goto MAKE_AND_INSTALL_THIS_SYMBOL;
		end;
		/*
		/* See above.
		/*
		/* goto COMPLETE_AND_RETURN_THIS_SYMBOL;
		/***/
		goto MAKE_AND_INSTALL_THIS_SYMBOL_BUT;
	end;
	/*
	/* Here, we have a local scope non-type (i.e. neither tag
	/* nor typedef) automatic or static declaration of a name
	/* which was already declared in either this scope (in
	/* which case it is an error) or in an enclosing scope (ok).
	/**/
	else if SYM_NODE.ENCLOSING_SCOPE = CURRENT_SCOPE then do;
		if SYM_NODE.IS_PARAMETER then do;
			/*
			/* Error; this declaration hides a
			/* parameter declaration of the same name.
			/**/
			if SW_ALLOW_PARAMETER_NAME_HIDING then do;
				/*
				/* Allow parameter name hiding with a
				/* warning; cfront allows this (probably
				/* by accident) and InterViews 3.0 actually
				/* uses this misfeature.
				/**/
				call SEMANTIC_ERROR_I
				     (ERR_HIDE_PARAM_WARN,
				      TOKEN_NAME (CURRENT_NAME));
				if SYM_NODE.REFERENCED then do;
					call CHANGE_SYMBOL_NAME
					     ((CURRENT_NODE_ID),
					      (NODE_PTR),
					      FORM_IDENTIFIER_TOKEN
					      ('____lpi_cxx_hidden_' ||
					       TOKEN_NAME (SYM_NODE.NAME)));
				end;
				else do;
					call CHANGE_SYMBOL_NAME
					     ((CURRENT_NODE_ID),
					      (NODE_PTR),
					      NULL_NID);
				end;
				goto MAKE_AND_INSTALL_THIS_SYMBOL;
			end;
			else	call SEMANTIC_ERROR_I
				     (ERR_HIDE_PARAM,
				      TOKEN_NAME (CURRENT_NAME));
		end;
		else if (CURRENT_TOP_TYPE.CODE ^= byte (FUNCTION_DT)) &
			 SYM_NODE.DEFINED & ^SW_TENTATIVE_DEFN then do;
			/*
			/* Error; diagnosed later as redefinition.
			/**/
			;
		end;
		else do;
			/*
			/* Error; this name has been previously
			/* declared in this (local) scope.
			/**/
			call SEMANTIC_ERROR_II
			     (ERR_LOCAL_REDCL,
			      SYMBOL_NAME (PREV_SYMBOL),
			      SYMBOL_LOCATION_NAME (PREV_SYMBOL));
		end;
		goto RETURN_THIS_SYMBOL;
	end;

	goto MAKE_AND_INSTALL_THIS_SYMBOL;

	/* ----------------------------------------------------------
	/* Make and install a new sym-node, but make it actually
	/* refer to PREV_SYMBOL.  This so that local scope "extern"
	/* declarations get there own symbol but refer to one global
	/* version of that entity if it exists.
	/* -------------------------------------------------------- */

	MAKE_AND_INSTALL_THIS_SYMBOL_BUT:

	REFER_TO_PREV_SYMBOL = TRUE;

	/* --------------------------------
	/* Make and install a new sym-node.
	/* ------------------------------ */

	MAKE_AND_INSTALL_THIS_SYMBOL:

	/*
	/* Here, no previously visible declaration of this name was
	/* found; make a symbol and install it, but first check out
	/* non-visible external linkage declarations.
	/**/

	if CURRENT_TOP_TYPE.CODE = byte (FUNCTION_DT) then do;
		if CURRENT_NAME = MAIN_NAME then
			call CHECK_MAIN_DECLARATION ();
		call CHECK_QUALIFIED_SIGNATURE (CURRENT_TOP_TYPE);
	end;

	CURRENT_SYMBOL = BUILD_SYMBOL (THIS_KIND);
	if SYM_NODE.IS_FUNCTION then do;
		SYM_NODE.PROTOTYPED = THIS_FUNCTION_IS_PROTOTYPED;
		if CURRENT_NAME = MAIN_NAME then do;
			SYM_NODE.MAIN_FUNCTION	= TRUE;
			SW_MAIN_MODULE		= TRUE;
		end;
	end;
	SYM_NODE.EXTERNAL_LINKAGE = THIS_EXTERNAL_LINKAGE;
	SYM_NODE.INTERNAL_LINKAGE = THIS_INTERNAL_LINKAGE;
	if ^USE_PREV_LINKAGE_KIND then
		SYM_NODE.LINKAGE_KIND_SPECIFIED = TRUE;
	if THIS_EXTERNAL_LINKAGE | THIS_INTERNAL_LINKAGE then do;
		call CHECK_NON_VISIBLE_DECLARATIONS ();
		call SET_CURRENT_DATA_SECTION ();
	end;
	call INSTALL_SYMBOL (CURRENT_SYMBOL, CURRENT_SCOPE);
	if  REFER_TO_PREV_SYMBOL &
	   (SYM_NODE.FIRST_EXTERNAL_LINKAGE_SYMBOL = NULL_NID) then
		SYM_NODE.FIRST_EXTERNAL_LINKAGE_SYMBOL = PREV_SYMBOL;
	goto DONE_SET_DECLARATION;

	/* -----------------------------------------------------------
	/* Overload the symbol represented by the current sym-node id.
	/* --------------------------------------------------------- */

	OVERLOAD_THIS_SYMBOL:

	if ^SW_C_PLUS_PLUS then do;
		/*
		/* Error; incompatible redeclaration.
		/**/
		if ^SW_ALLOW_ASM then do;
			call FUNCTION_REDECLARATION_ERROR ();
			goto RETURN_THIS_SYMBOL;
		end;
	end;
	else if CURRENT_LINKAGE_KIND ^= CXX_LINKAGE then do;
		if SYM_NODE.C_OVERLOAD ^= NULL_NID then do;
			if (THIS_INTERNAL_LINKAGE |
			    SYM_NODE.INTERNAL_LINKAGE) &
			   IN_C_HEADER_MODE () then do;
				/*
				/* In C-header mode, allow overloading a set
				/* of internal linkage (e.g. inline) functions.
				/* Came up in SCO 3.2.4 system headers.
				/* (128).
				/**/
				if SYM_NODE.C_OVERLOAD = CURRENT_NODE_ID then
					goto REALLY_OVERLOAD_THIS_SYMBOL;
				call GET_SYM_NODE_R (SYM_NODE.C_OVERLOAD, P);
				if P->SYM_NODE.INTERNAL_LINKAGE then do;
					call RELEASE_SYM_NODE
					     (SYM_NODE.C_OVERLOAD);
					goto REALLY_OVERLOAD_THIS_SYMBOL;
				end;
				else if THIS_INTERNAL_LINKAGE &
					SYM_NODE.INTERNAL_LINKAGE then do;
					call RELEASE_SYM_NODE
					     (SYM_NODE.C_OVERLOAD);
					goto REALLY_OVERLOAD_THIS_SYMBOL;
				end;
				call RELEASE_SYM_NODE (SYM_NODE.C_OVERLOAD);
			end;
			/*
			/* Error; at most, one of a set of overloaded functions
			/* can be specified with "C" linkage (C++ARM, 7.4).
			/**/
			if ^SW_PRAGMA_WRAPPER_REDECLARATIONS then do;
				call SEMANTIC_ERROR_II
				     (ERR_MULTIPLE_C_LINKAGE_OVERLOAD,
				      SYMBOL_NAME (SYM_NODE.C_OVERLOAD),
				      SYMBOL_LOCATION_NAME
				      (SYM_NODE.C_OVERLOAD));
			end;
			goto RETURN_THIS_SYMBOL;
		end;
		else if SYM_NODE.LINKAGE_KIND ^= byte (CXX_LINKAGE) then do;
			/*
			/* Error; at most, one of a set of overloaded functions
			/* can be specified with "C" linkage (C++ARM, 7.4).
			/**/
			if ^SW_PRAGMA_WRAPPER_REDECLARATIONS then do;
				call SEMANTIC_ERROR_II
				     (ERR_MULTIPLE_C_LINKAGE_OVERLOAD,
				      SYMBOL_NAME (PREV_SYMBOL),
				      SYMBOL_LOCATION_NAME (PREV_SYMBOL));
			end;
			goto RETURN_THIS_SYMBOL;
		end;
	end;
	REALLY_OVERLOAD_THIS_SYMBOL:
	CURRENT_SYMBOL = BUILD_SYMBOL (THIS_KIND);
	if SYM_NODE.IS_FUNCTION then
		SYM_NODE.PROTOTYPED = THIS_FUNCTION_IS_PROTOTYPED;
	SYM_NODE.EXTERNAL_LINKAGE = THIS_EXTERNAL_LINKAGE;
	SYM_NODE.INTERNAL_LINKAGE = THIS_INTERNAL_LINKAGE;
	if ^USE_PREV_LINKAGE_KIND then
		SYM_NODE.LINKAGE_KIND_SPECIFIED = TRUE;
	if THIS_EXTERNAL_LINKAGE | THIS_INTERNAL_LINKAGE then
		call CHECK_NON_VISIBLE_DECLARATIONS ();
	call OVERLOAD_SYMBOL (PREV_SYMBOL, CURRENT_SYMBOL);
	goto DONE_SET_DECLARATION;

	/* -----------------------------------------------------------
	/* Complete the symbol represented by the current sym-node id
	/* with the type represented by the type-node id CURRENT_TYPE,
	/* and return the symbol.
	/* --------------------------------------------------------- */

	COMPLETE_AND_RETURN_THIS_SYMBOL:

	COMPLETE_SYMBOL = TRUE;

	/* ---------------------------------------------------------
	/* Return the symbol represented by the current sym-node id.
	/* ------------------------------------------------------- */

	RETURN_THIS_SYMBOL:

	/*
	/* Here, the currently paged in symbol represents a previous visible
	/* non-overloaded compatible declaration; we just need to setup/check
	/* the linkage.  If the current declaration prefers the previous
	/* linkage data, then do nothing.  Otherwise, check for errors.
	/**/

	CURRENT_SYMBOL = CURRENT_NODE_ID;

	if USE_PREV_LINKAGE then
		;
	else if SYM_NODE.EXTERNAL_LINKAGE & THIS_INTERNAL_LINKAGE then do;
		if SYM_NODE.IS_MEMBER & SYM_NODE.IS_FUNCTION then
			SYM_NODE.INLINE = CURRENT_INLINE;
		else if CURRENT_STORAGE_CLASS = STATIC_ST then do;
			/*
			/* Error; this identifier was previously declared
			/* with external linkage, and is thus in conflict
			/* with this internal linkage declaration.
			/**/
			if ^SW_NOWARN_EXTERN_INTERN_CONFLICT then do;
				if ^SW_NOWARN_EXTERN_INLINE_CONFLICT then do;
					call SEMANTIC_ERROR_II
					     (ERR_LINKAGE_CONFLICT,
					      FULL_QUALIFIED_SYMBOL_NAME
					      (CURRENT_SYMBOL),
					      SYMBOL_LOCATION_NAME
					      (CURRENT_SYMBOL));
				end;
			end;
			SYM_NODE.STORAGE_CLASS = byte (STATIC_ST);
		end;
		SYM_NODE.EXTERNAL_LINKAGE = FALSE;
		SYM_NODE.INTERNAL_LINKAGE = TRUE;
	end;

	if USE_PREV_LINKAGE_KIND then
		;
	else if SYM_NODE.LINKAGE_KIND ^= byte (CURRENT_LINKAGE_KIND) then do;
		/*
		/* Error; this name has been previously declared
		/* with a different linkage specification.
		/**/
		call SEMANTIC_ERROR_II
		     (ERR_LINKAGE_KIND_CONFLICT,
		      FULL_QUALIFIED_SYMBOL_NAME (CURRENT_SYMBOL),
		      SYMBOL_LOCATION_NAME (CURRENT_SYMBOL));
	end;
	else if ^SYM_NODE.LINKAGE_KIND_SPECIFIED then do;
		/*
		/* Error; a function declaration without a linkage
		/* specification may not precede the first linkage
		/* specification for that function (C++ARM, 7.4).
		/*
		/*   extern void f (int);
		/*   extern "C++" void f (int);
		/**/
		if SYM_NODE.LINKAGE_KIND = byte (CXX_LINKAGE) then do;
			call SEMANTIC_ERROR_II
			     (ERR_MISSING_PREV_LINKAGE_KIND,
			      FULL_SYMBOL_NAME (CURRENT_SYMBOL),
			      SYMBOL_LOCATION_NAME (CURRENT_SYMBOL));
		end;
	end;

	if COMPLETE_SYMBOL then
		call COMPLETE_CURRENT_DECLARATION ();

	/* Check for alternate data sections */

	if  SYM_NODE.IS_DATA &
	   (SYM_NODE.EXTERNAL_LINKAGE | SYM_NODE.INTERNAL_LINKAGE) then do;
		if CURRENT_DATA_SECTION ^= NULL_NID then do;
			if (SYM_NODE.DATA_SECTION ^= CURRENT_DATA_SECTION) &
			   (SYM_NODE.DATA_SECTION ^= NULL_NID) then do;
				call SEMANTIC_ERROR_IIII
				     (ERR_INCOMPAT_REDCL_DATASEC,
				      QUALIFIED_SYMBOL_NAME (CURRENT_SYMBOL),
				      SYMBOL_LOCATION_NAME (CURRENT_SYMBOL),
				      DATA_SECTION_NAME (SYM_NODE.DATA_SECTION),
				      DATA_SECTION_NAME (CURRENT_DATA_SECTION));
			end;
		end;
	end;

	/* Done */

	DONE_SET_DECLARATION:
	ERROR_SET_DECLARATION:
	CURRENT_STORAGE_CLASS = SAVE_STORAGE_CLASS;
	CURRENT_LINKAGE_KIND  = SAVE_LINKAGE_KIND;
	if SAVE_AND_RESTORE_SCOPE_STATE then
		call RESTORE_SCOPE_STATE ();
	return;

/* ---------------------------------------------------------------------
/* FUNCTION_REDECLARATION_ERROR
/*
/* Assuming that the function symbol represented by the currently paged
/* in sym-node is being incompatibly redeclared with a type represented
/* by the type-node id CURRENT_TYPE and associated type-data CURRENT_TOP
/* _TYPE, give an appropriate redeclaration diagnostic message.
/* ------------------------------------------------------------------- */

FUNCTION_REDECLARATION_ERROR: procedure internal;

	declare
		(P, Q)		type (POINTER_T),
		ERROR_CODE	type (SHORT_T);

	if SW_PRAGMA_WRAPPER_REDECLARATIONS then
		return;

	if SYM_NODE.TOP_TYPE.CODE ^= byte (FUNCTION_DT) then do;
		if CURRENT_TOP_TYPE.CODE ^= byte (FUNCTION_DT) then
			call SEMANTIC_ERROR_II
			     (ERR_INCOMPAT_REDCL,
			      SYMBOL_NAME ((CURRENT_NODE_ID)),
			      SYMBOL_LOCATION_NAME ((CURRENT_NODE_ID)));
		else	call SEMANTIC_ERROR_II
			     (ERR_INCOMPAT_NON_FUN_FUN_REDCL,
			      SYMBOL_NAME ((CURRENT_NODE_ID)),
			      SYMBOL_LOCATION_NAME ((CURRENT_NODE_ID)));
		return;
	end;
	else if CURRENT_TOP_TYPE.CODE ^= byte (FUNCTION_DT) then do;
		call SEMANTIC_ERROR_II
		     (ERR_INCOMPAT_FUN_NON_FUN_REDCL,
		      SYMBOL_NAME ((CURRENT_NODE_ID)),
		      SYMBOL_LOCATION_NAME ((CURRENT_NODE_ID)));
		return;
	end;

	call GET_SIG_NODE_R (SYM_NODE.TOP_TYPE.SIGNATURE, P);
	call GET_SIG_NODE_R (CURRENT_TOP_TYPE.SIGNATURE, Q);

	if P->SIG_NODE.PROTOTYPED = Q->SIG_NODE.PROTOTYPED then do;
		/*
		/* Here, we have an incompatible redeclaration of
		/* of a function; the previous and current declarations
		/* are either both prototyped or both non-prototyped.
		/*
 		/* Error; this function F has been previously declared on
		/* line N with a type that is neither compatible with, nor
		/* sufficiently distinct from, the type of this declaration.
		/**/
		if SW_C_PLUS_PLUS then
			ERROR_CODE = ERR_REDCL_FUN;
		else	ERROR_CODE = ERR_SIMPLE_REDCL_FUN;
	end;

	/*
	/* Here, we have an incompatible redeclaration of a function;
	/* either the previous declaration is prototyped and the current
	/* one is not or the previous declaration is not prototyped and
	/* the current one is.  We want explicitly check for cases which
	/* are not at all obvious, i.e. those outlined in ANSI-C, 3.5.4.3:
	/*
	/*    void f (char);
	/*    void f (c) char c; { }  /* incompatible redeclaration! */
	/*
	/* Note that we will not currently give a special diagnostic for:
	/*
	/*    void f (char);
	/*    void f ();             /* illegal if -ansic mode */
	/**/

	else if ^COMPATIBLE_PROTOTYPED_TYPES
		 (SYM_NODE.TYPE, CURRENT_TYPE) then do;
		/*
		/* Same diagnostic as above.
		/**/
		if P->SIG_NODE.PROTOTYPED then
			ERROR_CODE = ERR_SIMPLE_REDCL_OLD_FUN;
		else if Q->SIG_NODE.PROTOTYPED then
			ERROR_CODE = ERR_SIMPLE_REDCL_NEW_FUN;
	end;

	/*
	/* Here, we have an incompatible redeclaration of a function
	/* due to a prototyped vs. non-prototyped unpromoted parameter
	/* type conflict (ANSI-C, 3.5.4.3).
	/**/

	else if P->SIG_NODE.PROTOTYPED then do;
		/*
		/* Error; this old-style function was previously declared
		/* on line N with an incompatible type; the type of each
		/* prototype parameter must be compatible with the promoted
		/* type of the corresponding old-style parameter.
		/**/
		ERROR_CODE = ERR_REDCL_OLD_FUN;
	end;
	else do;
		/*
		/* Error; this function was previously declared on line N
		/* as an old-style function with an incompatible type; the
		/* type of each prototype parameter must be compatible with
		/* the promoted type of the corresponding old-style parameter.
		/**/
		ERROR_CODE = ERR_REDCL_NEW_FUN;
	end;

	call SEMANTIC_ERROR_II
	     (ERROR_CODE,
	      FULL_SYMBOL_NAME ((CURRENT_NODE_ID)),
	      SYMBOL_LOCATION_NAME ((CURRENT_NODE_ID)));

	USE_PREV_LINKAGE = TRUE;	/* To prevent spurious error */
	USE_PREV_LINKAGE_KIND = TRUE;	/* To prevent spurious error */

	call RELEASE_SIG_NODE (SYM_NODE.TOP_TYPE.SIGNATURE);
	call RELEASE_SIG_NODE (CURRENT_TOP_TYPE.SIGNATURE);

end FUNCTION_REDECLARATION_ERROR;

end SET_DECLARATION;

/* ---------------------------------------------------------------------
/* SET_TYPEDEF_DECLARATION
/* ------------------------------------------------------------------- */

SET_TYPEDEF_DECLARATION: procedure internal;

	declare
		THIS_SYMBOL		type (NID_T),
		THIS_SCOPE		type (NID_T),
		PREV_SYMBOL		type (NID_T),
		THIS_KIND		type (LONG_BITS_T),
		P			type (POINTER_T);

	if   CURRENT_NAME_SCOPE_SYMBOL ^= NULL_NID
	   & ( SW_ALLOW_MEMBER_FUN_REF_TYPE
	     | CURRENT_SCOPE_TYPE = GLOBAL_SCOPE ) then do;
		/*
		/* Handle the cfront member-function-reference
		/* typedef extension; yuck.
		/*
		/*   struct A *ap;
		/*   typedef void A::T();
		/*   T *mp; // Same as: void (A::*mp)();
		/**/
		if TOP_DERIVED_TYPE
		   (CURRENT_DERIVED_TYPE_LEVEL) = FUNCTION_DT then do;
			if ^SW_ALLOW_MEMBER_FUN_REF_TYPE then
				call SEMANTIC_ERROR (ERR_DCL_MEMBER_FUN_REF);
			else if SW_WARN_MEMBER_FUN_REF_TYPE then
				call SEMANTIC_ERROR (ERR_WARN_MEMBER_FUN_REF);
			call SET_MEMBER_REFERENCE_TYPE ();
			call CLEAR_SCOPE_QUALIFIER ();
		end;
	end;
	/*
	/* Build a type-node for this typedef declaration from the current
	/* declaration data; sets CURRENT_TYPE & CURRENT_TOP_TYPE, and
	/* leaves the current declaration specifier and name data intact.
	/**/

	call BUILD_CURRENT_TYPEDEF_TYPE ();
	call FREE_CURRENT_PROTOTYPE_SCOPE ();

	/* Process the declarator name for this typedef declaration */

	if CURRENT_NAME_KIND ^= VANILLA_NK then do;
		/*
		/* Error; a "typedef" declaration must
		/* declare a vanilla name.
		/**/
		call SEMANTIC_ERROR (ERR_TYPEDEF_NAME);
		goto ERROR_SET_TYPEDEF_DECLARATION;
	end;
	else if (CURRENT_SCOPE_TYPE = CLASS_SCOPE) & ^CURRENT_FRIEND then do;
		if ^VALID_DECLARATOR_NAME (MEMBER_DCL) then
			goto ERROR_SET_TYPEDEF_DECLARATION;
	end;
	else do;
		if ^VALID_DECLARATOR_NAME (VANILLA_DCL) then
			goto ERROR_SET_TYPEDEF_DECLARATION;
	end;

	/* Perform various sanity checks on the base type */

	if ^VALID_BASE_TYPE () then
		goto ERROR_SET_TYPEDEF_DECLARATION;

	/* Check the other specifiers */

	if CURRENT_FRIEND  | CURRENT_INLINE |
	   CURRENT_VIRTUAL | CURRENT_OVERLOAD then do;
		/*
		/* Error; a "typedef" declaration may not contain any
		/* "friend", "virtual", "inline", or "overload" specifiers.
		/**/
		call SEMANTIC_ERROR (ERR_TYPEDEF_SPEC);
		CURRENT_FRIEND   = FALSE;
		CURRENT_OVERLOAD = FALSE;
		CURRENT_INLINE   = FALSE;
		CURRENT_VIRTUAL  = FALSE;
	end;
	if CURRENT_SCOPE_TYPE = CLASS_SCOPE then do;
		/*
		/* Here, we have a typedef declaration in a class.
		/**/
		if CURRENT_BIT_FIELD >= 0 then do;
			/*
			/* Error; a "typedef" declaration may not
			/* be specified as a bit-field; ignored.
			/**/
			call SEMANTIC_ERROR (ERR_TYPEDEF_BIT_FIELD);
		end;
		else if ^SW_C_PLUS_PLUS then do;
			/*
			/* Error; a "typedef" declaration may not
			/* be specified used within a struct/union
			/* in ANSI C mode.
			/**/
			call SEMANTIC_ERROR (ERR_NO_TYPEDEF_MEMBER);
		end;
	end;

	/* Set the appropriate symbol kind */

	THIS_KIND = TYPE_SK;

	/*
	/* Determine the scope in which this "typedef" wants to live.
	/* I'm not really sure what to do with this case; it's only
	/* an issue in ANSI-C compatibility mode when nested types
	/* are not supported (i.e. SW_NO_NESTED_TYPE_NAMES).
	/*
	/*	void f (struct S { typedef float T; } a);
	/*
	/*	T x;   // ok ? see old C++RM, sec.9.7, page 62.
	/*	S y;   // error; S not visible.
	/**/

	if SW_NO_NESTED_TYPE_NAMES then
		THIS_SCOPE = CURRENT_NON_CLASS_SCOPE;

	/*
	/* If this typedef is nested within a class, then make sure it
	/* doesn't have the same name is its enclosing class tag name
	/* (C++ARM, 9.2); e.g. "class A { typedef int A; };".
	/**/

	else if CURRENT_SCOPE_TYPE = CLASS_SCOPE then do;
		if (CURRENT_NAME = CURRENT_CLASS_NAME) &
		   ^SW_NO_NESTED_TYPE_NAMES then do;
			/*
			/* Error; a nested typedef name may not have the
			/* same name as its enclosing class (C++ARM, 9.2).
			/**/
			call SEMANTIC_ERROR_I (ERR_MEMBER_NAME,
					       TOKEN_NAME (CURRENT_NAME));
		end;
		THIS_SCOPE = CURRENT_SCOPE;
		THIS_KIND = THIS_KIND | MAP_MEMBER_KIND (CURRENT_CLASS_TYPE);
		call GET_SYM_NODE_R (CURRENT_CLASS, P);
		if P->SYM_NODE.IS_ANON_UNION_TAG then
			THIS_KIND = THIS_KIND | ANON_UNION_MEMBER_SK;
		call RELEASE_SYM_NODE (CURRENT_CLASS);
	end;

	else	THIS_SCOPE = CURRENT_SCOPE;

	/* See if this name has been previously declared in this scope */

	PREV_SYMBOL = SEARCH_SCOPE (THIS_SCOPE, CURRENT_NAME, ANY_SK);

	if PREV_SYMBOL = NULL_NID then
		goto MAKE_AND_INSTALL_THIS_SYMBOL;

	if ^SYM_NODE.IS_TYPE then do;
		/*
		/* Error; this "typedef" name was previously
		/* declared in this scope as a non-type.
		/**/
		call SEMANTIC_ERROR_II
		     (ERR_NON_TYPE_TYPEDEF_REDCL,
		      SYMBOL_NAME (PREV_SYMBOL),
		      SYMBOL_LOCATION_NAME (PREV_SYMBOL));
		goto ERROR_SET_TYPEDEF_DECLARATION;
	end;

	/*
	/* Here, this name was previously declared in the
	/* same scope as a type-name (tag or typedef); make
	/* sure that they define the same type.  For example:
	/*
	/* "typedef char a; typedef char a;" (legal), or
	/* "typedef char a; typedef long a;" (illegal), or
	/* "struct S { ... }; typedef struct s s;" (legal), or
	/* "class T { typedef int T; };" (illegal), or
	/* "class T { typedef T T; };" (legal).
	/*
	/* N.B. Much to my surprise, ANSI-C (sec.3.5) says that
	/* redeclaring typedef names is illegal.  I do not believe
	/* this; it may be a bug in the Standard, so I will not give
	/* an error.  If I change my mind, then I'll simply give a
	/* warning/error at this point and continue.  DGM, 2.6.91.
	/*
	/* Well, I've decided to give a violation for this.  4.30.92.
	/**/

	if ^COMPATIBLE_TYPES (SYM_NODE.TYPE, CURRENT_TYPE) then do;
		if ^SW_PRAGMA_WRAPPER_REDECLARATIONS then do;
			if SYM_NODE.IS_TAG then
				call SEMANTIC_ERROR_II
				     (ERR_TAG_TYPEDEF_REDEF,
				      SYMBOL_NAME (PREV_SYMBOL),
				      SYMBOL_LOCATION_NAME (PREV_SYMBOL));
			else	call SEMANTIC_ERROR_II
				     (ERR_TYPEDEF_TYPEDEF_REDEF,
				      SYMBOL_NAME (PREV_SYMBOL),
				     SYMBOL_LOCATION_NAME (PREV_SYMBOL));
		end;
		goto ERROR_SET_TYPEDEF_DECLARATION;
	end;
	else if SW_WARN_FOR_MULTIPLE_TYPEDEFS then do;
		call SEMANTIC_ERROR_II
		     (ERR_DUP_TYPEDEF_DCL,
		      SYMBOL_NAME (PREV_SYMBOL),
		      SYMBOL_LOCATION_NAME (PREV_SYMBOL));
	end;

	if ^SYM_NODE.IS_TAG then do;
		call COMPLETE_CURRENT_DECLARATION ();
		THIS_SYMBOL = PREV_SYMBOL;
		goto RETURN_THIS_SYMBOL;
	end;

	/* ---------------------------------------------------
	/* Make a new sym-node for this "typedef" declaration.
	/* ------------------------------------------------- */

	MAKE_AND_INSTALL_THIS_SYMBOL:

	/*
	/* If this "typedef" declaration is simply creating a synonym
	/* for an unnamed class, then set name of the unnamed class to
	/* the "typedef" name (C++ARM, 7.1.3).  E.g:
	/*
	/*     typedef class { void f (); } T;
	/*
	/* This is really sort of screwy, what about cases like this?
	/*
	/*     typedef class { void f (); } T, U, V;
	/*
	/* Can we say "class T x" ?  (probably not; we allow it).
	/* Can we say "class U x" ?  (probably not; we disallow it).
	/* Can we say "T::f" ?  (probably; we allow it).
	/* Can we say "U::f" ?  (probably; we allow it).
	/**/

	/*
	/* Note that this will not cause a duplicate name to be
	/* placed in the symbol table since the class name will
	/* not be properly registered in the symbol table.
	/**/

	if IS_TAG_TYPE (rank (CURRENT_TOP_TYPE.CODE)) then do;
		call SET_SYM_NODE (CURRENT_BASE_TYPE_ID);
		if SYM_NODE.NAME = NULL_NID then
			SYM_NODE.NAME = CURRENT_NAME;
	end;

	/* Make a new typedef sym-node */

	THIS_SYMBOL = BUILD_SYMBOL (THIS_KIND);

	if SW_NO_NESTED_TYPE_NAMES then
		SYM_NODE.ENCLOSING_CLASS = CURRENT_CLASS;

	/* Link this symbol into the symbol table of the current scope */

	call INSTALL_SYMBOL (THIS_SYMBOL, THIS_SCOPE);

	/* Return with CURRENT_SYMBOL set to this symbol */

	RETURN_THIS_SYMBOL:
	CURRENT_SYMBOL = THIS_SYMBOL;
	return;

	/* Error */

	ERROR_SET_TYPEDEF_DECLARATION:
	CURRENT_SYMBOL = NULL_NID;
	return;

end SET_TYPEDEF_DECLARATION;

/* ---------------------------------------------------------------------
/* SET_TYPE_DECLARATION
/* ------------------------------------------------------------------- */

SET_TYPE_DECLARATION: procedure external (X_SET_TYPE_DECLARATION);

	/*
	/* Build a type-node for this (cast) declaration from the current
	/* declaration data; sets CURRENT_TYPE & CURRENT_TOP_TYPE, and
	/* leaves the current declaration specifier and name data intact.
	/**/

	call BUILD_CURRENT_NEW_TYPE ();

end SET_TYPE_DECLARATION;

/* ---------------------------------------------------------------------
/* BUILD_SYMBOL
/*
/* Allocate and initialize a new sym-node for the given KIND of
/* symbol.  Initializes current declaration specifier, name, and
/* line/file data according to the current (global) values; all
/* other data is initialized to the appropriate null values.
/* Set CURRENT_SYMBOL to the new sym-node id and leave it paged in.
/* ------------------------------------------------------------------- */

BUILD_SYMBOL: procedure (KIND) returns (type (NID_T))
	      external (X_BUILD_SYMBOL);

	declare
		KIND		type (LONG_BITS_T);
	declare
		SIZE_UNITS	type (SHORT_T),
		BOUNDARY	type (SHORT_T),
		P		type (POINTER_T);

	/* Allocate a sym-node */

	CURRENT_SYMBOL = MAKE_SYM_NODE (KIND);

	/*
	/* Performance haque; if this symbol is a type, then set the
	/* DTYPE field of the TOKEN_NODE associated with the the name
	/* of the symbol to 1.  This is intended to indicate (to the
	/* parser) that the given name does indeed exist *somewhere*
	/* as a type-name, i.e. so that lookup can be avoided quickly
	/* if the name does not exist *anywhere* as a type-name.
	/*
	/* ...

	if SYM_NODE.IS_TYPE then do;
		if CURRENT_NAME ^= NULL_NID then do;
			call GET_TOKEN_NODE (CURRENT_NAME, P);
			P->TOKEN_NODE.DTYPE = byte (1);
			call RELEASE_TOKEN_NODE (CURRENT_NAME);
		end;
	end;

	... */

	/*
	/* Fill in this sym-node with the current declaration specifier
	/* data, name data, and line/file data; initialize all the rest.
	/**/

	SYM_NODE.NAME			= CURRENT_NAME;
	SYM_NODE.DCL_LINE_ID		= CURRENT_NAME_LINE_ID;
	SYM_NODE.DCL_FILE_ID		= CURRENT_NAME_FILE_ID;

	if CURRENT_LINKAGE_KIND = DEFAULT_LINKAGE then
		SYM_NODE.LINKAGE_KIND	= byte (CXX_LINKAGE);
	else	SYM_NODE.LINKAGE_KIND	= byte (CURRENT_LINKAGE_KIND);

	if SYM_NODE.IS_AGGREGATE_MEMBER then
		SYM_NODE.ACCESS		= byte (CURRENT_MEMBER_ACCESS);

	if SYM_NODE.IS_TAG then do;
		/*
		/* Note the little catch-22 work-around here; we
		/* make the symbol first, then get its sym-node id
		/* in CURRENT_BASE_TYPE_ID, and then build its type.
		/* This is so that the base type id of the type-node
		/* will point back to the tag symbol.
		/**/
		CURRENT_BASE_TYPE_ID = CURRENT_NODE_ID;
		call BUILD_CURRENT_TAG_TYPE ();
		SYM_NODE.TYPE		= CURRENT_TYPE;
		SYM_NODE.TOP_TYPE	= CURRENT_TOP_TYPE;
		/*
		/* Set the default linkage internal; if this class subsequently
		/* defines static or non-inline members or it is used in the
		/* declaration of an external linkage object/function, then it
		/* will be changed to external linkage.  N.B. I'm not really
		/* sure if we'll really need this or not; it may be enough to
		/* set the appropriate linkage for the members; we'll see.
		/**/
		SYM_NODE.INTERNAL_LINKAGE	= TRUE;
		if SYM_NODE.IS_ANON_UNION_TAG then
			SYM_NODE.STORAGE_CLASS	= byte (CURRENT_STORAGE_CLASS);
		if SYM_NODE.IS_ENUM_TAG then do;
			SYM_NODE.ENUM_INTEGRAL_TYPE =
				byte (CURRENT_ENUM_BASE_TYPE);
			if CURRENT_ENUM_NO_BASE_TYPE then
				SYM_NODE.HAS_ENUM_INTEGRAL_TYPE = FALSE;
			else do;
				SYM_NODE.HAS_ENUM_INTEGRAL_TYPE = TRUE;
				call SIMPLE_TYPE_SIZE (CURRENT_ENUM_BASE_TYPE,
						       SYM_NODE.SIZE,
						       SIZE_UNITS, BOUNDARY);
				SYM_NODE.SIZE_UNITS = byte (SIZE_UNITS);
				SYM_NODE.BOUNDARY   = byte (BOUNDARY);
			end;
		end;
		return (CURRENT_SYMBOL);
	end;
	else if SYM_NODE.IS_FUNCTION then do;
		SYM_NODE.INLINE			= CURRENT_INLINE;
		SYM_NODE.VIRTUAL		= CURRENT_VIRTUAL;
		SYM_NODE.OVERLOAD		= CURRENT_OVERLOAD;
		SYM_NODE.PURE			= CURRENT_PURE_SPECIFIER;
		if SW_ALLOW_ASM then
			SYM_NODE.ASM_FUNCTION	= TRUE;
		SYM_NODE.SOURCE			= CURRENT_SOURCE.ID;
	end;
	else if SYM_NODE.IS_BIT_FIELD then do;
		SYM_NODE.TYPE			= CURRENT_TYPE;
		SYM_NODE.TOP_TYPE		= CURRENT_TOP_TYPE;
		SYM_NODE.SIGNED_BIT_FIELD	= CURRENT_BASE_TYPE_SIGNED;
		SYM_NODE.SIGNED			= CURRENT_BASE_TYPE_SIGNED;
		SYM_NODE.SIZE			= CURRENT_BIT_FIELD;
		SYM_NODE.SIZE_UNITS		= byte (BITS);
		return (CURRENT_SYMBOL);
	end;
	else	SYM_NODE.SIGNED			= CURRENT_BASE_TYPE_SIGNED;

	/* Check the ordering of any default arguments within the type */

	if ^SYM_NODE.IS_PARAMETER then do;
		if CURRENT_TYPE_LEVEL > 0 then do;
			call GET_TYPE_NODE_R (CURRENT_TYPE, P);
			call CHECK_DEFAULT_ARGUMENT_ORDER (P);
			call RELEASE_TYPE_NODE (CURRENT_TYPE);
		end;
	end;

	/* Fill in the storage class */

	if CURRENT_STORAGE_CLASS = REGISTER_ST then do;
		if CXX_USING_PHOENIX then
			SYM_NODE.REGISTER_AT = TRUE;
		SYM_NODE.STORAGE_CLASS = byte (AUTO_ST);
	end;
	else	SYM_NODE.STORAGE_CLASS = byte (CURRENT_STORAGE_CLASS);

	/* Fill in the type/size information */

	call FINISH_SYMBOL ();

	/* Return the new sym-node id */

	return (CURRENT_SYMBOL);

end BUILD_SYMBOL;

/* ---------------------------------------------------------------------
/* FINISH_SYMBOL
/*
/* Fill in the type/size information of the symbol represented by
/* the currently paged in symbol node.  Preserves current-node-id.
/* ------------------------------------------------------------------- */

FINISH_SYMBOL: procedure internal;

	declare
		SIZE_UNITS	type (SHORT_T),
		BOUNDARY	type (SHORT_T),
		TP		type (POINTER_T);

	call GET_TYPE_NODE_R (CURRENT_TYPE, TP);

	call GET_TOP_TYPE_P (TP, SYM_NODE.TOP_TYPE);
	call ANY_TYPE_SIZE (TP, 0, SYM_NODE.SIZE, SIZE_UNITS, BOUNDARY);

	if SYM_NODE.IS_NON_STATIC_DATA_MEMBER then do;
		if SYM_NODE.SIZE = 0 then do;
			if SYM_NODE.TOP_TYPE.CODE = byte (ARRAY_DT) then do;
				if SW_CLASSIC_C_MODE then
					call SEMANTIC_ERROR
					     (ERR_WARN_ZERO_ARRAY_MEMBER_SIZE);
				else	call SEMANTIC_ERROR
					     (ERR_ZERO_ARRAY_MEMBER_SIZE);
			end;
			else	call SEMANTIC_ERROR (ERR_ZERO_MEMBER_SIZE);
			SYM_NODE.SIZE_UNITS	= byte (BYTES);
			SYM_NODE.BOUNDARY	= byte (BYTES);
		end;
		else if (CURRENT_STRUCT_ALIGNMENT ^= 0) &
			(CURRENT_STRUCT_ALIGNMENT < BOUNDARY) then do;
			SYM_NODE.SIZE	    = ROUNDU
					      (SYM_NODE.SIZE,
					       SIZE_UNITS,
					       CURRENT_STRUCT_ALIGNMENT);
			SYM_NODE.SIZE_UNITS = byte (CURRENT_STRUCT_ALIGNMENT);
			SYM_NODE.BOUNDARY   = byte (CURRENT_STRUCT_ALIGNMENT);
		end;
		else do;
			SYM_NODE.SIZE_UNITS	= byte (SIZE_UNITS);
			SYM_NODE.BOUNDARY	= byte (BOUNDARY);
		end;
	end;
	else do;
		if SYM_NODE.REGISTER_AT then do;
			if SYM_NODE.SIZE = 0 then
				SYM_NODE.REGISTER_AT = FALSE;
			else if SYM_NODE.TOP_TYPE.CODE = byte (ARRAY_DT) then
				SYM_NODE.REGISTER_AT = FALSE;
			else if IS_AGGREGATE_TAG_TYPE
				(rank (SYM_NODE.TOP_TYPE.CODE)) then
				SYM_NODE.REGISTER_AT = FALSE;
			/*
			/* TODO: Create a target specific replace
			/* constant to use (REGISTER_BYTE_SIZE)
			/* rather than 4!
			/**/
			else if ROUNDU (SYM_NODE.SIZE, SIZE_UNITS, BYTES) > 4
			then	SYM_NODE.REGISTER_AT = FALSE;
		end;
		SYM_NODE.SIZE_UNITS	= byte (SIZE_UNITS);
		SYM_NODE.BOUNDARY	= byte (BOUNDARY);
	end;

	SYM_NODE.TYPE			= CURRENT_TYPE;
	SYM_NODE.FROM_TYPEDEF		= CURRENT_TYPE_FROM_TYPEDEF;
	SYM_NODE.BASE_TYPE_UNSPECIFIED	= CURRENT_BASE_TYPE_UNSPECIFIED;

	call RELEASE_TYPE_NODE (CURRENT_TYPE);

end FINISH_SYMBOL;

/* ---------------------------------------------------------------------
/* BUILD_OLD_PARAMETER_SYMBOL
/* ------------------------------------------------------------------- */

BUILD_OLD_PARAMETER_SYMBOL: procedure returns (type (NID_T)) internal;

	CURRENT_SYMBOL		= MAKE_SYM_NODE (PARAMETER_SK);
	SYM_NODE.NAME		= CURRENT_NAME;
	SYM_NODE.DCL_LINE_ID	= CURRENT_NAME_LINE_ID;
	SYM_NODE.DCL_FILE_ID	= CURRENT_NAME_FILE_ID;
	return (CURRENT_SYMBOL);

end BUILD_OLD_PARAMETER_SYMBOL;

/* ---------------------------------------------------------------------
/* FINISH_OLD_PARAMETER_SYMBOL
/* ------------------------------------------------------------------- */

FINISH_OLD_PARAMETER_SYMBOL: procedure internal;

	declare TP type (POINTER_T);

	if CURRENT_TYPE_LEVEL > 0 then do;
		call GET_TYPE_NODE_R (CURRENT_TYPE, TP);
		call CHECK_DEFAULT_ARGUMENT_ORDER (TP);
		call RELEASE_TYPE_NODE (CURRENT_TYPE);
	end;

	if CURRENT_STORAGE_CLASS = REGISTER_ST then do;
		if CXX_USING_PHOENIX then
			SYM_NODE.REGISTER_AT = TRUE;
	end;

	call FINISH_SYMBOL ();

end FINISH_OLD_PARAMETER_SYMBOL;

/* ---------------------------------------------------------------------
/* SET_CURRENT_TYPE
/*
/* (Re)Set the current type to the type represented by
/* the given type-node id.  Preserves current-node-id.
/* ------------------------------------------------------------------- */

SET_CURRENT_TYPE: procedure (T);

	declare
		T	type (NID_T);
	declare
		TP	type (POINTER_T);

	CURRENT_TYPE			= T;

	call GET_TOP_TYPE (T, CURRENT_TOP_TYPE);

	call GET_TYPE_NODE_R (T, TP);
	CURRENT_BASE_TYPE		= rank (TP->TYPE_NODE.DATA (0).CODE);
	CURRENT_BASE_TYPE_QUALIFIER	= TP->TYPE_NODE.DATA (0).QUALIFIERS;
	CURRENT_BASE_TYPE_ID		= TP->TYPE_NODE.DATA (0).NID;
	call RELEASE_TYPE_NODE (T);

	CURRENT_TYPE_FROM_TYPEDEF	= FALSE;

end SET_CURRENT_TYPE;

/* ---------------------------------------------------------------------
/* BEGIN_LINKAGE_SPECIFIER
/* ------------------------------------------------------------------- */

BEGIN_LINKAGE_SPECIFIER: procedure external (X_BEGIN_LINKAGE_SPECIFIER);

	declare
		THIS_LINKAGE_STRING	character (256) varying,
		THIS_LINKAGE_KIND	type (SHORT_T),
		THIS_C_HEADER_MODE	type (BOOL_T);

	if CURRENT_SCOPE_TYPE ^= GLOBAL_SCOPE then do;
		/*
		/* Error; a linkage specifier may
		/* only occur at file (global) scope.
		/**/
		call SEMANTIC_ERROR (ERR_LINKAGE_PLACEMENT);
		call SAVE_LINKAGE_STATE ();
		return;
	end;

	/* Get the linkage specification string */

	THIS_LINKAGE_STRING = TOKEN_SPELLING (MATCHED_TOKEN_PTR);

	/* Remove the enclosing quotes and the trailing null */

	THIS_LINKAGE_STRING = substr (THIS_LINKAGE_STRING, 2,
				      length (THIS_LINKAGE_STRING) - 3);

	/* Check out the linkage specification string */

	THIS_C_HEADER_MODE = FALSE;

	if       THIS_LINKAGE_STRING  = 'C' then
		 THIS_LINKAGE_KIND    =  C_LINKAGE;
	else if (THIS_LINKAGE_STRING  = 'C-header') |
		(THIS_LINKAGE_STRING  = 'CC') then do;
		 THIS_LINKAGE_KIND    =  C_LINKAGE;
		 THIS_C_HEADER_MODE   =  TRUE;
	end;
	else if  THIS_LINKAGE_STRING  = 'C++' then
		 THIS_LINKAGE_KIND    =  Cxx_LINKAGE;
	else if  THIS_LINKAGE_STRING  = 'FORTRAN' then
		 THIS_LINKAGE_KIND    =  FORTRAN_LINKAGE;
	else if  THIS_LINKAGE_STRING  = 'Pascal' then
		 THIS_LINKAGE_KIND    =  PASCAL_LINKAGE;
	else if  THIS_LINKAGE_STRING  = 'PL/I' then
		 THIS_LINKAGE_KIND    =  PLI_LINKAGE;
	else do;
		call SEMANTIC_ERROR (ERR_UNKNOWN_LINKAGE);
		call SAVE_LINKAGE_STATE ();
		return;
	end;

	if THIS_C_HEADER_MODE then do;
		CURRENT_LINKAGE_KIND = CURRENT_LINKAGE_KIND + HB_LINKAGE + 1;
		call SET_C_HEADER_MODE ();
	end;

	call SAVE_LINKAGE_STATE ();

	CURRENT_LINKAGE_KIND		 = THIS_LINKAGE_KIND;
	CURRENT_SIMPLE_LINKAGE_SPECIFIER = TRUE;
	CURRENT_STORAGE_CLASS		 = EXTERN_ST;

end BEGIN_LINKAGE_SPECIFIER;

/* ---------------------------------------------------------------------
/* SET_LINKAGE_SPECIFIER_GROUP
/* ------------------------------------------------------------------- */

SET_LINKAGE_SPECIFIER_GROUP: procedure
			     external  (X_SET_LINKAGE_SPECIFIER_GROUP);

	CURRENT_SIMPLE_LINKAGE_SPECIFIER = FALSE;
	CURRENT_STORAGE_CLASS		 = NULL_ST;

end SET_LINKAGE_SPECIFIER_GROUP;

/* ---------------------------------------------------------------------
/* END_LINKAGE
/* ------------------------------------------------------------------- */

END_LINKAGE_SPECIFIER: procedure external (X_END_LINKAGE_SPECIFIER);

	call RESTORE_LINKAGE_STATE ();
	CURRENT_SIMPLE_LINKAGE_SPECIFIER = FALSE;
	if CURRENT_LINKAGE_KIND > HB_LINKAGE then do;
		CURRENT_LINKAGE_KIND = CURRENT_LINKAGE_KIND - HB_LINKAGE - 1;
		call UNSET_C_HEADER_MODE ();
	end;

end END_LINKAGE_SPECIFIER;

/* ---------------------------------------------------------------------
/* BEGIN_ASM_DECLARATION
/* ------------------------------------------------------------------- */

BEGIN_ASM_DECLARATION: procedure
		       returns   (type (NID_T))
		       external  (X_BEGIN_ASM_DECLARATION);

	call SEMANTIC_ERROR (ERR_NO_ASM);

end BEGIN_ASM_DECLARATION;

/* ---------------------------------------------------------------------
/* SET_ASM_DECLARATION
/* ------------------------------------------------------------------- */

SET_ASM_DECLARATION: procedure
		     returns   (type (NID_T))
		     external  (X_SET_ASM_DECLARATION);

	call SEMANTIC_ERROR (ERR_NO_ASM);

end SET_ASM_DECLARATION;

/* ---------------------------------------------------------------------
/* WARN_EXTRA_TEXT
/* ------------------------------------------------------------------- */

WARN_EXTRA_TEXT: procedure external (X_WARN_EXTRA_TEXT);

	call SYNTAX_ERROR (ERR_EXTRA_TEXT);

end WARN_EXTRA_TEXT;

/* ---------------------------------------------------------------------
/* WARN_EXTRA_ELLIPSIS
/*
/* This is called iff ellipsis are encountered after a parameter which
/* is *not* followed by a comma.  This is allowed in C++ but not ANSI-C.
/* ------------------------------------------------------------------- */

WARN_EXTRA_ELLIPSIS: procedure external (X_WARN_EXTRA_ELLIPSIS);

	if ^SW_C_PLUS_PLUS then
		call SYNTAX_ERROR (ERR_NO_COMMA_BEFORE_ELLIPSIS);
	else	call SET_ELLIPSIS ();

end WARN_EXTRA_ELLIPSIS;

/* ---------------------------------------------------------------------
/* WARN_EXTRA_ENUM_COMMA
/* ------------------------------------------------------------------- */

WARN_EXTRA_ENUM_COMMA: procedure external (X_WARN_EXTRA_ENUM_COMMA);

	if ^SW_ALLOW_EXTRANEOUS_ENUM_COMMA then
		call SYNTAX_ERROR (ERR_ENUM_TRAILING_COMMA);

end WARN_EXTRA_ENUM_COMMA;

/* ---------------------------------------------------------------------
/* WARN_EXTRA_ARGUMENT_COMMA
/* ------------------------------------------------------------------- */

WARN_EXTRA_ARGUMENT_COMMA: procedure external (X_WARN_EXTRA_ARGUMENT_COMMA);

	if ^SW_ALLOW_EXTRANEOUS_ARG_COMMA then
		call SYNTAX_ERROR (ERR_EXTRA_ARG_COMMA);

end WARN_EXTRA_ARGUMENT_COMMA;

/* ---------------------------------------------------------------------
/* RUMMAGE_QUALIFIED_TYPE_NAME
/*
/* Look for the name represented by the token-node id NAME name starting
/* at the current non-class scope.  If found and it is a type name and it
/* was originally nested within another class (but it's not now because
/* we are compiling in -xnnt mode), then return the sym-node id of the
/* type symbol and with it paged in.  Otherwise, if not found or if
/* found but not a type name or not originally nested within another
/* class, then return NULL_NID with the current-node-id trashed.
/* ------------------------------------------------------------------- */

RUMMAGE_QUALIFIED_TYPE_NAME: procedure (NAME)
			     returns   (type (NID_T))
			     external  (X_RUMMAGE_QUALIFIED_TYPE_NAME);
	declare
		NAME	type (NID_T);

	if LOOKUP_NAME_QUIETLY
	   (NAME, ANY_SK, CURRENT_NON_CLASS_SCOPE) = NULL_NID then
		return (NULL_NID);
	else if ^SYM_NODE.IS_TYPE then
		return (NULL_NID);
	else if SYM_NODE.ENCLOSING_CLASS = NULL_NID then
		return (NULL_NID);
	else	return (CURRENT_NODE_ID);
    
end RUMMAGE_QUALIFIED_TYPE_NAME;

/* ---------------------------------------------------------------------
/* RUMMAGE_QUALIFIED_TAG_NAME
/*
/* Look for the name represented by the token-node id NAME name starting
/* at the current non-class scope.  If found and it is a tag name and it
/* was originally nested within another class (but it's not now because
/* we are compiling in -xnnt mode), then return the sym-node id of the
/* tag symbol and with it paged in.  Otherwise, if not found or if found
/* but not a tag name or not originally nested within another class,
/* then return NULL_NID with the current-node-id trashed.
/* ------------------------------------------------------------------- */

RUMMAGE_QUALIFIED_TAG_NAME: procedure (NAME)
			    returns   (type (NID_T))
			    external  (X_RUMMAGE_QUALIFIED_TAG_NAME);
	declare
		NAME	type (NID_T);

	if RUMMAGE_QUALIFIED_TYPE_NAME (NAME) ^= NULL_NID then
		if SYM_NODE.IS_TAG then
			return (CURRENT_NODE_ID);
	return (NULL_NID);
    
end RUMMAGE_QUALIFIED_TAG_NAME;

/* ---------------------------------------------------------------------
/* UNDECLARED_MEMBER_ERROR
/*
/* Assuming that the name represented by CURRENT_NAME was referenced as
/* a member of the class represented by CURRENT_NAME_SCOPE_SYMBOL, but
/* is not a member of the class, issue an appropriate diagnostic.
/* Preserves current-node-id.
/* ------------------------------------------------------------------- */

UNDECLARED_MEMBER_ERROR: procedure internal;

	if CURRENT_NAME = CONSTRUCTOR_NAME then
		call SEMANTIC_ERROR_I
		     (ERR_UNDEF_QUAL_CTOR_NAME,
		      QUALIFIED_SYMBOL_NAME (CURRENT_NAME_SCOPE_SYMBOL));
	else if CURRENT_NAME = DESTRUCTOR_NAME then
		call SEMANTIC_ERROR_I
		     (ERR_UNDEF_QUAL_DTOR_NAME,
		      QUALIFIED_SYMBOL_NAME (CURRENT_NAME_SCOPE_SYMBOL));
	else if CURRENT_NAME = CONVERSION_NAME then
		call SEMANTIC_ERROR_I
		     (ERR_UNDEF_QUAL_CNV_NAME,
		      QUALIFIED_SYMBOL_NAME (CURRENT_NAME_SCOPE_SYMBOL));
	else	call SEMANTIC_ERROR_II
		     (ERR_UNDEF_QUAL_NAME,
		      TOKEN_NAME (CURRENT_NAME),
		      QUALIFIED_SYMBOL_NAME (CURRENT_NAME_SCOPE_SYMBOL));

end UNDECLARED_MEMBER_ERROR;

/* ---------------------------------------------------------------------
/* MAKE_QUALIFIED_NAME
/* ------------------------------------------------------------------- */

MAKE_QUALIFIED_NAME: procedure (CLASS_SYMBOL, MEMBER_NAME)
		     returns   (character (512) varying) internal;
	declare
		CLASS_SYMBOL	type (NID_T),
		MEMBER_NAME	type (NID_T);

	if CLASS_SYMBOL = NULL_NID then
		return ('::' || TOKEN_NAME (MEMBER_NAME));
	else	return (QUALIFIED_SYMBOL_NAME (CLASS_SYMBOL) ||
			'::' || TOKEN_NAME (MEMBER_NAME));

end MAKE_QUALIFIED_NAME;

/* ---------------------------------------------------------------------
/* MAKE_QUALIFIED_NAME_FROM_TOKEN
/* ------------------------------------------------------------------- */

MAKE_QUALIFIED_NAME_FROM_TOKEN: procedure (CLASS_SYMBOL, TOKEN_PTR)
				returns   (character (512) varying) internal;
	declare
		CLASS_SYMBOL	type (NID_T),
		TOKEN_PTR	type (POINTER_T);

	if CLASS_SYMBOL = NULL_NID then
		return ('::' || TOKEN_SPELLING (TOKEN_PTR));
	else	return (QUALIFIED_SYMBOL_NAME (CLASS_SYMBOL) ||
			'::' || TOKEN_SPELLING (TOKEN_PTR));

end MAKE_QUALIFIED_NAME_FROM_TOKEN;

/* ---------------------------------------------------------------------
/* SET_DECLARATOR_SCOPE
/* ------------------------------------------------------------------- */

SET_DECLARATOR_SCOPE: procedure external (X_SET_DECLARATOR_SCOPE);

	if CURRENT_NAME_SCOPE ^= NULL_NID then do;
		call SAVE_SCOPE_STATE ();
		call SET_CURRENT_SCOPE (CURRENT_NAME_SCOPE);
	end;
	else if (INACCESSIBLE_QUALIFIED_BASE_TYPE ^= NULL_NID) &
		(CURRENT_BASE_TYPE_ID ^= NULL_NID) then do;
		/*
		/* Error; the nested base type for this declarator is
		/* inaccessible (deferred from LOOKUP_CURRENT_QUALIFIED_TYPE).
		/**/
		call SEMANTIC_ERROR_I
		     (ERR_PRIV_BASE_TYPE_NAME,
		      QUALIFIED_SYMBOL_NAME
		      (INACCESSIBLE_QUALIFIED_BASE_TYPE));
		INACCESSIBLE_QUALIFIED_BASE_TYPE = NULL_NID;
	end;

end SET_DECLARATOR_SCOPE;

/* ---------------------------------------------------------------------
/* RESTORE_DECLARATOR_SCOPE
/* ------------------------------------------------------------------- */

RESTORE_DECLARATOR_SCOPE: procedure internal;

	if CURRENT_NAME_SCOPE ^= NULL_NID then
		call RESTORE_SCOPE_STATE ();

end RESTORE_DECLARATOR_SCOPE;

/* ---------------------------------------------------------------------
/* FREE_CURRENT_PROTOTYPE_SCOPE
/*
/* If CURRENT_TYPE is a function type, call FREE_PROTOTYPE_SCOPE
/* for that function's signature.  
/* ------------------------------------------------------------------- */

FREE_CURRENT_PROTOTYPE_SCOPE: procedure
			      internal;

	if rank (CURRENT_TOP_TYPE.CODE) = FUNCTION_DT then
		call FREE_PROTOTYPE_SCOPE (CURRENT_TOP_TYPE.SIGNATURE);

end FREE_CURRENT_PROTOTYPE_SCOPE;

/* ---------------------------------------------------------------------
/* BEGIN_PAREN_TYPE_NAME
/* ------------------------------------------------------------------- */

BEGIN_PAREN_TYPE_NAME: procedure external (X_BEGIN_PAREN_TYPE_NAME);

	IN_PAREN_TYPE_NAME_LEVEL = IN_PAREN_TYPE_NAME_LEVEL + 1;

end BEGIN_PAREN_TYPE_NAME;

/* ---------------------------------------------------------------------
/* END_PAREN_TYPE_NAME
/* ------------------------------------------------------------------- */

END_PAREN_TYPE_NAME: procedure external (X_END_PAREN_TYPE_NAME);

	IN_PAREN_TYPE_NAME_LEVEL = IN_PAREN_TYPE_NAME_LEVEL - 1;

end END_PAREN_TYPE_NAME;

/* ---------------------------------------------------------------------
/* CHECK_QUALIFIED_SIGNATURE
/*
/* Call with a function type for a function that's not a non-static
/* member.  Reports error if qualifiers are present in signature.
/* ------------------------------------------------------------------- */

CHECK_QUALIFIED_SIGNATURE: procedure (TYPE_DATA)
			   internal;

	declare
		TYPE_DATA	type (TYPE_DATA_T);
	declare
		SIGP		type (POINTER_T);

	if rank (TYPE_DATA.CODE) ^= FUNCTION_DT then
		return;

	call GET_SIG_NODE_R (TYPE_DATA.SIGNATURE, SIGP);

	if SIGP->SIG_NODE.THIS_QUALIFIERS.CONST then do;
		/*
		/* Error; only non-static member
		/* function may be declared as "const".
		/**/
		call SEMANTIC_ERROR (ERR_CONST_FUN_DCL);
	end;
	else if    SIGP->SIG_NODE.THIS_QUALIFIERS.QUALIFIERS & ALL_TQ 
	        ^= NULL_TQ  then do;
		/*
		/* Error; only non-static member
		/* function may be declared with qualifier.
		/**/
		call SEMANTIC_ERROR (ERR_QUALIFIED_FUN_DCL);
	end;

	call RELEASE_SIG_NODE (TYPE_DATA.SIGNATURE);

end CHECK_QUALIFIED_SIGNATURE;

