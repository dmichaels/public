/* CPP pp.pl1 - Lexical analyzer and preprocessor */

/***********************************************************************
 * This product is the property of Liant Software Corporation and is   *
 * licensed pursuant to a written license agreement.  No portion of    *
 * this product may be reproduced without the written permission of    *
 * Liant Software Corporation except pursuant to the license agreement.*
 ***********************************************************************/

/***********************************************************************
 *
 *  LPI EDIT HISTORY               [ Update the VERSION__ string below ]
 *
 *  01.21.92  DGM  047 	Added SW_DEFINE_STDCPP (__STDCPP__ & __ANSI_CPP__)
 *			and SW_TREAT_QUOTE_INCLUDE_AS_ANGLE.
 *  10.29.92  DGM  046 	Added SW_NO_IMPLICIT_C_HEADER_MODE.
 *  09.30.92  DGM  045 	Added SW_IGNORE_IDENT & SW_NO_PRAGMA_DATA_SECTION.
 *  09.09.92  DGM  044 	Increase MAX_SKIP_FILES.
 *  07.15.92  DGM  043 	Fix for computing the #line adjustment.
 *  06.23.92  DGM  042R	Send out #pragma LPI data_section (".comment")
 *			for #ident (____lpi_ident_N) string.
 *  06.22.92  DGM  042 	#pragma varargs_used (explicit for completeness).
 *  06.18.92  DGM  041 	Added #pragma LPI data_section.
 *  06.11.92  DGM  040 	Added #pragma LPI C-header ( on | off )
 *  06.03.92  DGM  039 	Added SW_DEFINE_C_HEADER_STDC_AS_ZERO.
 *  05.13.92  DGM  038R	Fix for 038.
 *  05.11.92  DGM  038	#pragma weak work.
 *  04.30.92  DGM  037	Pre#define c_plusplus in -cfront mode.
 *  03.30.92  DGM  036	Strongly favor our <prof.h>.
 *			Fix for gray-space in #define.
 *  03.19.92  DGM  035	Minor fix to prevent blowup for #line 1 L"s".
 *  02.26.92  DGM  034	Coding fix for #pragma comment.
 *  02.10.92  DGM  033	Implemented -nowrappers switch.
 *  01.31.92  DGM  032	Violation for eof in line iff SW_WARN_EOF_IN_LINE.
 *  01.29.92  DGM  031	No warning if sysdef.h not found.
 *  01.28.92  DGM  030	Accept "va_start (name, )" or va_start (name)".
 *  01.22.92  DGM  029	Set __STDC__ to 0 in during C-header mode iff
 *			it's not already define (as anything at all);
 *			we used to unconditionally define __STDC__ as 1
 *			during C-header mode.  Fix to not print any
 *			startup include files to the listing file if
 *			-noincludes is given.
 *  12.19.91  DGM  027R Changed WRITE_DEBUG_LINE to WRITE_ERROR_LINE.
 *  11.19.91  DGM  027R Fix for #pragma LPI wrapper_redeclarations.
 *  11.12.91  DGM  027  Allow __STDC__ to be redefined in default (C++)
 *			mode and in -classicc mode.  Treat a system
 *			header wrapper file as a SYSTEM_HEADER_SK.
 *			#pragma ident, #pragma int_to_unsigned (ignore).
 *  10.03.91  DGM  026  Added #pragma LPI allow_asm (on | off)
 *  10.01.91  DGM  025  Fix for -ipathc in OPEN_xxx_INCLUDE.
 *  08.19.91  DGM  024  Fix in OPEN_xxx_INCLUDE to search in the standard
 *			LPI C header directory, /usr/include/LPI, in 
 *			Classic C mode iff the file being included is
 *			common.h or machine.h; this is needed because
 *			varargs.h and stdarg.h is always pulled in from
 *			the LPI directory, and those header pull in
 *			common.h and machine.h.  There are better ways!
 *  08.15.91  DGM  023R Fix in DEFINE_STDC_MACRO.
 *			Changed system header file wrapper include method.
 *  08.14.91  DGM  023  Good fake at #ident & #comment functionality;
 *			send thru a ``static char *____lpi_ident_N
 *			= "given string-literal"''; the real way is
 *			to send a pragma thru with the string-literal
 *			and have the front-end stuff it in .comment.
 *  08.06.91  DGM  022  #pragma pack.
 *  07.31.91  DGM  021  Fix for skipping header based on #ifndef/#endif.
 *  07.24.91  DGM  020  Added #pragma LPI wrapper_redeclarations; fixes
 *			for #once; additions for #pragma LPI C-header. 
 *  07.21.91  PKT  019  Bug fix.
 *  07.18.91  DGM  018  Added __LPI_CXX_USE_SYSTEM_LIBRARY__.
 *			Added #include {file.h} functionality to search
 *			in standard system header directory *only*.
 *			Search STANDARD_SYSTEM_HEADER_WRAP_DIR,
 *			i.e. /usr/include/LPI/system, before the
 *			standard system header directory.
 *			Added SW_PRINT_FILE_NAME_AS_WE_GO functionality.
 *  07.08.91  DGM  017  Implement #assert/#unassert/#file/#elseif etc.
 *  06.17.91  DGM  016  #define __LPI_CXX__ iff C++.
 *  05.29.91  DGM  015  #define __LPI_CXX_OLD_STREAM_HEADER__ iff C++
 *			mode and SW_USE_OLD_CXX_STREAM_HEADER is TRUE.
 *  05.03.91  DGM  014  Yet another minor with #include lookups.
 *  05.02.91  DGM  013  Hard wire #include <stdarg.h> and <varargs.h>
 *			to find the standard LPI version these headers
 *			even if "-sys" is specified; also, minor fix in
 *			CHECK_FOR_C_HEADER_FILE.
 *  04.29.91  DGM  012  Fix in CHECK_FOR_C_HEADER_FILE
 *			(previously FILE_IN_C_HEADER_DIRECTORY).
 *  04.18.91  DGM  011  Fix in FILE_IN_C_HEADER_DIR..
 *  04.08.91  DGM  010  Fix in GET_{FILE,DATE,TIME}_TOKEN to allocate
 *			an  extra byte!
 *  03.21.91  DGM  009  Fixes related to 008.
 *  03.20.91  DGM  008  Added #pragma LPI C-header.  Fixed bug
 *			in PUSH_MACRO_ARGUMENT_INVOCATION for:
 *				#define X(p) z p #p
 *				X(a)
 *			which was giving ``z a " a"'' not ``z a "a"''.
 *  10.10.90  DGM  007  Fix; prevent "defined" from begin #defined.
 *			Also minor fix for gray-space.
 *  09.25.90  DGM  006  Include file name changes.
 *  09.25.90  DGM  005  New failure return value from LOOKUP_PP_KEYWORD
 *			and LOOKUP_KEYWORD (from -1 to NULL_TOKEN) to
 *			support new/faster keyword lookup implementation.
 *  07.18.90  DGM  004  Fix for a problem some guy in Tel Aviv found:
 *				#define  incfil x
 *				#include <incfil>
 *			This should try to #include "incfil" not "x".
 *			The following will also behave differently (and
 *			I think now, correctly):
 *				#define  incfil x
 *				#define  INCFIL <incfil>
 *				#include INCFIL
 *			This should try to #include "incfil" not "x".
 *			Also, a big bug fix in SHOULD_EXPAND_MACRO:
 *				#define  ABC(q) ((q)->m)
 *				#define  XYZ    ABC(r)
 *				ABC(XYZ)
 *			was being expanded to "((ABC(r))->m)" rather than
 *			"((((r)->m))->m)" !! Note also that the following
 *			is *not* ambiguous as I had previously thought:
 *				#define  h(a) a+f
 *				#define  f    h
 *				f(1)(2)
 *			It should (and does) expand to "1+h(2)", that is
 *			according to the ANSI-C Rationale (3.8.3.3), but
 *			the Plum Hall test "c38.c" tests for "1+f(2)" or
 *			"1+h+2"; this is where my confusion arose.  The
 *			following however *is* ambiguous:
 *				#define  h(a) a+f
 *				#define  f(a) h(a)
 *				f(1)(2)
 *			The ANSI-C Rationale (sec.3.8.3.3) states that
 *			this should expand to either "1+h(2)" or "1+h+2";
 *			we (and TauMetric) however expand this to "1+f(2)".
 *			Plum Hall is definitely confused, ANSI-C is maybe
 *			confused or perhaps we (and TauMetric) are confused.
 *  06.13.90  DGM  003	Updated include files.
 *  06.08.90  DGM  002	Upgraded to new way of reading predefined system
 *			macros, i.e. from a special file at startup, iff
 *			the "-predef" option is given.
 *  06.05.90  DGM  001	Updated.
 *  06.05.90  DGM  000	First CPP component version.
 *
 *  --------------------------------------------------------------------
 *
 *  06.05.90  DGM  [045]
 *  --------------------
 *  Changed for the new utilities (include files).
 *
 *  05.02.90  DGM  [044]
 *  --------------------
 *  Added the ability to process *arbitrarily* long string-literals by
 *  splitting them up necessary into multiple adjacent string-literals.
 *
 *  01.05.90  DGM  [043]
 *  --------------------
 *  Fix in GET_NEXT_MACRO_TOKEN (after HAVE_NEXT_MACRO_TOKEN:), we need
 *  to SALLOC space for one more (+1) character; PLB found that this only
 *  comes up when a string more than 32 bytes in length is used in a macro.
 *
 *  11.21.89  DGM  [042]
 *  --------------------
 *  Added (conditional) support for C++ (hooked on SW_C_PLUS_PLUS).
 *
 *  10.17.89  PLB  [041]
 *  --------------------
 *  Changes for New Globals/Utilities.
 *
 *  10.03.89  DGM  [040]
 * ---------------------
 *  Changed SHOULD_EXPAND_THIS_MACRO to expand:
 *
 *              #define f    h
 *              #define h(a) a+f
 *              f(1)(2)
 *
 *  to "1+h(2)" rather than "1+2+h" to pass Plum Hall tests (lang/c38).
 *  Old method supported via SW_LESS_RESTRICTIVE_MACRO_RESCAN (-lrmr).
 *
 *  08.01.89  DGM  [039]
 *  ---------------------
 *  Added support for CodeWatch macro evaluation (MAKE_DEBUGGER_MACROS).
 *  Fix to LINE_FILE_TOKEN token pod to set the LINE field to be the
 *  line *adjustment* rather than the assumed #line specified so the
 *  caller (e.g. CLEXER) can correctly track the line number.
 *
 *  07.20.89  DGM  [038]
 *  --------------------
 *  Added support for a (non-ANSI) "#note" preprocessing directive.
 *
 *  06.26.89  DGM  [037]
 *  --------------------
 *  Added support for "-xid" (SW_IDENT_NOWARN) flag to ignore, *without*
 *  a warning, occurrences of the non-ANSI "#ident" directive.
 *
 *  06.12.89  DGM  [036]
 *  --------------------
 *  Added functionality for "-ppall" (run preprocessing phase first).
 *
 *  06.12.89  DGM  [035]
 *  --------------------
 *  Fix in READ_MACRO_DEFINITION which caused blowup on 386 for macro
 *  redefinitions.  Also, now gives macro redefinition diagnostic which
 *  contains the line number and file where macro was last defined.
 *
 *  06.09.89  DGM  [034]
 *  --------------------
 *  Added/modified support for "-imath", "-istring", and "-sysdef"; see
 *  OPEN_STARTUP_INCLUDE, OPEN_INLINE_INCLUDE, PRE_DEFINE_OTHER_MACROS,
 *  and PRE_DEFINE_SYSTEM_MACROS.
 *
 *  06.08.89  DGM  [033]
 *  --------------------
 *  Changed #include file search algorithm;
 *  see comments in OPEN_INCLUDE_FILE and OPEN_INCLUDE_HEADER.
 *
 *  06.05.89  DGM  [032]
 *  --------------------
 *  Minor reorganization.  Added ability to optionally refrain from
 *  trigraph mapping via the "-xnt" switch (see OPEN_SOURCE).
 *
 *  05.26.89  DGM  [031]
 *  --------------------
 *  Allocate one more byte for the spelling of floating constant; this
 *  is necessary in case the unary minus operator was applied to the
 *  floating constant in which case the front-end (in EXPV (in MINUS_VOP))
 *  will tack minus onto the beginning of the string, assuming that enough
 *  space for the extra character has been allocated.
 *
 *  05.18.89  DGM  [030]
 *  --------------------
 *  Added ability to specify number of tokens to send out to the token
 *  token pod stream at a time (via PP_MAX_TOKENS and the "-ppntok"
 *  switch).  Moved initialization of internal entry variable outside
 *  the FIRST_TIME block to avoid non-local-goto blowup if PP_MAX_TOKENS
 *  is small (i.e. smaller than the total number of tokens sent out),
 *  and couple other similar fixups.
 *
 *  05.12.89  DGM  [029]
 *  --------------------
 *  Added more switch stuff, the ability to include a specified file at
 *  startup (in STARTUP_INCLUDE_FILE), and changed some error messages.
 *  Also, yet another Plum Hall update has invalidated my macro expansion
 *  algorithm, they now say:
 *
 *              #define f    h
 *              #define h(a) a+f
 *              f(1)(2)
 *
 *  should expand to either "1+f(2)" or "1+h(2)".  In 4/89 they said it
 *  should expand to either "1+f(2)" or "1+2+h".  In 2/89 they said it
 *  should expand to either "1+h(2)" or "1+2+h".  X3J11 notes from Nashua,
 *  NH, in 4/88 said it should expand to either "1+h(2)" or "1+2+h"!
 *  Let's get it straight guys!  Here's the lowdown on everyone I know:
 *
 *		Oregon C++:			1+2+h
 *		NEW C (currently (027))		1+2+h
 *		NEW C (previously (025))	1+h(2)
 *		GNU C:				1+h(2)
 *		GreenHills C:			1+h(2)
 *		MS-DOS Quick C:			1+h(2)
 *		MS-DOS MIX C:			1+f(2)
 *		PlumHall toy preprocessor:	1+f(2)
 *
 *  I think I'll wait till things settle down before I make any more
 *  changes as its relatively easy to break things in this area (i.e.
 *  in NEXT_IS_LPAREN_TOKEN and SHOULD_EXPAND_THIS_MACRO).  Although,
 *  the more I look at it, the more I think that "1+h(2)" is the most
 *  logical result - i.e. what I originally coded (revision 025)! Hmm.
 *
 *  04.17.89  DGM  [027]
 *  --------------------
 *  Yanked out EXPRESSION into PPEXPR (ppexpr.pl1) and most of the macro
 *  utilities to PPMAC (ppmac.pl1).  Added PCC_STYLE_STRINGIZE_CHARIZE
 *  to check for PCC style function-like macro definitions in which
 *  parameters are to be substituted within string literals and/or
 *  character constants; hooked on SW_X_STRINGIZE, SW_X_STRINGIZE_WARN,
 *  SW_X_CHARIZE, and SW_X_CHARIZE_WARN.  Much reorganization.
 *
 *  04.19.89  PLB  [026]
 *  --------------------
 *  Added DEFINE_MACRO's for __LPI_MATH__ & __LPI_ISTRING__ (in-line math
 *  and string operations, respectively.  See <math.h> and <string.h>.
 *
 *  02.14.89  DGM  [025]
 *  --------------------
 *  Removed the SOPEN_FLAG; call SINIT instead.
 *
 *  02.06.89  DGM  (024]
 *  --------------------
 *  Added SOPEN_FLAG to for SOPEN; if no listing file then 0, else 1.
 *
 *  01.27.89  DGM  [023]
 *  --------------------
 *  Good grief! I have been under the impression that PL/I guaranteed
 *  logical short-circuits like C; it doesn't! Changed 13 if's which
 *  relied upon this assumption! Also, yanked out SETUP_KEYWORD_TABLES,
 *  KW, & PPKW into kw.pl1. Totally removed the PRE_DEFINE_SYSTEM_MACROS
 *  routine which defined things like "sun", "mc68020", "unix" etc.;
 *  this really renders the implementation non-ANSI, AND there is
 *  really a better way to do this; maybe put these system definitions
 *  in an include file, and a use a compile-time switch to include it.
 *  -TODO- Maybe disallow re-definition of a macro name; currently we
 *  give a warning and then do it (like PCC), but this is really not
 *  ANSI-C behavior; maybe put on switch.  -TODO- Maybe the predefined
 *  macro stuff shouldn't be done; I mean it technically renders this
 *  implementation non-conforming.
 *
 *  01.26.89  DGM  [022]
 *  --------------------
 *  Fixed the brain damaged GET_LINE_TOKEN and GET_FILE_TOKEN routines.
 *
 *  01.11.89  DGM  [021]
 *  --------------------
 *  Added check for <= 0 in #line directive.
 *
 *  01.04.89  DGM  [020]
 *  --------------------
 *  New keyword lookup scheme; see KW, PPKW, and SETUP_KEYWORD_TABLES.
 *  Check for zero divide in an #if/#elif (in MULTIPLICATIVE_EXPR).
 *
 *  12.23.88  DGM  [019]
 *  --------------------
 *  GET_NEXT_LEX_TOKEN/GET_NEXT_EXPANDED_TOKEN changes to improve
 *  performance.  Clarified comments concerning the functions and
 *  assumptions of these routines.  Added warning comments for
 *  architecture dependencies in conversions in EXPRESSION.
 *
 *  12.22.88  DGM  [018]
 *  --------------------
 *  Renamed PP_ERROR to PERROR and put it in its own file (perror.pl1);
 *  renamed PP_ERROR_LINE to PERRORL.  Add LINE_ADJUSTMENT to
 *  PHYSICAL_LINE when creating the __LINE__ token to account
 *  for any previous #line.
 *
 *  12.16.88  DGM  [017]
 *  --------------------
 *  Set LINE_ADJUSTMENT of CURRENT_SOURCE for a #line.
 *
 *  12.14.88  DGM  [016]
 *  --------------------
 *  Modified to free tokens as necessary in expression parser.
 *  Also, check for buffer overflow on #error.
 *
 *  12.13.88  DGM  [015]
 *  --------------------
 *  Fixed bug (typo) in LOGICAL_OR_EXPR (#if 0 || 1).
 *
 *  10.18.88  DGM (David G. Michaels)  [000-014]
 *  --------------------------------------------
 *  Original.
 *
 ***********************************************************************/

/* ---------------------------------------------------------------------
/* Version and copyright stamp
/* ------------------------------------------------------------------- */

declare	VERSION__	character (28) varying static internal initial

('@(#)LPI 02.19.93 047 CPP');

/* ---------------------------------------------------------------------
/* Include files
/* ------------------------------------------------------------------- */

%include 'incfil';
%include GLOBAL_IN;                   /* Global switches */
%include GBL_FILE_NAMES_IN;           /* SOURCE_FILE_NAME */
%include CPP_UTL_DEFS_IN;
%include CPP_UTL_SYMBOL_TABLE_PKG;
%include CPP_UTL_STORE_TOKEN_PKG;
%include CPP_UTL_WRITE_PKG;
%include CPP_COMPILATION_DATA_IN;     /* PP_MAX_TOKENS, DEFINE_LIST, et. al. */
%include CPP_COMPILATION_SWITCHES_IN; /* Front-end switches */
%include CPP_HOST_SYSTEM_IN;          /* Host system definitions */
%include CPP_TARGET_SYSTEM_IN;        /* Target system definitions */
%include CPP_CHARACTER_SET_IN;        /* C character set codes */
%include CPP_TOKEN_POD_MGR_PKG;       /* Token-pod package interface */
%include CPP_TOKEN_POD_SPELLING_PKG;  /* Token-pod spelling routines */
%include CPP_TOKEN_POD_DEBUG_PKG;     /* Token-pod debugging routines */
%include CPP_STANDARD_DEFS_IN;        /* Standard PL/I definitions */
%include CPP_EXTERNAL_NAME_MAP_IN;    /* External name map */
%include CPP_GLOBAL_IN;               /* Preprocessor global functions & data */
%include CPP_MACRO_DEFS_IN;           /* Macro node data & definitions */
%include CPP_MACRO_UTL_PKG;           /* Macro related utilities */
%include CPP_EXPRESSION_PKG;          /* Expression handler */
%include CPP_KEYWORD_PKG;             /* Keyword lookup routines */
%include CPP_SOURCE_MGR_PKG;          /* Source file functions & data */
%include CPP_ERROR_MGR_PKG;            /* Error related utilities */

/* =====================================================================
/* CPPEND
/* =================================================================== */

CPPEND: procedure;

	if SYMBOL_TABLE then
		call MAKE_DEBUGGER_MACROS ();

	call PURGE_MACROS ();

end; /* CPPEND */

/* =====================================================================
/* CPP
/*
/* Description:
/*
/* This routine performs lexical analysis & preprocessing of the ANSI C
/* source file SOURCE_FILE_NAME; it fills up the token-pod stream buffer
/* (via the token-pod manager routines TALLOC/TPUT) with MAX_PP_TOKENS
/* tokens (global).  See C_TOKENS_IN and C_TOKEN_POD for a complete
/* description of the token-pods and token-pod codes.  The first tokens
/* sent out are a BOF_INCLUDE_TOKEN & BOF_TOKEN; a BOF_INCLUDE_TOKEN &
/* EOF_INCLUDE_TOKEN are sent out appropriately for each include file
/* read.  The last token sent out is an EOF_TOKEN; if called repeatedly
/* at end-of-file, this routine will continue to send out EOF_TOKEN's.
/*
/* Miscellaneous:
/*
/* The lower level lexical scanning routines (SNEXTC, SSCANC, SSCANP,
/* SSCANP, SSCANA, SSCANX, and SBACKC) are defined in the modules scan.c
/* (and [icl]file.[ch]); the lower level source file manipulation routines
/* and data (CURRENT_SOURCE) are defined in src.[ch] and src.in (C_SOURCE_IN);
/* the preprocessor macro handling utilities (e.g. lookup, define, undef)
/* are defined in the modules C_PP_MACRO_UTL_PKG; the preprocessor expression
/* handler is defined in ppexpr.pl1.  Preprocessor global function/data
/* declarations are in ppglob.in (PP_GLOBAL_IN); See also the list of
/* %include files & comments below.
/*
/* Procedure Map:
/* ---------------------------------------------------------------------
/*  OPEN_SOURCE
/*  CLOSE_SOURCE
/* ---------------------------------------------------------------------
/*  OPEN_STARTUP_INCLUDE_FILE
/*  OPEN_INLINE_INCLUDE_FILE
/* ---------------------------------------------------------------------
/*  GET_EOF_TOKEN
/*  GET_CONSTANT_ONE_TOKEN
/* ---------------------------------------------------------------------
/*  PRE_DEFINE_COMPILER_MACROS
/*  |  GET_LINE_TOKEN
/*  |  GET_FILE_TOKEN
/*  |  GET_DATE_TOKEN
/*  |  GET_TIME_TOKEN
/* ---------------------------------------------------------------------
/*  COMMAND_LINE_DIRECTIVES
/*  |  NEXTC_FROM_BUFFER
/*  |  SCAND_FROM_BUFFER
/*  |  BACKC_FROM_BUFFER
/* ---------------------------------------------------------------------
/*  GET_NEXT_LEXICAL_TOKEN    <-- GET_NEXT_PP_TOKEN
/*  READ_PP_DIRECTIVE
/*  |  SKIP_GROUP
/*  |  OPEN_INCLUDE_HEADER
/*  |  READ_MACRO_DEFINITION
/*  |  READ_MACRO_PARAMETER_LIST
/*  |  |  CHECK_TOKEN_PASTE
/*  |  |  CHECK_STRINGIZE
/*  |  |  PCC_STYLE_STRINGIZE_CHARIZE
/*  |  IGNORE_PP_DIRECTIVE
/*  HANDLE_END_OF_FILE
/* ---------------------------------------------------------------------
/*  GET_NEXT_MACRO_TOKEN      <-- GET_NEXT_PP_TOKEN
/*  |  GET_MACRO_TOKEN
/*  |  |  FREE_MACRO_ARGUMENT_LIST
/*  |  GET_TOKEN_PASTE_OPERAND
/*  |  GET_STRINGIZE_CHARIZE_OPERAND
/*  |  PASTE_TOKENS
/*  |  |  NEXTC_FROM_BUFFER
/*  |  |  BACKC_FROM_BUFFER
/* ---------------------------------------------------------------------
/*  GET_NEXT_UNEXPANDED_TOKEN
/* ---------------------------------------------------------------------
/*  GET_NEXT_EXPANDED_TOKEN
/*  |  SHOULD_EXPAND_MACRO
/*  |  |  PEEK_FOR_LPAREN_TOKEN
/*  |  PUSH_MACRO_INVOCATION
/*  |  |  COLLECT_MACRO_ARGUMENT_LIST
/*  PUSH_MACRO_ARGUMENT_INVOCATION
/*  PUSH_BACK_TOKEN
/* ---------------------------------------------------------------------
/*  GET_NEXT_UNEXPANDED_TOKEN
/* =================================================================== */

CPP: procedure external;

/* ---------------------------------------------------------------------
/* Macro definitions
/* ------------------------------------------------------------------- */

/*
/* PP_MAX_TOKENS (global) specifies the maximum number of preprocessing
/* tokens to be sent out at a time into the token-pod stream.  By default,
/* PP_MAX_TOKENS is set to DEFAULT_MAX_TOKENS, defined below; set this to
/* WICKED_LOT_OF_TOKENS to process the entire source file all at once.
/* PP_MAX_TOKENS may be set via the "-ppntok" to be any other number.
/* PP_MAX_TOKENS may be to WICKED_LOT_OF_TOKENS via "-ppall".
/**/

%replace WICKED_LOT_OF_TOKENS		by 2147483647;
%replace DEFAULT_MAX_TOKENS		by 512;

/* Source kind codes (used by OPEN_SOURCE) */

%replace VANILLA_SK			by 0;
%replace MAIN_SK			by 1;
%replace STARTUP_HEADER_SK		by 1;
%replace MAIN_OR_STARTUP_HEADER_SK	by 1;
%replace C_HEADER_SK			by 2;
%replace SYSTEM_HEADER_SK		by 3;

/* ---------------------------------------------------------------------
/* Local static data definitions (i.e. global within PREPROCESSOR)
/* ------------------------------------------------------------------- */

declare
	GET_NEXT_PP_TOKEN		entry returns (type (POINTER_T))
					variable static internal;
declare
	DUMMY_WHITE_SPACE		type (BYTE_T) static internal,
	DUMMY_END_MACRO_ARGUMENT	type (BYTE_T) static internal,
	DUMMY_END_PP_DIRECTIVE		type (BYTE_T) static internal,
	DUMMY_END_BUFFER		type (BYTE_T) static internal;

declare
	FIRST_TIME			type (BOOL_T)
					static internal initial (TRUE),
	AT_EOF				type (BOOL_T)
					static internal initial (FALSE),
	IN_GET_NEXT_LEXICAL_TOKEN	type (BOOL_T)
					static internal initial (TRUE),
	GROUP_LEVEL			type (SHORT_T)
					static internal initial (0),
	DO_NOT_EXPAND_MACROS		type (BOOL_T)
					static internal initial (FALSE);
/*
/* TOKEN_AT_LOOK_AHEAD is needed ONLY when we have a function-like
/* macro identifier, and we're looking ahead ONE token to check for
/* a "(" token, and we hit end-of-file! In this case, HANDLE_END_OF_FILE
/* must send out the function-like macro identifier token which will
/* be pointed to by TOKEN_AT_LOOK_AHEAD before the EOF token.  Gross.
/**/
declare
	TOKEN_AT_LOOK_AHEAD		type (POINTER_T)
					static internal initial (null ());
/*
/* This is used to implement #pragma LPI C-header (only applicable in C++
/* compilation mode), which puts the compiler into C-header mode until the
/* end of the source file in which the #pragma occurred; C-header mode does
/* not nest.  Note that when using this #pragma, __STDC__ is set for the
/* duration of C-header mode, but when C-header mode is entered using the
/* extern "C-header" construct, __STDC__ is not set.
/**/
declare
	C_HEADER_MODE_INCLUDE_LEVEL	type (SHORT_T)
					static internal initial (-1),
	VA_START_NAME			type (NID_T)
					static internal initial (0);
/*
/* This next three guys are used ONLY for better error messages when EOF
/* is hit while conditionally excluding source text or while collecting
/* function-like macro arguments.  -TODO- Also do this when conditionaly
/* including source text (e.g. INCLUDE_FROM_LINE and INCLUDE_FROM_FILE). 
/**/
declare
	EXCLUDE_FROM_LINE		type (LONG_T)
					static internal initial (0),
	EXCLUDE_FROM_FILE		type (POINTER_T)
					static internal initial (null ()),
	CURRENT_MACRO_FUNCTION		type (POINTER_T)
					static internal initial (null ());

/* ---------------------------------------------------------------------
/* Local data definitions
/* ------------------------------------------------------------------- */

declare
	NTOKENS				type (LONG_T),
	TP				type (POINTER_T),
	SNID				type (SNID_T);

/* ---------------------------------------------------------------------
/* PREPROCESSOR begin
/* ------------------------------------------------------------------- */

/*
/* (Re)Initialize the internal entry variables.  This *must* be done each
/* time PREPROCESSOR is called because HANDLE_END_OF_FILE could be called
/* from these routines, which in turn may non-local-goto END_OF_MAIN_FILE;
/* non-local-goto's rely upon the correct/current display-pointer being
/* available for all procedure calls leading up to the non-local-goto.
/**/

GET_NEXT_LEXICAL_TOKEN	  = I_GET_NEXT_LEXICAL_TOKEN;
GET_NEXT_EXPANDED_TOKEN	  = I_GET_NEXT_EXPANDED_TOKEN;
GET_NEXT_UNEXPANDED_TOKEN = I_GET_NEXT_UNEXPANDED_TOKEN;

/* Set up the default token-pod reading routine */

if IN_GET_NEXT_LEXICAL_TOKEN then
	GET_NEXT_PP_TOKEN = GET_NEXT_LEXICAL_TOKEN;
else	GET_NEXT_PP_TOKEN = GET_NEXT_MACRO_TOKEN;

/* ----------------------------
/* Initialize the preprocessor.
/* -------------------------- */

if FIRST_TIME then do;

	/* See if we've already reached end-of-file */

	if AT_EOF then do;
		call TPUT (GET_EOF_TOKEN ());
		return;
	end;

	/* Initialize the maximum number of tokens to be processed at a time */

	if      PP_MAX_TOKENS = 0 then PP_MAX_TOKENS = DEFAULT_MAX_TOKENS;
	else if PP_MAX_TOKENS < 0 then PP_MAX_TOKENS = WICKED_LOT_OF_TOKENS;

	/* Open the main source file */

	if ^OPEN_SOURCE (SOURCE_FILE_NAME, MAIN_SK) then do;
		call PP_ERROR_I (ERR_PP_NO_MAIN_FILE, SOURCE_FILE_NAME);
		return;
	end;
	else	call PUT_BOF_TOKEN ();

	/* Initialize the ANSI-C/C++ keyword lookup routines */

	call INITIALIZE_KEYWORD_TABLES ();

	/* Set up the default input reading/scanning routines */

	GET_NEXT_CHAR	= SNEXTC; /* To read get next C character */
	SCAN_NEXT_CHAR	= SSCANC; /* To scan vanilla C character */
	SCAND_NEXT_CHAR	= SSCAND; /* To scan vanilla pp-directive character */
	SCANP_NEXT_CHAR	= SSCANP; /* To scan #define pp-directive character */
	PUSH_BACK_CHAR	= SBACKC; /* To push back character onto input */

	/* Set up dummy token-pod pointers */

	WHITE_SPACE_TOKEN	 = addr (DUMMY_WHITE_SPACE);
	END_PP_DIRECTIVE_TOKEN	 = addr (DUMMY_END_PP_DIRECTIVE);
	END_MACRO_ARGUMENT_TOKEN = addr (DUMMY_END_MACRO_ARGUMENT);
	END_BUFFER_TOKEN	 = addr (DUMMY_END_BUFFER);

	/* Set up any pre-defined macros */

	call PRE_DEFINE_MACROS ();

	/* Set up any startup include files */

	call OPEN_STARTUP_INCLUDE_FILES ();
 
	/*
	/* If the "-predef" option was given but nothing was implicitly
	/* included (e.g. via SW_SYSTEM_MACROS, SW_ISTRING, SW_IMATH,
	/* or STARTUP_INCLUDE_FILE), then simply return immediately
	/* without processing the main source file.
	/**/

	if SW_DUMP_PREDEF_MACROS then do;
		if CURRENT_SOURCE.INCLUDE_LEVEL = 0 then do;
			FIRST_TIME = FALSE;
			return;
		end;
	end;

	FIRST_TIME = FALSE;
end;

/* Save the current node id (necessary only if PP_MAX_TOKENS is small) */

call SAVE_NODE (SNID);

/* ---------------------------------------------------
/* Fill up the token-pod stream buffer.  Send out up
/* to PP_MAX_TOKENS token-pods to the token-pod stream.
/* -------------------------------------------------- */

do NTOKENS = 1 while (NTOKENS <= PP_MAX_TOKENS);

	/* ---------------------------------
	/* Get a fully macro expanded token.
	/* ------------------------------- */

	TP = GET_NEXT_EXPANDED_TOKEN ();

	/* -----------------------------------------------
	/* Get rid of any preceding white space indicator.
	/* --------------------------------------------- */

	if TP->TOKEN_POD.LINE < 0 then do;
		if TP->TOKEN_POD.TYPE ^= LINE_FILE_TOKEN then
			TP->TOKEN_POD.LINE = -(TP->TOKEN_POD.LINE);
	end;
	
	/* ------------------------------------------------------
	/* Send this final token-pod out to the token-pod stream.
	/* ---------------------------------------------------- */

	call TPUT (TP);

	/* -----------------------------------------------------------
	/* Increment the total number of token-pods sent out thus far.
	/* --------------------------------------------------------- */

	NTOKENS = NTOKENS + 1;

	/* -----------------------
	/* Check for end-of-file.
	/* -------------------- */

	if TP->TOKEN_POD.TYPE = EOF_TOKEN then
		goto END_OF_MAIN_FILE;
end;

/* --------------------------------------------------
/* Here, we've sent out the number of tokens desired.
/* Save the preprocessor state and return.
/* ------------------------------------------------ */

IN_GET_NEXT_LEXICAL_TOKEN = (GET_NEXT_PP_TOKEN = GET_NEXT_LEXICAL_TOKEN);
call RESTORE_NODE (SNID);
return;

/* ----------------------------------------------------------
/* Here, we've hit the end-of-include with PP_MAX_TOKENS = 1.
/* -------------------------------------------------------- */

END_OF_INCLUDE_FILE:

IN_GET_NEXT_LEXICAL_TOKEN = (GET_NEXT_PP_TOKEN = GET_NEXT_LEXICAL_TOKEN);
call RESTORE_NODE (SNID);
return;

/* -------------------------------------
/* Here, we've hit the end-of-main-file.
/* ----------------------------------- */

END_OF_MAIN_FILE:

/* Set the appropriate flags (in case we get called again) */

AT_EOF     = TRUE;
FIRST_TIME = TRUE;

call RESTORE_NODE (SNID);
return;

/***********************************************************************
/* Source file opening and closing routines
/***********************************************************************/

/* =====================================================================
/* OPEN_SOURCE
/*
/* Tries to open the named source file, if all is well then returns
/* TRUE otherwise returns FALSE.
/* =================================================================== */

OPEN_SOURCE: procedure (FILE_NAME, KIND) returns (type (BOOL_T));

	declare
		FILE_NAME			character (*) varying,
		KIND				type (SHORT_T);
	declare
		TP				type (POINTER_T),
		LINES				type (LONG_T),
		LEVEL				type (SHORT_T),
		LINE_ON_WHICH_FILE_WAS_INCLUDED	type (LONG_T);

	if KIND = MAIN_OR_STARTUP_HEADER_SK then do;
		LINE_ON_WHICH_FILE_WAS_INCLUDED = 0;
		goto DO_OPEN_SOURCE;
	end;

	LINE_ON_WHICH_FILE_WAS_INCLUDED = CURRENT_SOURCE.PHYSICAL_LINE;

	if SHOULD_SKIP_FILE (FILE_NAME, LINES) then do;
		/*
		/* We can skip this file because it has been #included
		/* before, and we saw that it was entirely enclosed in a
		/* #ifndef/#endif pair, and the #ifndef macro is currently
		/* defined.  We still send out a BOF_INCLUDE/EOF_INCLUDE
		/* token pair; also, update the total source line count.
		/**/
		if SW_PRINT_FILE_NAME_AS_WE_GO then
			call WRITE_ERROR_LINE (FILE_NAME || ' (*)');
		call PUT_BOF_INCLUDE_TOKEN ();
		TP = TALLOC ();
		TP->TOKEN_POD.TYPE = EOF_INCLUDE_TOKEN;
		TP->TOKEN_POD.LINE = LINES;
		TP->TOKEN_POD.SPELLING_PTR = SALLOC (length (FILE_NAME));
		TP->TOKEN_POD.SPELLING_PTR->TOKEN_SPELLING_POD.SPELLING
			= FILE_NAME;
		TP->TOKEN_POD.SPELLING_PTR =
			addr (TP->TOKEN_POD.SPELLING_PTR->
			      TOKEN_SPELLING_POD.SPELLING);
		call TPUT (TP);
		TOTAL_LINES = TOTAL_LINES + LINES;
		return (TRUE);
	end;

	DO_OPEN_SOURCE:

	/*
	/* Open the file.  Pass indicator to lower level routines as to
	/* whether or not this file needs to have a listing file made;
	/* these lower level routines need to know this at open time.
	/**/

	if ^LISTING | (NO_INCLUDES & (KIND ^= MAIN_SK)) then
		LEVEL = XSOPEN (FILE_NAME, 0);
	else	LEVEL = XSOPEN (FILE_NAME, 1);

	if LEVEL <= 0 then
		return (FALSE);

	/* Here, we sucessfully opened the file */

	if SW_PRINT_FILE_NAME_AS_WE_GO then do;
		if (KIND = SYSTEM_HEADER_SK) | (KIND = C_HEADER_SK) then
			call WRITE_ERROR_LINE (FILE_NAME || ' (C)');
		else	call WRITE_ERROR_LINE (FILE_NAME);
	end;

	/* Set the no-trigraph-sequence-mapping bit if desired */

	if SW_X_NOTRIGRAPH then
		CURRENT_SOURCE.FLAG = CURRENT_SOURCE.FLAG + SRC_NO_TRIGRAPHS;

	/* Set the old-style token-pasting bit if desired */

	if SW_X_OLD_STYLE_TOKEN_PASTING then
		CURRENT_SOURCE.FLAG = CURRENT_SOURCE.FLAG +
				      SRC_OLD_TOKEN_PASTING;

	/* Set the C++ style comments flag if desired */

	if SW_C_PLUS_PLUS | SW_ALLOW_CXX_STYLE_COMMENTS then
		CURRENT_SOURCE.FLAG = CURRENT_SOURCE.FLAG + SRC_CXX_COMMENTS;

	/* Mark this file to be included just once if desired (-ionce) */

	if SW_INCLUDE_ONLY_ONCE then
		call RECORD_SKIPABLE_FILE (TRUE);

	/* Reset the flag to look for totally enclosing #ifndef/#endif's */

	CURRENT_SOURCE.LINE_OF_FIRST_CHAR = 0;

	/* Send out a bof-include token */

	call PUT_BOF_INCLUDE_TOKEN ();

	/* Handle special header kinds */

	if KIND = SYSTEM_HEADER_SK then do;
		if ^SW_NO_IMPLICIT_C_HEADER_MODE then
			call BEGIN_C_HEADER_MODE ();
		call OPEN_STANDARD_SYSTEM_HEADER_FILE ();
	end;
	else if KIND = C_HEADER_SK then
		call BEGIN_C_HEADER_MODE ();

	return (TRUE);

/* =====================================================================
/* PUT_BOF_INCLUDE_TOKEN
/* =================================================================== */

PUT_BOF_INCLUDE_TOKEN: procedure () internal;

	declare TP type (POINTER_T);

	TP = TALLOC ();
	TP->TOKEN_POD.TYPE = BOF_INCLUDE_TOKEN;
	TP->TOKEN_POD.SPELLING_PTR = SALLOC (length (FILE_NAME));
	TP->TOKEN_POD.SPELLING_PTR->TOKEN_SPELLING_POD.SPELLING = FILE_NAME;
	TP->TOKEN_POD.LINE = LINE_ON_WHICH_FILE_WAS_INCLUDED;
	call TPUT (TP);

end; /* PUT_BOF_INCLUDE_TOKEN */

end; /* OPEN_SOURCE */

/* =====================================================================
/* CLOSE_SOURCE
/*
/* Closes the current source file and pops it from the source file stack.
/* If this was an include file, the previous (including) source file will
/* be made current, and returns the level number (greater than 0) of the
/* now current source file.  If this was the main source file, returns 0.
/* =================================================================== */

CLOSE_SOURCE: procedure returns (type (SHORT_T)) internal;

	return (XSCLOSE ());

end; /* CLOSE_SOURCE */

/* =====================================================================
/* OPEN_STARTUP_INCLUDE_FILES
/* =================================================================== */

OPEN_STARTUP_INCLUDE_FILES: procedure internal;

	call OPEN_USER_INCLUDE_FILE ();
	call OPEN_INLINE_INCLUDE_FILES ();
	if SW_SYSTEM_MACROS then
		call OPEN_STANDARD_SYSTEM_HEADER_FILE ();
	return;

/* =====================================================================
/* OPEN_USER_INCLUDE_FILE
/*
/* Open the file specified by the user using the -include file_name
/* command-line option if given.
/* =================================================================== */

OPEN_USER_INCLUDE_FILE: procedure internal;

	if length (STARTUP_INCLUDE_FILE) <= 0 then
		return;
	if ^OPEN_SOURCE (STARTUP_INCLUDE_FILE, STARTUP_HEADER_SK) then do;
		call PP_ERROR_I (ERR_PP_NO_USER_STARTUP_FILE,
				 STARTUP_INCLUDE_FILE);
	end;

end; /* OPEN_USER_INCLUDE_FILE */

/* =====================================================================
/* OPEN_INLINE_INCLUDE_FILES
/* =================================================================== */

OPEN_INLINE_INCLUDE_FILES: procedure internal;

	declare S character (1024) varying;

	/* Include "imath.h" if the "-imath" option was given */

	if SW_IMATH then do;
		S = STANDARD_ANSI_C_HEADER_DIR ||
		    HOST_DIR_DELIM || IMATH_INCLUDE_FILE;
		if HOST_DIR_DELIM ^= TARGET_DIR_DELIM then
			S = translate (S, HOST_DIR_DELIM, TARGET_DIR_DELIM);
		if ^OPEN_SOURCE (S, C_HEADER_SK) then
			call PP_ERROR_I (ERR_PP_NO_IMATH_FILE, S);
	end;

	/* Include "istring.h" if the "-istring" option was given */

	if SW_ISTRING then do;
		S = STANDARD_ANSI_C_HEADER_DIR ||
		    HOST_DIR_DELIM || ISTRING_INCLUDE_FILE;
		if HOST_DIR_DELIM ^= TARGET_DIR_DELIM then
			S = translate (S, HOST_DIR_DELIM, TARGET_DIR_DELIM);
		if ^OPEN_SOURCE (S, C_HEADER_SK) then
			call PP_ERROR_I (ERR_PP_NO_ISTRING_FILE, S);
	end;

end; /* OPEN_INLINE_INCLUDE_FILES */

end; /* OPEN_STARTUP_INCLUDE_FILES */

/* =====================================================================
/* OPEN_STANDARD_SYSTEM_HEADER_FILE
/* =================================================================== */

OPEN_STANDARD_SYSTEM_HEADER_FILE: procedure internal;

	declare
		OPENED	type (BOOL_T) static internal initial (FALSE);
	declare
		S	character (1024) varying;

	if OPENED then
		return;
	S = STANDARD_ANSI_C_HEADER_DIR || HOST_DIR_DELIM ||
	    SYSDEF_INCLUDE_FILE;
	if HOST_DIR_DELIM ^= TARGET_DIR_DELIM then
		S = translate (S, HOST_DIR_DELIM, TARGET_DIR_DELIM);
	if ^OPEN_SOURCE (S, C_HEADER_SK) then
		;
	OPENED = TRUE;

end; /* OPEN_STANDARD_SYSTEM_HEADER_FILE */

/* =====================================================================
/* RECORD_SKIPABLE_FILE & SHOULD_SKIP_FILE
/* =================================================================== */

%replace MAX_SKIP_FILES		by 1024;

declare

NSKIP_FILES		type (SHORT_T) static internal initial (0),
SKIP_FILE_NAME		(MAX_SKIP_FILES) type (NID_T)
			static internal initial ((MAX_SKIP_FILES) (0)),
SKIP_FILE_MACRO		(MAX_SKIP_FILES) type (NID_T)
			static internal initial ((MAX_SKIP_FILES) (0)),
SKIP_FILE_NLINES	(MAX_SKIP_FILES) type (LONG_T)
			static internal initial ((MAX_SKIP_FILES) (0));

/* =====================================================================
/* SHOULD_SKIP_FILE
/* =================================================================== */

SHOULD_SKIP_FILE: procedure (NAME, NLINES) returns (type (BOOL_T));

	declare
		NAME	character (*) varying,
		NLINES	type (LONG_T);
	declare
		NAME_ID	type (NID_T),
		I	type (SHORT_T);

	NAME_ID = STORE_TOKEN (IDENTIFIER_TOKEN, NAME);

	do I = 1 to NSKIP_FILES;
		if SKIP_FILE_NAME (I) = 0 then
			leave;
		if SKIP_FILE_NAME (I) = NAME_ID then do;
			if SKIP_FILE_NLINES (I) < 0 then do;
				NLINES = 0;
				return (TRUE);
			end;
			else if IS_DEFINED_MACRO (SKIP_FILE_MACRO (I)) then do;
				NLINES = SKIP_FILE_NLINES (I);
				return (TRUE);
			end;
		end;
	end;
	return (FALSE);

end; /* SHOULD_SKIP_FILE */

/* =====================================================================
/* RECORD_SKIPABLE_FILE
/*
/* Record the current source file as being skippable.  The absolute
/* value of the the NLINES specifies the number of lines in the source
/* file.  In addition, if NLINES is negative then this source file is
/* to be skipped if it is ever included again (period), otherwise it
/* is to be skipped if it is ever included again iff the associated
/* macro is defined.
/* =================================================================== */

RECORD_SKIPABLE_FILE: procedure (UNCONDITIONALLY_SKIP);

	declare
		UNCONDITIONALLY_SKIP	type (BOOL_T);
	declare
		NAME_ID			type (NID_T),
		I			type (SHORT_T);

	if NSKIP_FILES >= MAX_SKIP_FILES then
		return;

	NAME_ID = STORE_TOKEN
		  (IDENTIFIER_TOKEN, CURRENT_SOURCE.PHYSICAL_NAME->STR);

	do I = 1 to NSKIP_FILES;
		if SKIP_FILE_NAME (I) = NAME_ID then
			return;
	end;

	NSKIP_FILES = NSKIP_FILES + 1;

	SKIP_FILE_NAME (NSKIP_FILES) = NAME_ID;

	if ^UNCONDITIONALLY_SKIP then do;
		SKIP_FILE_MACRO (NSKIP_FILES) =
			CURRENT_SOURCE.ENCLOSING_MACRO;
		SKIP_FILE_NLINES (NSKIP_FILES) =
			CURRENT_SOURCE.PHYSICAL_LINE - 1;
	end;
	else	SKIP_FILE_NLINES (NSKIP_FILES) = -1;

end; /* RECORD_SKIPABLE_FILE */

/***********************************************************************
/* Miscellaneous token-put routines
/***********************************************************************/

/* =====================================================================
/* BEGIN_C_HEADER_MODE
/* =================================================================== */

BEGIN_C_HEADER_MODE: procedure internal;

	declare
		DEFINED_STDC			type (BOOL_T)
						static internal;
	declare
		1 SAVE_SW			static internal,
		  2 X_TRAILING_TEXT		type (BOOL_T),
		  2 ALLOW_ASSERT_DIRECTIVE	type (BOOL_T),
		  2 ALLOW_ONCE_DIRECTIVE	type (BOOL_T),
		  2 IDENT_NOWARN		type (BOOL_T),
		  2 X_INNOCUOUS_MACRO_REDEF	type (BOOL_T),
		  2 X_IGNORE_GRAY_SPACE		type (BOOL_T),
		  2 PRAGMA_WARN			type (BOOL_T);

	/* See if we're already in C-header mode */

	if C_HEADER_MODE_INCLUDE_LEVEL >= 0 then
		return;

	/* Mark the include level at which C-header mode began */

	C_HEADER_MODE_INCLUDE_LEVEL = CURRENT_SOURCE.INCLUDE_LEVEL;

	/* Send a #pragma LPI C-header (on) token to the front-end */

	call  PUT_PRAGMA_TOKEN (PRAGMA_C_HEADER_PK, 1);

	/* Save/reset the appropriate C-header mode attributes */

	/* Set __STDC__ to 0 (or 1 if old way) iff not already defined */

	if SW_DEFINE_C_HEADER_STDC_AS_ZERO |
	   SW_DEFINE_C_HEADER_STDC_AS_ONE then do;
		if LOOKUP_MACRO (STDC_PP_KW_NAME) = null () then do;
			if SW_DEFINE_C_HEADER_STDC_AS_ZERO then
				call DEFINE_STDC_MACRO_AS_ZERO ();
			else	call DEFINE_STDC_MACRO ();
			DEFINED_STDC = TRUE;
		end;
		else	DEFINED_STDC = FALSE;
	end;
	else	DEFINED_STDC = FALSE;

	SAVE_SW.X_TRAILING_TEXT		= SW_X_TRAILING_TEXT;
	SAVE_SW.ALLOW_ASSERT_DIRECTIVE	= SW_ALLOW_ASSERT_DIRECTIVE;
	SAVE_SW.ALLOW_ONCE_DIRECTIVE	= SW_ALLOW_ONCE_DIRECTIVE;
	SAVE_SW.IDENT_NOWARN		= SW_IDENT_NOWARN;
	SAVE_SW.X_INNOCUOUS_MACRO_REDEF	= SW_X_INNOCUOUS_MACRO_REDEF;
	SAVE_SW.X_IGNORE_GRAY_SPACE	= SW_X_IGNORE_GRAY_SPACE;
	SAVE_SW.PRAGMA_WARN		= SW_PRAGMA_WARN;

	SW_X_TRAILING_TEXT		= TRUE;
	SW_ALLOW_ASSERT_DIRECTIVE	= TRUE;
	SW_ALLOW_ONCE_DIRECTIVE		= TRUE;
	SW_IDENT_NOWARN			= TRUE;
	SW_X_INNOCUOUS_MACRO_REDEF	= TRUE;
	SW_X_IGNORE_GRAY_SPACE		= TRUE;
	SW_PRAGMA_WARN			= FALSE;

	return;

/* =====================================================================
/* CHECK_FOR_END_OF_C_HEADER_MODE
/* =================================================================== */

CHECK_FOR_END_OF_C_HEADER_MODE: entry;

	/*
	/* Make sure we're at the same include
	/* level at which C-header mode began.
	/**/

	if C_HEADER_MODE_INCLUDE_LEVEL ^= CURRENT_SOURCE.INCLUDE_LEVEL then
		return;

/* =====================================================================
/* END_C_HEADER_MODE
/* =================================================================== */

END_C_HEADER_MODE: entry;

	if C_HEADER_MODE_INCLUDE_LEVEL < 0 then
		return;

	/*
	/* Set the C-header mode include level to
	/* indicate that we're no longer in C-header mode
	/**/

	C_HEADER_MODE_INCLUDE_LEVEL = -1;

	/* Send a #pragma LPI C-header (off) token to the front-end */

	call  PUT_PRAGMA_TOKEN (PRAGMA_C_HEADER_PK, 0);

	/* Restore the appropriate pre-C-header mode attributes */

	if DEFINED_STDC then
		call UNDEF_MACRO (STDC_PP_KW_NAME);

	SW_X_TRAILING_TEXT		= SAVE_SW.X_TRAILING_TEXT;
	SW_ALLOW_ASSERT_DIRECTIVE	= SAVE_SW.ALLOW_ASSERT_DIRECTIVE;
	SW_ALLOW_ONCE_DIRECTIVE		= SAVE_SW.ALLOW_ONCE_DIRECTIVE;
	SW_IDENT_NOWARN			= SAVE_SW.IDENT_NOWARN;
	SW_X_INNOCUOUS_MACRO_REDEF	= SAVE_SW.X_INNOCUOUS_MACRO_REDEF;
	SW_X_IGNORE_GRAY_SPACE		= SAVE_SW.X_IGNORE_GRAY_SPACE;
	SW_PRAGMA_WARN			= SAVE_SW.PRAGMA_WARN;

	return;

end; /* BEGIN_C_HEADER_MODE */

/* =====================================================================
/* PUT_TOGGLE_PRAGMA_TOKEN
/* =================================================================== */

PUT_TOGGLE_PRAGMA_TOKEN: procedure (PRAGMA_KIND, S) internal;

	declare
		PRAGMA_KIND	type (SHORT_T),
		S		character (*) varying;
	declare
		VALUE		type (SHORT_T),
		TP		type (POINTER_T);

	if S = 'on' then
		VALUE = 1;
	else if S = 'off' then
		VALUE = 0;
	else	call PP_ERROR (ERR_PP_MALFORMED_PRAGMA);

	TP = TALLOC ();
	TP->TOKEN_POD.TYPE = PRAGMA_TOKEN;
	TP->TOKEN_POD.VALUE_ONE = byte (PRAGMA_KIND);
	TP->TOKEN_POD.VALUE_TWO = byte (VALUE);
	call TPUT (TP);

end; /* PUT_TOGGLE_PRAGMA_TOKEN */

/* =====================================================================
/* PUT_SIMPLE_PRAGMA_TOKEN
/* =================================================================== */

PUT_SIMPLE_PRAGMA_TOKEN: procedure (PRAGMA_KIND) internal;

	declare
		PRAGMA_KIND	type (SHORT_T);
	declare
		TP		type (POINTER_T);

	TP = TALLOC ();
	TP->TOKEN_POD.TYPE = PRAGMA_TOKEN;
	TP->TOKEN_POD.VALUE_ONE = byte (PRAGMA_KIND);
	call TPUT (TP);

end; /* PUT_SIMPLE_PRAGMA_TOKEN */

/* =====================================================================
/* PUT_PRAGMA_TOKEN
/* =================================================================== */

PUT_PRAGMA_TOKEN: procedure (PRAGMA_KIND, VALUE) internal;

	declare
		PRAGMA_KIND	type (SHORT_T),
		VALUE		type (SHORT_T);
	declare
		TP		type (POINTER_T);

	TP = TALLOC ();
	TP->TOKEN_POD.TYPE = PRAGMA_TOKEN;
	TP->TOKEN_POD.VALUE_ONE = byte (PRAGMA_KIND);
	TP->TOKEN_POD.VALUE_TWO = byte (VALUE);
	call TPUT (TP);

end; /* PUT_PRAGMA_TOKEN */

/* =====================================================================
/* PUT_PRAGMA_WEAK_TOKEN
/* =================================================================== */

PUT_PRAGMA_WEAK_TOKEN: procedure (WEAK_NAME, STRONG_NAME) internal;

	declare
		WEAK_NAME	type (NID_T),
		STRONG_NAME	type (NID_T);
	declare
		TP		type (POINTER_T);

	TP = TALLOC ();
	TP->TOKEN_POD.TYPE       = PRAGMA_TOKEN;
	TP->TOKEN_POD.VALUE_ONE  = byte (PRAGMA_WEAK_PK);
	TP->TOKEN_POD.VALUE_FIVE = WEAK_NAME;
	TP->TOKEN_POD.VALUE_SIX  = STRONG_NAME;
	call TPUT (TP);

end; /* PUT_PRAGMA_WEAK_TOKEN */

/* =====================================================================
/* PUT_PRAGMA_DATA_SECTION_TOKEN
/* =================================================================== */

PUT_PRAGMA_DATA_SECTION_TOKEN: procedure (NAME,
					  ATTRIBUTES,
					  ALIGNMENT,
					  ADDRESS)
			       internal;
	declare
		NAME		type (NID_T),
		ATTRIBUTES	type (LONG_T),
		ALIGNMENT	type (LONG_T),
		ADDRESS		type (LONG_T);
	declare
		P		type (POINTER_T),
		TP		type (POINTER_T);
	declare
		LAST_NAME	type (NID_T)
				static internal initial (NULL_ID),
		LAST_ATTRIBUTES	type (LONG_T)
				static internal initial (0),
		LAST_ALIGNMENT	type (LONG_T)
				static internal initial (0),
		LAST_ADDRESS	type (LONG_T)
				static internal initial (0);

	%include GBL_DATA_SECTION_NODE_IN;

	allocate DATA_SECTION_NODE set (P);

	P->DATA_SECTION_NODE.NAME	= NAME;
	P->DATA_SECTION_NODE.ATTRIBUTES	= ATTRIBUTES;
	P->DATA_SECTION_NODE.ALIGNMENT	= ALIGNMENT;
	P->DATA_SECTION_NODE.ADDRESS	= ADDRESS;
	P->DATA_SECTION_NODE.LINE	= CURRENT_SOURCE.PHYSICAL_LINE;

	TP = TALLOC ();
	TP->TOKEN_POD.TYPE        = PRAGMA_TOKEN;
	TP->TOKEN_POD.VALUE_ONE   = byte (PRAGMA_DATA_SECTION_PK);
	TP->TOKEN_POD.VALUE_SEVEN = P;
	call TPUT (TP);

	LAST_NAME	= NAME;
	LAST_ATTRIBUTES	= ATTRIBUTES;
	LAST_ALIGNMENT	= ALIGNMENT;
	LAST_ADDRESS	= ADDRESS;
	return;

GET_LAST_PRAGMA_DATA_SECTION: entry (NAME, ATTRIBUTES, ALIGNMENT, ADDRESS);

	NAME		= LAST_NAME;
	ATTRIBUTES	= LAST_ATTRIBUTES;
	ALIGNMENT	= LAST_ALIGNMENT;
	ADDRESS		= LAST_ADDRESS;
	return;

end; /* PUT_PRAGMA_DATA_SECTION_TOKEN */

/* =====================================================================
/* PUT_BOF_TOKEN
/* =================================================================== */

PUT_BOF_TOKEN: procedure;

	declare TP type (POINTER_T);

	TP = TALLOC ();
	TP->TOKEN_POD.TYPE = BOF_TOKEN;
	call TPUT (TP);

end; /* PUT_BOF_TOKEN */

/***********************************************************************
/* Miscellaneous token-get routines
/***********************************************************************/

/* =====================================================================
/* GET_EOF_TOKEN
/*
/* Create and return an EOF token-pod.
/* =================================================================== */

GET_EOF_TOKEN: procedure returns (type (POINTER_T));

	declare TP type (POINTER_T);

	TP = TALLOC ();
	TP->TOKEN_POD.TYPE = EOF_TOKEN;
	TP->TOKEN_POD.LINE = CURRENT_SOURCE.PHYSICAL_LINE - 1;
	TP->TOKEN_POD.SPELLING_PTR = CURRENT_SOURCE.PHYSICAL_NAME;
	return (TP);

end; /* GET_EOF_TOKEN */

/* =====================================================================
/* GET_CONSTANT_ZERO_TOKEN
/*
/* Create and return a (pointer to a) token-pod
/* representing the decimal constant 0 (zero).
/* =================================================================== */

GET_CONSTANT_ZERO_TOKEN: procedure returns (type (POINTER_T));

	declare TP type (POINTER_T);

	TP = TALLOC ();
	TP->TOKEN_POD.TYPE = DECIMAL_CONSTANT_TOKEN;
	TP->TOKEN_POD.SPELLING_PTR = SALLOC (1);
	TP->TOKEN_POD.SPELLING_PTR->TOKEN_SPELLING_POD.SPELLING = '0';
	TP->TOKEN_POD.LINE = CURRENT_SOURCE.PHYSICAL_LINE;
	return (TP);

end; /* GET_CONSTANT_ZERO_TOKEN */

/* =====================================================================
/* GET_CONSTANT_ONE_TOKEN
/*
/* Create and return a (pointer to a) token-pod
/* representing the decimal constant 1 (one).
/* =================================================================== */

GET_CONSTANT_ONE_TOKEN: procedure returns (type (POINTER_T));

	declare TP type (POINTER_T);

	TP = TALLOC ();
	TP->TOKEN_POD.TYPE = DECIMAL_CONSTANT_TOKEN;
	TP->TOKEN_POD.SPELLING_PTR = SALLOC (1);
	TP->TOKEN_POD.SPELLING_PTR->TOKEN_SPELLING_POD.SPELLING = '1';
	TP->TOKEN_POD.LINE = CURRENT_SOURCE.PHYSICAL_LINE;
	return (TP);

end; /* GET_CONSTANT_ONE_TOKEN */

/* =====================================================================
/* PRE_DEFINE_MACROS
/*
/* Set up pre-defined compiler macros.
/* =================================================================== */

PRE_DEFINE_MACROS: procedure internal;

	call PRE_DEFINE_COMPILER_MACROS ();
	call PRE_DEFINE_INLINE_MACROS ();
	call PROCESS_COMMAND_LINE_DIRECTIVES ();

/* =====================================================================
/* PRE_DEFINE_COMPILER_MACROS
/*
/* Define all of the predefined macros;
/* __LINE__, __FILE__, __DATE__, __TIME__, etc.
/* =================================================================== */

PRE_DEFINE_COMPILER_MACROS: procedure;

	declare MP type (POINTER_T);
	
	/* #define __LPI__ */

	call DEFINE_MACRO_AS_ONE ('__LPI__');

	/* #define __STDC__ to be 1 iff ANSI-C mode or -stdc */

	if SW_DEFINE_STDC_AS_ONE then
		call DEFINE_STDC_MACRO ();

	/* #define __cplusplus and __LPI_CXX__ iff C++ mode */

	if SW_C_PLUS_PLUS then do;
		if SW_USE_OLD_CXX_STREAM_HEADER then do;
			call DEFINE_MACRO_AS_ONE
			     ('__LPI_CXX_OLD_STREAM_HEADER__');
		end;
		call DEFINE_MACRO_AS_ONE ('__cplusplus');
		if SW_DEFINE_OLD_CPLUSPLUS_MACRO then
			call DEFINE_MACRO_AS_ONE ('c_plusplus');
		call DEFINE_MACRO_AS_ONE ('__LPI_CXX__');
	end;

	/* #define __LPI_CLASSIC_C__ iff -classicc mode */

	if SW_CLASSIC_C_MODE then
		call DEFINE_MACRO_AS_ONE ('__LPI_CLASSIC_C__');

	/* #define __LPI_ANSI_C__ iff -ansic mode */

	if SW_ANSI_C_MODE then
		call DEFINE_MACRO_AS_ONE ('__LPI_ANSI_C__');

	/* #define __LPI_ANSI_C_LIB__ iff -ansiclib mode */

	if ^SW_FAVOR_SYSTEM_HEADER_DIR then
		call DEFINE_MACRO_AS_ONE ('__LPI_ANSI_C_LIB__');

	/* #define __LPI_CXX_USE_SYSTEM_LIBRARY__ iff -sys mode */

	/* OBSOLETE: stdstr.cxx filebf.cxx new.h use it; TODO */

	if SW_FAVOR_SYSTEM_HEADER_DIR then
		call DEFINE_MACRO_AS_ONE ('__LPI_SYSTEM_LIB__');

	/* #define __STDCPP__ & __ANSI_CPP__ to be 1 iff SW_DEFINE_STDCPP */

	if SW_DEFINE_STDCPP then do;
		call DEFINE_MACRO_AS_ONE ('__STDCPP__');
		call DEFINE_MACRO_AS_ONE ('__ANSI_CPP__');
	end;
	
	/* #define _POSIX_SOURCE iff -posix */

	if SW_POSIX_MODE then
		call DEFINE_MACRO_AS_ONE ('_POSIX_SOURCE');

	/* #define __LINE__, __FILE__, __DATE__, __TIME__ */

	MP = DEFINE_MACRO (STORE_TOKEN (IDENTIFIER_TOKEN, '__LINE__'));
	MP->MACRO_NODE.GET_TOKEN	= GET_LINE_TOKEN;
	MP->MACRO_NODE.KIND		= DYNAMIC_MACRO_MK;

	MP = DEFINE_MACRO (STORE_TOKEN (IDENTIFIER_TOKEN, '__FILE__'));
	MP->MACRO_NODE.GET_TOKEN	= GET_FILE_TOKEN;
	MP->MACRO_NODE.KIND		= DYNAMIC_MACRO_MK;

	MP = DEFINE_MACRO (STORE_TOKEN (IDENTIFIER_TOKEN, '__DATE__'));
	MP->MACRO_NODE.GET_TOKEN	= GET_DATE_TOKEN;
	MP->MACRO_NODE.KIND		= DYNAMIC_MACRO_MK;

	MP = DEFINE_MACRO (STORE_TOKEN (IDENTIFIER_TOKEN, '__TIME__'));
	MP->MACRO_NODE.GET_TOKEN	= GET_TIME_TOKEN;
	MP->MACRO_NODE.KIND		= DYNAMIC_MACRO_MK;

/* =====================================================================
/* GET_LINE_TOKEN
/*
/* Create and return a token representing the appropriate value
/* for the predefined macro __LINE__.
/* =================================================================== */

GET_LINE_TOKEN: procedure returns (type (POINTER_T));

	declare
		TP	type (POINTER_T),
		L	type (LONG_T),
		S	character (12) varying;

	L = CURRENT_SOURCE.PHYSICAL_LINE +
	    CURRENT_SOURCE.LINE_ADJUSTMENT;
	S = trim (character (L));
	TP = TALLOC ();
	TP->TOKEN_POD.TYPE = DECIMAL_CONSTANT_TOKEN;
	TP->TOKEN_POD.SPELLING_PTR = SALLOC (length (S) + 1);
	TP->TOKEN_POD.SPELLING_PTR->TOKEN_SPELLING_POD.SPELLING = S;
	TP->TOKEN_POD.LINE = CURRENT_SOURCE.PHYSICAL_LINE;
	return (TP);

end; /* GET_LINE_TOKEN */

/* =====================================================================
/* GET_FILE_TOKEN
/*
/* Create and return a token representing the appropriate value
/* for the predefined macro __FILE__.
/* =================================================================== */

GET_FILE_TOKEN: procedure returns (type (POINTER_T));

	declare
		TP	type (POINTER_T),
		S	character (4096) varying;

	if CURRENT_SOURCE.ASSUMED_NAME ^= null () then
		S = trim (CURRENT_SOURCE.ASSUMED_NAME->STR);
	else	S = trim (CURRENT_SOURCE.PHYSICAL_NAME->STR);
	TP = TALLOC ();
	TP->TOKEN_POD.TYPE = STRING_LITERAL_TOKEN;
	TP->TOKEN_POD.SPELLING_PTR = SALLOC (length (S) + 1);
	TP->TOKEN_POD.SPELLING_PTR->TOKEN_SPELLING_POD.SPELLING = S;
	TP->TOKEN_POD.LINE = CURRENT_SOURCE.PHYSICAL_LINE;
	return (TP);

end; /* GET_FILE_TOKEN */

/* =====================================================================
/* GET_DATE_TOKEN
/*
/* Create and return a token representing the appropriate value
/* for the predefined macro __DATE__.
/* =================================================================== */

GET_DATE_TOKEN: procedure returns (type (POINTER_T));

	declare
		date	builtin;
	declare
		TP	type (POINTER_T),
		D	character (6) varying,
		S	character (12) varying static internal initial (''),
		MONTH	(1 : 12) character (3) static internal initial
			( 'Jan' , 'Feb' , 'Mar' , 'Apr' , 'May' , 'Jun'
			, 'Jul' , 'Aug' , 'Sep' , 'Oct' , 'Nov' , 'Dec' );

	if S = '' then do;
		D = date ();  /* yymmdd */
		if substr (D, 5, 1) = '0' then substr (D, 5, 1) = ' ';
		S = MONTH (binary (substr (D, 3, 2), 15)) || ' ' ||
		    substr (D, 5, 2) || ' 19' || substr (D, 1, 2);
	end;
	TP = TALLOC ();
	TP->TOKEN_POD.TYPE = STRING_LITERAL_TOKEN;
	TP->TOKEN_POD.SPELLING_PTR = SALLOC (length (S) + 1);
	TP->TOKEN_POD.SPELLING_PTR->TOKEN_SPELLING_POD.SPELLING = S;
	TP->TOKEN_POD.LINE = CURRENT_SOURCE.PHYSICAL_LINE;
	return (TP);

end; /* GET_DATE_TOKEN */

/* =====================================================================
/* GET_TIME_TOKEN
/*
/* Create and return a token representing the appropriate value
/* for the predefined macro __TIME__.
/* =================================================================== */

GET_TIME_TOKEN: procedure returns (type (POINTER_T));

	declare
		time	builtin;
	declare
		TP	type (POINTER_T),
		T	character (6) varying,
		S	character (12) varying static internal initial ('');

	if S = '' then do;
		T = time ();  /* hhmmss */
		S = substr (T, 1, 2) || ':' ||
		    substr (T, 3, 2) || ':' || substr (T, 5, 2);
	end;
	TP = TALLOC ();
	TP->TOKEN_POD.TYPE = STRING_LITERAL_TOKEN;
	TP->TOKEN_POD.SPELLING_PTR = SALLOC (length (S) + 1);
	TP->TOKEN_POD.SPELLING_PTR->TOKEN_SPELLING_POD.SPELLING = S;
	TP->TOKEN_POD.LINE = CURRENT_SOURCE.PHYSICAL_LINE;
	return (TP);

end; /* GET_TIME_TOKEN */

end; /* PRE_DEFINE_COMPILER_MACROS */

/* =====================================================================
/* PRE_DEFINE_INLINE_MACROS
/*
/* Define other predefined macros.
/* =================================================================== */

PRE_DEFINE_INLINE_MACROS: procedure;

	declare MP type (POINTER_T);

	if SW_IMATH then do;	/* -imath */
		MP = DEFINE_MACRO (STORE_TOKEN (IDENTIFIER_TOKEN,
						'__LPI_IMATH__'));
		MP->MACRO_NODE.REPLACEMENT = null ();
        end;
	if SW_ISTRING then do;	/* -istring */
		MP = DEFINE_MACRO (STORE_TOKEN (IDENTIFIER_TOKEN,
						'__LPI_ISTRING__'));
		MP->MACRO_NODE.REPLACEMENT = null ();
        end;

end; /* PRE_DEFINE_INLINE_MACROS */

/* =====================================================================
/* DEFINE_MACRO_AS_ZERO
/* =================================================================== */

DEFINE_MACRO_AS_ZERO: procedure (S) internal;

	declare
		S	character (*) varying;
	declare
		MP	type (POINTER_T);

	MP = DEFINE_MACRO (STORE_TOKEN (IDENTIFIER_TOKEN, S));
	MP->MACRO_NODE.GET_TOKEN	= GET_CONSTANT_ZERO_TOKEN;
	MP->MACRO_NODE.KIND		= DYNAMIC_MACRO_MK;

end; /* DEFINE_MACRO_AS_ZERO */

/* =====================================================================
/* DEFINE_MACRO_AS_ONE
/* =================================================================== */

DEFINE_MACRO_AS_ONE: procedure (S) internal;

	declare
		S	character (*) varying;
	declare
		MP	type (POINTER_T);

	MP = DEFINE_MACRO (STORE_TOKEN (IDENTIFIER_TOKEN, S));
	MP->MACRO_NODE.GET_TOKEN	= GET_CONSTANT_ONE_TOKEN;
	MP->MACRO_NODE.KIND		= DYNAMIC_MACRO_MK;

end; /* DEFINE_MACRO_AS_ONE */

/* =====================================================================
/* PROCESS_COMMAND_LINE_DIRECTIVES
/*
/* Process the "-define" and "-undefine" command line directives.
/* =================================================================== */

PROCESS_COMMAND_LINE_DIRECTIVES: procedure;

	declare
                K                       type (SHORT_T),
                RAW_STRING              character (80) varying;
	declare
		TP			type (POINTER_T),
		EQPOS			type (SHORT_T);
	declare
		BUFFER			character (4096) varying,
		BUFFER_INDEX		type (SHORT_T),
		BUFFER_SIZ		type (SHORT_T);
	declare
		SAVE_GET_NEXT_CHAR 	entry returns (type (SHORT_T))
					variable,
		SAVE_SCAN_NEXT_CHAR 	entry returns (type (SHORT_T))
					variable,
		SAVE_SCANP_NEXT_CHAR 	entry returns (type (SHORT_T))
					variable,
		SAVE_SCAND_NEXT_CHAR 	entry returns (type (SHORT_T))
					variable,
		SAVE_PUSH_BACK_CHAR 	entry (type (SHORT_T)) variable;

	do while (GET_DEFINE (K, RAW_STRING));

		/* ----------------------------------------------------
		/* -define name            ==>  #define name 1
		/* -define name=text       ==>  #define name text
       		/* -define name=           ==>  #define name
       		/* -define name(ids)       ==>  #define name(ids) 1
       		/* -define name(ids)=text  ==>  #define name(ids) text
       		/* -define name(ids)=      ==>  #define name(ids)
       		/* --------------------------------------------------- */

		if K ^= 0 then do;	/* define */

			EQPOS = index(RAW_STRING,'=');

			if EQPOS = 0 then
				BUFFER = 'define ' || RAW_STRING || ' 1';
			else do;
				BUFFER = 'define ' ||
					 substr (RAW_STRING, 1, EQPOS - 1);
				if length (RAW_STRING) > EQPOS then do;
					BUFFER = BUFFER || ' ' ||
						 substr (RAW_STRING,
							 EQPOS + 1);
				end;
			end;
		end;

		/* -----------------------------------------------------
		/* -undefine name  ==>  #undef name
		/* -undef name     ==>  #undef name
		/* --------------------------------------------------- */

		else	BUFFER = 'undef ' || RAW_STRING;

		BUFFER = BUFFER || byte (NEWLINE_CHAR);
		BUFFER_SIZ = length (BUFFER);
		BUFFER_INDEX = 1;

		/* --------------------------------------------------------
		/* Now that we have built the directive buffer, process it.
		/* ------------------------------------------------------ */

		/* Save and switch the lexical context */

		SAVE_GET_NEXT_CHAR	= GET_NEXT_CHAR;
		SAVE_SCAN_NEXT_CHAR	= SCAN_NEXT_CHAR;
		SAVE_SCANP_NEXT_CHAR	= SCANP_NEXT_CHAR;
		SAVE_SCAND_NEXT_CHAR	= SCAND_NEXT_CHAR;
		SAVE_PUSH_BACK_CHAR	= PUSH_BACK_CHAR;

		GET_NEXT_CHAR		= NEXTC_FROM_BUFFER;
		SCAN_NEXT_CHAR		= SCANP_FROM_BUFFER;
		SCANP_NEXT_CHAR		= SCANP_FROM_BUFFER;
		SCAND_NEXT_CHAR		= SCAND_FROM_BUFFER;
		PUSH_BACK_CHAR		= BACKC_FROM_BUFFER;

		/* Process the directive */

		TP = READ_PP_DIRECTIVE ();

		/* Restore the lexical context */

		GET_NEXT_CHAR		= SAVE_GET_NEXT_CHAR;
		SCAN_NEXT_CHAR		= SAVE_SCAN_NEXT_CHAR;
		SCANP_NEXT_CHAR		= SAVE_SCANP_NEXT_CHAR;
		SCAND_NEXT_CHAR		= SAVE_SCAND_NEXT_CHAR;
		PUSH_BACK_CHAR		= SAVE_PUSH_BACK_CHAR;

	end; /* of while loop - while there are -define/-undef options */

	/* =============================================================
	/* GET_DEFINE
	/*
	/* Return the define/undefine argument for processing.
        /* (See PUT_DEFINE in xinife.pl1)
	/* =========================================================== */

        GET_DEFINE: procedure (TYPE, VALUE) returns (type (BOOL_T));

		declare
			TYPE		type (SHORT_T),
			VALUE		character (*) varying;
		declare
			1 DEFINE_ITEM	based (P),
			  2 NEXT	type (POINTER_T),
			  2 TYPE	type (SHORT_T),
			  2 VALUE	character (80) varying;
		declare
			P		type (POINTER_T);

		/* Remove from head of list */

		P = DEFINE_LIST.HEAD;
		if P = null () then return (FALSE);
		TYPE  = DEFINE_ITEM.TYPE;
		VALUE = DEFINE_ITEM.VALUE;
		DEFINE_LIST.HEAD = DEFINE_ITEM.NEXT;
		return (TRUE);

	end GET_DEFINE;

	/* =============================================================
	/* NEXTC_FROM_BUFFER
	/*
	/* Return the next character from the internal character buffer.
	/* =========================================================== */

	NEXTC_FROM_BUFFER: procedure returns (type (SHORT_T));

		declare C type (SHORT_T);

		if BUFFER_INDEX > BUFFER_SIZ then
			return (END_PP_DIRECTIVE_CHAR);
		C = rank (substr (BUFFER, BUFFER_INDEX, 1));
		BUFFER_INDEX = BUFFER_INDEX + 1;
		return (C);

	end NEXTC_FROM_BUFFER;

	/* =============================================================
	/* SCANP_FROM_BUFFER
	/*
	/* This routine (analogous to SSCANP) is used to scan to the
	/* next relevant input character when we are within a command-
	/* line preprocessing directive.  Returns from the internal
	/* buffer, one of the following:
	/*
	/*	Next relevant character
	/*	END_PP_DIRECTIVE_CHAR
	/*
	/* Note that comments are not skipped here, and we don't mess
	/* around with differentiate between gray-space from white-space.
	/* =========================================================== */

	SCANP_FROM_BUFFER: procedure returns (type (SHORT_T));

		declare C type (SHORT_T);

		do while (TRUE);
			C = SCAND_FROM_BUFFER ();
			if C ^= WHITE_SPACE_CHAR then
				return (C);
		end;

	end SCANP_FROM_BUFFER;

	/* =============================================================
	/* SCAND_FROM_BUFFER
	/*
	/* This routine (analogous to SSCAND) is used to scan to the next
	/* relevant input character when we are within a command-line
	/* macro definition.  Returns from the internal buffer, one of
	/* the following:
	/*
	/*	Next relevant character
	/*	WHITE_SPACE_CHAR (space|tab|formfeed|vtab|newline)
	/*	END_PP_DIRECTIVE_CHAR
	/*
	/* Note that comments are not skipped here, and we don't mess
	/* around with differentiating between gray-space and white-space.
	/* =========================================================== */

	SCAND_FROM_BUFFER: procedure returns (type (SHORT_T));

		declare C type (SHORT_T);
		declare SPACE type (BOOL_T);

		do SPACE = FALSE while (TRUE);
			if BUFFER_INDEX > BUFFER_SIZ then
				return (END_PP_DIRECTIVE_CHAR);
			C = rank (substr (BUFFER, BUFFER_INDEX, 1));
			BUFFER_INDEX = BUFFER_INDEX + 1;
			if (C = SPACE_CHAR) | (C = HORIZONTAL_TAB_CHAR) |
			   (C = FORMFEED_CHAR) | (C = VERTICAL_TAB_CHAR) |
			   (C = NEWLINE_CHAR) then
				SPACE = TRUE;
			else if SPACE then do;
				BUFFER_INDEX = BUFFER_INDEX - 1;
				return (WHITE_SPACE_CHAR);
			end;
			else	return (C);
		end;

	end SCAND_FROM_BUFFER;

	/* =============================================================
	/* BACKC_FROM_BUFFER
	/*
	/* Push back a character onto the internal character buffer.
	/* =========================================================== */

	BACKC_FROM_BUFFER: procedure (C);

		declare C type (SHORT_T);

		if BUFFER_INDEX > 1 then do;
			BUFFER_INDEX = BUFFER_INDEX - 1;
			substr (BUFFER, BUFFER_INDEX, 1) = byte (C);
		end;

	end BACKC_FROM_BUFFER;

end; /* PROCESS_COMMAND_LINE_DIRECTIVES */

end; /* PRE_DEFINE_MACROS */

/* =====================================================================
/* DEFINE_STDC_MACRO
/* =================================================================== */

DEFINE_STDC_MACRO: procedure internal;

	declare MP type (POINTER_T);

	MP = DEFINE_MACRO (STDC_PP_KW_NAME);
	if MP ^= null () then do;
		MP->MACRO_NODE.GET_TOKEN	= GET_CONSTANT_ONE_TOKEN;
		MP->MACRO_NODE.KIND		= DYNAMIC_MACRO_MK;
	end;

end; /* DEFINE_STDC_MACRO */

/* =====================================================================
/* DEFINE_STDC_MACRO_AS_ZERO
/* =================================================================== */

DEFINE_STDC_MACRO_AS_ZERO: procedure internal;

	declare MP type (POINTER_T);

	MP = DEFINE_MACRO (STDC_PP_KW_NAME);
	if MP ^= null () then do;
		MP->MACRO_NODE.GET_TOKEN	= GET_CONSTANT_ZERO_TOKEN;
		MP->MACRO_NODE.KIND		= DYNAMIC_MACRO_MK;
	end;

end; /* DEFINE_STDC_MACRO_AS_ZERO */

/***********************************************************************
** The ANSI-C lexical analyzer
************************************************************************/

/* =====================================================================
/* GET_NEXT_LEXICAL_TOKEN
/*
/* The ANSI-C lexical analyzer.  This routine will create, and return
/* a pointer to, a token-pod representing the next preprocessing token
/* from the source file.  Note that this routine pays no mind to the
/* macro invocation stack; if there is anything on it it is ignored;
/* perhaps we should check for this case and give a warning since it
/* is a very strange situation indeed; it can occur for example when
/* a "defined" keyword is found due to a macro expansion within a #if
/* or #elif directive, or when a "<" token is found as the first
/* expanded.  token of a #include directive.
/*
/* Preprocessing directives *are* processed.
/*
/* Depending upon the lexical context (which is indicated by the values of
/* SCAN_NEXT_CHAR), one of the dummy pointer values WHITE_SPACE_TOKEN,
/* END_PP_DIRECTIVE_TOKEN, or END_BUFFER_TOKEN may be returned.
/*
/* WHITE_SPACE_TOKEN will be returned iff a sequence of white-space
/* (including comments) was encountered when the current lexical context
/* was within a macro definition preprocessing directive (i.e. #define),
/* (i.e. SCAN_NEXT_CHAR = SCAND_NEXT_CHAR), or within the expansion of
/* a function-like macro argument, (i.e. SCAN_NEXT_CHAR = SSCANA).
/* 
/* END_PP_DIRECTIVE_TOKEN will be returned iff the current lexical context
/* is within a preprocessing directive and a newline is encountered.
/*
/* END_BUFFER_TOKEN will be returned when END_BUFFER_CHAR is returned
/* from SCAN_NEXT_CHAR or GET_NEXT_CHAR, indicating that the end of an
/* internal buffer has been reached; this buffer is assumed to have
/* been set up by the caller who has also set up SCAN_NEXT_CHAR,
/* GET_NEXT_CHAR, and PUSH_BACK_CHAR to point to the routines which
/* manipulate the internal buffer appropriatly, returning the special
/* code END_BUFFER_CHAR upon reaching the end of the buffer.
/*
/* Scanning function return value summary:
/*
/* SNEXTC:	Next relevant character
/*		EOF_CHAR EOF_IN_LINE_CHAR
/*
/* SSCANC:	Next relevant character
/*		BEGIN_PP_DIRECTIVE_CHAR
/*		EOF EOF_IN_LINE_CHAR EOF_IN_COMMENT_CHAR
/*
/* SSCANP:	Next relevant character
/*		END_PP_DIRECTIVE_CHAR
/*		GRAY_SPACE_CHAR (vertical-tab|form-feed)
/*		EOF_IN_DIRECTIVE_CHAR
/*
/* SSCAND:	Next relevant character
/*		END_PP_DIRECTIVE_CHAR
/*		WHITE_SPACE_CHAR (space|tab)
/*		GRAY_SPACE_CHAR (vertical-tab|form-feed)
/*		EOF_IN_DIRECTIVE_CHAR
/*
/* SSCANA:	Next relevant character
/*		WHITE_SPACE_CHAR (space|tab|vertical-tab|form-feed|newline)
/*		EOF_IN_ARGUMENT_CHAR
/*
/* SSCANX:	BEGIN_PP_DIRECTIVE_CHAR
/*		EOF_IN_SKIP_GROUP_CHAR
/*
/* ---------------------------------------------------------------------
/* [See] ANSI-C (X3J11/88-090), 3.1, Lexical Elements
/* ---------------------------------------------------------------------
/* [See] ANSI-C (X3J11/88-090), 2.1.1.2, Translation phases
/* =================================================================== */

I_GET_NEXT_LEXICAL_TOKEN: procedure returns (type (POINTER_T));

	%include CPP_LEX_TABLE_IN;	/* Lex tables */

	declare
		C		type (SHORT_T),
		P		type (POINTER_T),
		TP		type (POINTER_T),
        	CLASS		type (SHORT_T),
        	PREVIOUS_STATE	type (SHORT_T),
		STATE		type (SHORT_T),
		ERROR		type (BOOL_T);
	declare
	      1 T_NAME		union,
		2 STRING	character (MAX_TOKEN_SPELLING_LENGTH) varying,
		2 SPELLING	,
		  3 LENGTH	type (SHORT_T),
		  3 TEXT	character (MAX_TOKEN_SPELLING_LENGTH),
        	T_SPELLING	type (POINTER_T),
        	T_VALUE		type (SHORT_T),
        	T_TYPE		type (SHORT_T),
		T_LINE		type (LONG_T);

	/* ---------------------------------
	 * Set the FSM to the initial state.
	 * ------------------------------- */

	SET_TO_INITIAL_STATE:

	STATE		= INITIAL_STATE;
	T_NAME.LENGTH	= 0;
	ERROR		= FALSE;  /* I'd love to get rid of this */

	/* -----------------------------------------------------
	/* Get next relevant character and set the current line.
	/* --------------------------------------------------- */

	C = SCAN_NEXT_CHAR ();

	/* ---------------------------------------------------------------
	/* -NOTE- Setting T_LINE *here* rather *after* the entire token
	/* token has been processed (i.e. after each of the HAVE_xxx_TOKEN
	/* labels), will cause the line number at the *start* of the token 
	/* to be associated with the token rather than the line number at
	/* the *end* of the token.  No big deal; but just so you know.
	/* ------------------------------------------------------------- */

	T_LINE = CURRENT_SOURCE.PHYSICAL_LINE;

	/*
	/* The following is only to help us entirely skip #include files
	/* based on their enclosure entirely withing #ifndef/#endif.
	/**/

	if CURRENT_SOURCE.LINE_OF_FIRST_CHAR = 0 then
		CURRENT_SOURCE.LINE_OF_FIRST_CHAR = T_LINE;

	/* -----------------------------------
	/* Go process this relevant character.
	/* --------------------------------- */

	goto PROCESS_CHARACTER;

	/* ----------------------------------
	/* Get the very next input character.
	/* -------------------------------- */

	NEXT_CHARACTER:

	C = GET_NEXT_CHAR ();

	/* ----------------------------------
	/* Process this next input character.
	/* -------------------------------- */

	PROCESS_CHARACTER:

	if CURRENT_SOURCE.ENCLOSING_MACRO_FLAG = 0 then
		CURRENT_SOURCE.ENCLOSING_MACRO_FLAG = C;

	/* ------------------------------------------------------------------
	 * Determine the lexical class of this character (most likely first).
	 * ---------------------------------------------------------------- */

	if (C >= lbound(BYTE_CLASS_TABLE,1)) &
	   (C <= hbound(BYTE_CLASS_TABLE,1)) then
		CLASS = BYTE_CLASS_TABLE (C);

	/* ---------------------------------------------------
	 * Handle special character codes (most likely first).
	 * ------------------------------------------------- */

	else if C < 0 then do;

		/* ---------------------------------------------------
		 * White space within a macro argument list or macro
		 * definition preprocessing directive (i.e. #define) ?
		 * ------------------------------------------------- */

		if C = WHITE_SPACE_CHAR then
			return (WHITE_SPACE_TOKEN);
		   		
		/* ----------------------------------------
		 * Beginning of a preprocessing directive ?
		 * -------------------------------------- */

		else if C = BEGIN_PP_DIRECTIVE_CHAR then do;
			TP = READ_PP_DIRECTIVE ();
			if TP = END_PP_DIRECTIVE_TOKEN then
				goto SET_TO_INITIAL_STATE;
			else	return (TP);
		end;

		/* ----------------------------------
		 * End of a preprocessing directive ?
		 * -------------------------------- */

		else if C = END_PP_DIRECTIVE_CHAR then
			return (END_PP_DIRECTIVE_TOKEN);

		/* -------------
		 * End of file ?
		 * ------------ */

		else if C <= EOF_CHAR then do;
			if STATE ^= INITIAL_STATE then
				call SCAN_ERROR (ERR_PP_EOF_IN_TOKEN);
			call HANDLE_END_OF_FILE (C);
			goto SET_TO_INITIAL_STATE;
		end;

		/* ---------------------------
		 * End of an internal buffer ?
		 * ------------------------- */

		else if C = END_BUFFER_CHAR then
			return (END_BUFFER_TOKEN);

		/* ---------------------------------------------
		 * Gray space (form-feed/vertical-tab) character
		 * within a preprocessing directive line ?
		 * ------------------------------------------- */

		else if C = GRAY_SPACE_CHAR then do;
			if ^SW_X_IGNORE_GRAY_SPACE then
				call SCAN_ERROR (ERR_PP_ILLEGAL_DIRECTIVE_CHAR);
			C = SCAN_NEXT_CHAR ();
			goto PROCESS_CHARACTER;
			/* goto NEXT_CHARACTER; */
		end;

		else	CLASS = 0;
	end;

	else	CLASS = 0;

	/* ----------------------------------------
	 * Determine the next FSM transition state.
	 * -------------------------------------- */

	PREVIOUS_STATE = STATE;
	STATE = NEXT_STATE (STATE, CLASS);

	/* ------------------------------------------------------------------
	 * Add this character to the token spelling if necessary ("+" state).
	 * ---------------------------------------------------------------- */

	if STATE < 0 then do;
		STATE = -STATE;
		if T_NAME.LENGTH < MAX_TOKEN_SPELLING_LENGTH then do;
			T_NAME.LENGTH = T_NAME.LENGTH + 1;
			substr (T_NAME.TEXT, T_NAME.LENGTH, 1) = byte (C);
		end;
		else if (PREVIOUS_STATE = STRING_LITERAL_STATE) |
			(STATE          = STRING_LITERAL_STATE) |
			(STATE          = STRING_LITERAL_ESCAPE_STATE) then do;
			/*
			/* We have a long string-literal.  Split it up and
			/* send it out in pieces.  Guard against splitting
			/* in the middle of an escape sequence, since the
			/* translation phase which handles escapes sequences
			/* (5) happens before the phase which handles
			/* adjacent string-literal concatenation (6).
			/**/
			call PUSH_BACK_CHAR (C);
			call PUSH_BACK_CHAR (rank (substr (T_NAME.TEXT,
							   T_NAME.LENGTH, 1)));
			if substr (T_NAME.TEXT, T_NAME.LENGTH - 1, 1) =
			   byte (BACKSLASH_CHAR) then do;
				call PUSH_BACK_CHAR (BACKSLASH_CHAR);
				T_NAME.LENGTH = T_NAME.LENGTH - 1;
			end;
			substr (T_NAME.TEXT, T_NAME.LENGTH, 1)
				= byte (DQUOTE_CHAR);
			call PUSH_BACK_CHAR (DQUOTE_CHAR);
			goto LEX (END_OF_STRING_LITERAL_STATE);
		end;
		else if ^ERROR then do;
			call SCAN_ERROR_I_ON_LINE
			     (ERR_PP_LONG_TOKEN, T_LINE,
			      substr (T_NAME.TEXT, 1, 16) || '...');
			ERROR = TRUE;
		end;
	end;

	/* ---------------------------------------------------------
	 * If this is not a terminal state then continue processing.
	 * ------------------------------------------------------- */

	if STATE < FIRST_TERMINAL_STATE then
		goto NEXT_CHARACTER;

	/* ----------------------------------------------
	 * Perform the appropriate terminal state action.
	 * -------------------------------------------- */

	else	goto LEX (STATE);

	/* -------------------------------------------------------------
	 * CHECK_DOLLAR_STATE
	 *
	 * Here, we have encountered a dollar sign "$" (in either an 
	 * initial state or in an identifier state).  If SW_ALLOW_DOLLAR
	 * is TRUE (the "-dollar" compilation switch was given), then
	 * the dollar sign is allowed as any part of an identifier name,
	 * otherwise it's not, so we back it out of the token spelling
	 * and go to the end of token state.
	 * ----------------------------------------------------------- */

	LEX (CHECK_DOLLAR_STATE):

	if ^SW_ALLOW_DOLLAR then do;
		T_NAME.LENGTH = T_NAME.LENGTH - 1;
		if PREVIOUS_STATE = IDENTIFIER_STATE then
			goto LEX (PAST_END_OF_IDENTIFIER_STATE);
		else	goto LEX (ERROR_STATE);
	end;
	STATE = IDENTIFIER_STATE;
	goto NEXT_CHARACTER;

	/* -------------------------------------------------------------
	 * ERROR_STATE
	 *
	 * We've encountered an "unknown" single character; we pass
	 * this on without complaining since it's technically a valid
	 * preprocessing-token; the front-end will later diagnose it.
	 * ----------------------------------------------------------- */

	LEX (ERROR_STATE):

	T_TYPE = SINGLE_CHAR_TOKEN;
	T_VALUE = C;

	/***************************************************************
	 * Here, we have a token which needs a value.
	 ***************************************************************/

	HAVE_VALUE_TOKEN:
	TP = TALLOC ();
	TP->TOKEN_POD.VALUE = T_VALUE;
	TP->TOKEN_POD.TYPE  = T_TYPE;
	TP->TOKEN_POD.LINE  = T_LINE;
	return (TP);

	/***************************************************************/

	/* -------------------------------------------------------------
	 * ILLEGAL_STRING_LITERAL_STATE
	 * ----------------------------------------------------------- */

	LEX (ILLEGAL_STRING_LITERAL_STATE):

	if SCAN_NEXT_CHAR = SSCANP then
		call SCAN_ERROR_ON_LINE (ERR_PP_NEWLINE_IN_FILE_NAME, T_LINE);
	else	call SCAN_ERROR_ON_LINE (ERR_PP_NEWLINE_IN_STRING, T_LINE);
	substr (T_NAME.TEXT, T_NAME.LENGTH, 1) = byte (DQUOTE_CHAR);
	call PUSH_BACK_CHAR (C);
	goto LEX (END_OF_STRING_LITERAL_STATE);

	/* -------------------------------------------------------------
	 * ILLEGAL_CHAR_CONSTANT_STATE
	 * ----------------------------------------------------------- */

	LEX (ILLEGAL_CHAR_CONSTANT_STATE):

	call SCAN_ERROR_ON_LINE (ERR_PP_NEWLINE_IN_CHAR, T_LINE);
	substr (T_NAME.TEXT, T_NAME.LENGTH, 1) = byte (SQUOTE_CHAR);
	call PUSH_BACK_CHAR (C);
	goto LEX (END_OF_CHAR_CONSTANT_STATE);

	/* -------------------------------------------------------------
	 * END_OF_STRING_LITERAL_STATE
	 *
	 * We have found the end of a string literal token.
	 * String literals are NOT put into the LPI global symbol table.
	 * Allocate enough memory to save the spelling, not including the
	 * enclosing quotes (nor the leading "L" for wide types).  Also, 
	 * allocate enough space for a terminating null byte, but don't
	 * actually append a null byte; the front-end may or may not
	 * want to append one depending on whether or not this string
	 * literal immediately precedes another string literal.
	 * ----------------------------------------------------------- */

	LEX (END_OF_STRING_LITERAL_STATE):

	/* Store the spelling for a wide string literal */

	if substr (T_NAME.TEXT, 1, 1) = byte (UPPER_L_CHAR) then do;
		T_TYPE = WSTRING_LITERAL_TOKEN;
		T_SPELLING = SALLOC (T_NAME.LENGTH - 2);
		T_SPELLING->TOKEN_SPELLING_POD.SPELLING =
			substr (T_NAME.STRING, 3, T_NAME.LENGTH - 3);
	end;

	/* Store the spelling for a normal string literal */

	else do;
		T_TYPE = STRING_LITERAL_TOKEN;
		T_SPELLING = SALLOC (T_NAME.LENGTH - 1);
		T_SPELLING->TOKEN_SPELLING_POD.SPELLING =
			substr (T_NAME.STRING, 2, T_NAME.LENGTH - 2);
	end;

        goto HAVE_SPELLING_TOKEN;

	/* -------------------------------------------------------------
	 * END_OF_CHAR_CONSTANT_STATE
	 *
	 * We have found the end of a character constant token.
	 * Character constants are NOT put into the LPI global symbol table.
	 * Allocate enough memory to save the spelling, not including the
	 * enclosing quotes (or the leading "L" for wide types).
	 * ----------------------------------------------------------- */

	LEX (END_OF_CHAR_CONSTANT_STATE):
	
	/* Store the spelling for a wide character constant */

	if substr (T_NAME.TEXT, 1, 1) = byte (UPPER_L_CHAR) then do;
		T_TYPE = WCHAR_CONSTANT_TOKEN;
		T_SPELLING = SALLOC (T_NAME.LENGTH - 3);
		T_SPELLING->TOKEN_SPELLING_POD.SPELLING =
			substr (T_NAME.STRING, 3, T_NAME.LENGTH - 3);
	end;

	/* Store the spelling for a normal character constant */

	else do;
		T_TYPE = CHAR_CONSTANT_TOKEN;
		T_SPELLING = SALLOC (T_NAME.LENGTH - 2);
		T_SPELLING->TOKEN_SPELLING_POD.SPELLING =
			substr (T_NAME.STRING, 2, T_NAME.LENGTH - 2);
	end;

        goto HAVE_SPELLING_TOKEN;

	/* -------------------------------------------------------------
	 * DOUBLE_DOT_STATE
	 *
	 * This handles the extra character push-back necessary when
	 * a prefix (..) to the ANSI-C ellipsis (...) token is found.
	 * ----------------------------------------------------------- */

	LEX (DOUBLE_DOT_STATE):

	call PUSH_BACK_CHAR (C);
	call PUSH_BACK_CHAR (DOT_CHAR);
	T_TYPE = BYTE_TYPE_TABLE (DOT_CHAR);
	goto HAVE_SIMPLE_TOKEN;

	/* -------------------------------------------------------------
	 * SIMPLE_TOKEN_STATE
	 *
	 * We have a simple (one character) operator/punctuator token.
	 * We have *not* gone past the end of the token.  If will be
	 * one of the following operator/punctuator tokens:
	 * -------------------------------------------------------------
	 *   [   ]   (   )   {   }   ,   :   ?   ;
	 * ----------------------------------------------------------- */

	LEX (SIMPLE_TOKEN_STATE):

	T_TYPE = BYTE_TYPE_TABLE (C);
	goto HAVE_SIMPLE_TOKEN;

	/* -------------------------------------------------------------
	 * Multi-character punctuator/operator states
	 *
	 * We have a simple multi-character operator/punctuator token.
	 * These are states for which we know we have lexed a complete
	 * token; i.e. we have *not* gone past the end of the token.
	 * It will be one of the following operator/punctuator tokens:
	 * -------------------------------------------------------------
	 *   ->   ++   --   <=   >=   ==   !=   &&    ||    *= 
	 *   /=   %=   +=   -=   &=   ^=   |=   <<=   >>=   ...
	 *   ##   ::   .*   ->*
	 * ----------------------------------------------------------- */

	LEX (POINTER_STATE):	  ;  LEX (GREATER_EQUAL_STATE):	 ;
	LEX (LESS_EQUAL_STATE):	  ;  LEX (EQUAL_EQUAL_STATE):	 ;
	LEX (NOT_EQUAL_STATE):	  ;  LEX (MINUS_MINUS_STATE):	 ;
	LEX (PLUS_PLUS_STATE):	  ;  LEX (OR_OR_STATE):		 ;
	LEX (AND_AND_STATE):	  ;  LEX (MINUS_EQUAL_STATE):	 ;
	LEX (PLUS_EQUAL_STATE):	  ;  LEX (SLASH_EQUAL_STATE):	 ;
	LEX (STAR_EQUAL_STATE):	  ;  LEX (LSHIFT_EQUAL_STATE):	 ;
	LEX (MOD_EQUAL_STATE):	  ;  LEX (AND_EQUAL_STATE):	 ;
	LEX (RSHIFT_EQUAL_STATE): ;  LEX (XOR_EQUAL_STATE):	 ;
	LEX (OR_EQUAL_STATE):	  ;  LEX (ELLIPSIS_STATE):	 ;
	LEX (COLON_COLON_STATE):  ;  LEX (POINTER_STAR_STATE):	 ;
	LEX (DOT_STAR_STATE):	  ;  LEX (PP_TOKEN_PASTE_STATE): ;

	T_TYPE = STATE_TYPE_TABLE (STATE);

	/***************************************************************
	 * Here, we have a simple token.
	 ***************************************************************/

	HAVE_SIMPLE_TOKEN:

	TP = TALLOC ();
	TP->TOKEN_POD.TYPE = T_TYPE;
	TP->TOKEN_POD.LINE = T_LINE;
	return (TP);

	/***************************************************************/

	/* -------------------------------------------------------------
	 * PAST_END_OF_TOKEN_STATE
	 *
	 * We have read one character past the end of a token.
	 * This will be either an preprocessing number, a (decimal,
	 * octal, or hexadecimal) constant, or one of the following
	 * puncutator/operator tokens:
	 * -------------------------------------------------------------
	 *   .   =   +   -   *   /   %   &   |  <<   >>   #
	 * ----------------------------------------------------------- */

	LEX (PAST_END_OF_TOKEN_STATE):

	call PUSH_BACK_CHAR (C);

	END_OF_TOKEN:

	/* Map the terminal state to a token type */

	T_TYPE = STATE_TYPE_TABLE (PREVIOUS_STATE);

	/* See if this token needs no spelling (i.e. operator/punctuator) */

	if (T_TYPE < LB_SPELLING_TOKEN) | (T_TYPE > HB_SPELLING_TOKEN) then
		goto HAVE_SIMPLE_TOKEN;

	/*
	/* Store other token spellings (octal, decimal, and hexadecimal integer
	/* constants, floating constants, and preprocessing-numbers in memory.
	/*
	/* N.B. we *must* allocate one extra byte for floating constants
	/* because the front-end (in EXPV (in MINUS_VOP)) will tack a minus
	/* onto the beginning of the string if the unary minus operator was
	/* applied to it, assuming that enough space for this extra character
	/* was allocated; we could check and do this only for floating
	/* constants, but screw it, we'll give everyone an extra byte.
	/**/

	T_SPELLING = SALLOC (T_NAME.LENGTH + 1);
	T_SPELLING->TOKEN_SPELLING_POD.SPELLING = T_NAME.STRING;

	/***************************************************************
	 * Here, we have a token which needs a spelling.
	 ***************************************************************/

	HAVE_SPELLING_TOKEN:

	TP = TALLOC ();
	TP->TOKEN_POD.SPELLING_PTR = T_SPELLING;
	TP->TOKEN_POD.TYPE     = T_TYPE;
	TP->TOKEN_POD.LINE     = T_LINE;
	return (TP);

	/**************************************************************/

	/* -------------------------------------------------------------
	 * PAST_END_OF_IDENTIFIER_STATE
	 *
	 * We have read one character past the end of identifier token.
	 * ----------------------------------------------------------- */

	LEX (PAST_END_OF_IDENTIFIER_STATE):

	call PUSH_BACK_CHAR (C);

	END_OF_IDENTIFIER_TOKEN:

	/* Store this identifier in the LPI global symbol table */

	T_TYPE = IDENTIFIER_TOKEN;
       	T_VALUE = STORE_TOKEN (IDENTIFIER_TOKEN, T_NAME.STRING);

	/***************************************************************
	 * Here, we have an identifier token.
	 ***************************************************************/

	HAVE_IDENTIFIER_TOKEN:

	TP = TALLOC ();
	TP->TOKEN_POD.SPELLING = T_VALUE;
	TP->TOKEN_POD.TYPE = T_TYPE;
	TP->TOKEN_POD.LINE = T_LINE;
	return (TP);

	/***************************************************************/

end; /* I_GET_NEXT_LEXICAL_TOKEN */

/* =====================================================================
/* READ_PP_DIRECTIVE
/*
/* Read and process an ANSI-C preprocessing directive.  It is assumed
/* that the preprocessing directive indicator character (#) has just
/* been read as the first pertinent character on a line; i.e. the next
/* thing we expect to see is a preprocessor directive keyword (or nothing).
/* ---------------------------------------------------------------------
/* [Excerpt] ANSI-C (X3J11/88-159), 3.8, Description:
/* ---------------------------------------------------------------------
/* A preprocessing directive consists of a sequence of preprocessing
/* tokens that begins with a "#" preprocessing token that is either
/* the first character in the source file (optionally after white space
/* containing no new-line characters) or that follows white space
/* containing at least one new-line character, and is ended by the next
/* new-line character.
/* =================================================================== */

READ_PP_DIRECTIVE: procedure returns (type (POINTER_T));

	declare
		length		builtin;
	declare
		(TP, P)		type (POINTER_T),
		(C, I, K, L, T)	type (SHORT_T),
		CURLY		type (BOOL_T),
		ERROR_CODE	type (SHORT_T),
		(ID1, ID2)	type (NID_T),
		S		character (MAX_TOKEN_SPELLING_LENGTH) varying;
	declare
		1 F_NAME	union,
		  2 STRING	character (MAX_FILE_NAME_LENGTH) varying,
		  2 SPELLING	,
		    3 LENGTH	type (SHORT_T),
		    3 TEXT	character (MAX_FILE_NAME_LENGTH),
		NAME		character (MAX_FILE_NAME_LENGTH) varying;
	declare
		SAVE_SCAN_NEXT_CHAR	entry
					returns (type (SHORT_T)) variable,
		GET_NEXT_INCLUDE_TOKEN	entry
					returns (type (POINTER_T)) variable;
	declare
		EXCLUDED_GROUP		type (BOOL_T)
					static internal initial (FALSE);

	/* Save and change the lexical context */

	SAVE_SCAN_NEXT_CHAR	= SCAN_NEXT_CHAR;
	SCAN_NEXT_CHAR		= SCANP_NEXT_CHAR;

	/* Get the next token; typically a preprocessor directive keyword */

	TP = GET_NEXT_LEXICAL_TOKEN ();

	/* Null preprocessing directive; ignore */

	if TP = END_PP_DIRECTIVE_TOKEN then
		goto DONE_PP_DIRECTIVE;

	/* See if this is a valid and known preprocessing directive */

	ERROR_CODE = ERR_PP_ERROR;

	if TP->TOKEN_POD.TYPE ^= IDENTIFIER_TOKEN then do;
		if (TP->TOKEN_POD.TYPE = DECIMAL_CONSTANT_TOKEN) &
		    SW_ALLOW_OLD_LINE_DIRECTIVE then
			goto HANDLE_LINE_DIRECTIVE;
		else	goto UNKNOWN_PP_DIRECTIVE;
	end;

	K = LOOKUP_PP_KEYWORD (TP->TOKEN_POD.SPELLING_NODE);

	/* Check for non-standard preprocessor directives */

	if K = NULL_TOKEN then
		goto UNKNOWN_PP_DIRECTIVE;

	call TFREE (TP);

	/* Process the specific directive */

	goto PP_DIRECTIVE (K);

	/* -------------------------------------------------------------
	 * PP_KW_ASSERT_TOKEN
	 *
	 * #assert identifer ( pp_tokens )
	 * ----------------------------------------------------------- */

	PP_DIRECTIVE (PP_KW_ASSERT_TOKEN):

	if ^SW_ALLOW_ASSERT_DIRECTIVE then
		call PP_ERROR_I (ERR_PP_ASSERT, 'assert');
	TP = GET_NEXT_LEXICAL_TOKEN ();
	if TP = END_PP_DIRECTIVE_TOKEN then do;
		call PP_ERROR_I (ERR_PP_EMPTY_DIRECTIVE, 'assert');
		goto DONE_PP_DIRECTIVE;
	end;
	if TP->TOKEN_POD.TYPE ^= IDENTIFIER_TOKEN then do; 
		call PP_ERROR_I (ERR_PP_NO_DIRECTIVE_IDENTIFIER, 'assert');
		goto SKIP_PP_DIRECTIVE;
	end;
	call READ_ASSERT_DEFINITION (TP);
	goto DONE_PP_DIRECTIVE;

	/* -------------------------------------------------------------
	 * PP_KW_UNASSERT_TOKEN
	 *
	 * #unassert identifer
	 * ----------------------------------------------------------- */

	PP_DIRECTIVE (PP_KW_UNASSERT_TOKEN):

	if ^SW_ALLOW_ASSERT_DIRECTIVE then
		call PP_ERROR_I (ERR_PP_ASSERT, 'unassert');
	TP = GET_NEXT_LEXICAL_TOKEN ();
	if TP = END_PP_DIRECTIVE_TOKEN then do;
		call PP_ERROR_I (ERR_PP_EMPTY_DIRECTIVE, 'unassert');
		goto DONE_PP_DIRECTIVE;
	end;
	if TP->TOKEN_POD.TYPE ^= IDENTIFIER_TOKEN then do;
		call PP_ERROR_I (ERR_PP_NO_DIRECTIVE_IDENTIFIER, 'unassert');
		goto SKIP_PP_DIRECTIVE;
	end;
	call READ_UNASSERT_DIRECTIVE (TP);
	goto DONE_PP_DIRECTIVE;

	/* -------------------------------------------------------------
	 * PP_KW_DEFINE_TOKEN
	 *
	 * #define identifer replacement_list
	 * #define identifier ( identifier_list ) replacement_list
	 * ----------------------------------------------------------- */

	PP_DIRECTIVE (PP_KW_DEFINE_TOKEN):

	TP = GET_NEXT_LEXICAL_TOKEN ();
	if TP = END_PP_DIRECTIVE_TOKEN then do;
		call PP_ERROR_I (ERR_PP_EMPTY_DIRECTIVE, 'define');
		goto DONE_PP_DIRECTIVE;
	end;
	if TP->TOKEN_POD.TYPE ^= IDENTIFIER_TOKEN then do;
		call PP_ERROR_I (ERR_PP_NO_DIRECTIVE_IDENTIFIER, 'define');
		goto SKIP_PP_DIRECTIVE;
	end;
	call READ_MACRO_DEFINITION (TP);
	goto DONE_PP_DIRECTIVE;

	/* -------------------------------------------------------------
	 * PP_KW_ELIF_TOKEN
	 * PP_KW_ELSEIF_TOKEN
	 *
	 * #elif constant_expression
	 * #elseif constant_expression
	 * ----------------------------------------------------------- */

	PP_DIRECTIVE (PP_KW_ELSEIF_TOKEN):

	if ^SW_ALLOW_ELSEIF_DIRECTIVE then
		call PP_ERROR (ERR_PP_ELSEIF);

	PP_DIRECTIVE (PP_KW_ELIF_TOKEN):

	if GROUP_LEVEL <= 0 then do;
		call PP_ERROR_I (ERR_PP_EXTRA_DIRECTIVE, 'elif');
		GROUP_LEVEL = 0;
		goto DONE_PP_DIRECTIVE;
	end;

	if (CURRENT_SOURCE.ENCLOSING_MACRO_LEVEL = GROUP_LEVEL) &
	   (CURRENT_SOURCE.ENCLOSING_MACRO ^= NULL_ID) then do;
		/*
		/* Here, this source file begins with an
		/* #ifndef but now has an associated #elif.
		/**/
		CURRENT_SOURCE.ENCLOSING_MACRO = NULL_ID;
	end;

	if  EXCLUDED_GROUP then do;
		if PP_EXPRESSION () = 0 then do;
			K = SKIP_GROUP (PP_KW_IF_TOKEN);
			EXCLUDED_GROUP = TRUE;
			goto PP_DIRECTIVE (K);	/* #endif, #else, or #elif */
		end;
		else do;
			EXCLUDED_GROUP = FALSE;
			goto DONE_PP_DIRECTIVE;
		end;
	end;
	else do;
		K = SKIP_GROUP (PP_KW_ELSE_TOKEN);
		EXCLUDED_GROUP = TRUE;
		goto PP_DIRECTIVE (K);	/* #endif */
	end;

	/* -------------------------------------------------------------
	 * PP_KW_ELSE_TOKEN
	 *
	 * #else
	 * ----------------------------------------------------------- */

	PP_DIRECTIVE (PP_KW_ELSE_TOKEN):

	C = SCAN_NEXT_CHAR ();
	if C ^= END_PP_DIRECTIVE_CHAR then do;
		if C = EOF_IN_DIRECTIVE_CHAR then do;
			call HANDLE_END_OF_FILE (C);
			goto DONE_PP_DIRECTIVE;
		end;
		if ^SW_X_TRAILING_TEXT then
			call PP_ERROR_I
			     (ERR_PP_EXTRA_TEXT_DIRECTIVE_OK, 'else');
		call IGNORE_PP_DIRECTIVE ();
	end;

	if GROUP_LEVEL <= 0 then do;
		call PP_ERROR_I (ERR_PP_EXTRA_DIRECTIVE, 'else');
		GROUP_LEVEL = 0;
		goto DONE_PP_DIRECTIVE;
	end;

	if (CURRENT_SOURCE.ENCLOSING_MACRO_LEVEL = GROUP_LEVEL) &
	   (CURRENT_SOURCE.ENCLOSING_MACRO ^= NULL_ID) then do;
		/*
		/* Here, this source file begins with an
		/* #ifndef but now has an associated #else.
		/**/
		CURRENT_SOURCE.ENCLOSING_MACRO = NULL_ID;
	end;

	if EXCLUDED_GROUP then do;
		EXCLUDED_GROUP = FALSE;
		goto DONE_PP_DIRECTIVE;
	end;
	else do;
		K = SKIP_GROUP (PP_KW_ELSE_TOKEN);
		EXCLUDED_GROUP = TRUE;
		goto PP_DIRECTIVE (K);	/* #endif */
	end;

	/* -------------------------------------------------------------
	 * PP_KW_ENDIF_TOKEN
	 *
	 * #endif
	 * ----------------------------------------------------------- */

	PP_DIRECTIVE (PP_KW_ENDIF_TOKEN):

	C = SCAN_NEXT_CHAR ();
	if C ^= END_PP_DIRECTIVE_CHAR then do;
		if C = EOF_IN_DIRECTIVE_CHAR then do;
			call HANDLE_END_OF_FILE (C);
			goto DONE_PP_DIRECTIVE;
		end;
		if ^SW_X_TRAILING_TEXT then
			call PP_ERROR_I
			     (ERR_PP_EXTRA_TEXT_DIRECTIVE_OK, 'endif');
		call IGNORE_PP_DIRECTIVE ();
	end;

	if GROUP_LEVEL <= 0 then do;
		call PP_ERROR_I (ERR_PP_EXTRA_DIRECTIVE, 'endif');
		GROUP_LEVEL = 0;
		goto DONE_PP_DIRECTIVE;
	end;

	if (CURRENT_SOURCE.ENCLOSING_MACRO_LEVEL = GROUP_LEVEL) &
	   (CURRENT_SOURCE.ENCLOSING_MACRO ^= NULL_ID) then do;
		/*
		/* Here, this source file begins with an #ifndef and has no
		/* associated #else/#elif; we will now be on the lookout for
		/* and record the next pertinent character after this #endif;
		/* hopefull it will turn out to be an end-of-file character!
		/**/
		CURRENT_SOURCE.ENCLOSING_MACRO_FLAG = 0;
	end;

	GROUP_LEVEL = GROUP_LEVEL - 1;
	EXCLUDED_GROUP = FALSE;
	goto DONE_PP_DIRECTIVE;

	/* -------------------------------------------------------------
	 * PP_KW_ERROR_TOKEN
	 * PP_KW_NOTE_TOKEN
	 *
	 * #error preprocessing_tokens
	 * #note
	 * ----------------------------------------------------------- */

	PP_DIRECTIVE (PP_KW_NOTE_TOKEN):

	ERROR_CODE = ERR_PP_NOTE;

	PP_DIRECTIVE (PP_KW_ERROR_TOKEN):
	
	begin;

	%replace MAX_ERROR_LINE_LENGTH	by 72;

	declare  (BUFFER, S)	character (MAX_ERROR_LINE_LENGTH) varying;

	SCAN_NEXT_CHAR = SCAND_NEXT_CHAR;
	BUFFER = ''; S = '';
	do TP = GET_NEXT_LEXICAL_TOKEN ()
	repeat (GET_NEXT_LEXICAL_TOKEN ()) while (TP ^= END_PP_DIRECTIVE_TOKEN);
		if TP ^= WHITE_SPACE_TOKEN then do;
			S = TOKEN_SPELLING (TP);
			call TFREET (TP);
		end;
		else if length (BUFFER) > 0 then
			S = ' ';
		else	S = '';
		if (length (BUFFER) + length (S)) >
		   MAX_ERROR_LINE_LENGTH then do;
			call PP_ERROR_I (ERROR_CODE, BUFFER || ' ...');
			goto SKIP_PP_DIRECTIVE;
		end;
		else	BUFFER = BUFFER || S;
	end;
	call PP_ERROR_I (ERROR_CODE, BUFFER);
	goto SKIP_PP_DIRECTIVE;

	end;

	/* -------------------------------------------------------------
	 * PP_KW_IDENT_TOKEN
	 *
	 * #ident string_literal ...
	 * ----------------------------------------------------------- */

	PP_DIRECTIVE (PP_KW_IDENT_TOKEN):

	if ^SW_IDENT_NOWARN then
		call PP_ERROR (ERR_PP_IDENT);
	TP = GET_NEXT_EXPANDED_TOKEN ();
	if TP = END_PP_DIRECTIVE_TOKEN then do;
		call PP_ERROR_I (ERR_PP_EMPTY_DIRECTIVE, 'ident');
		goto DONE_PP_DIRECTIVE;
	end;
	else if TP->TOKEN_POD.TYPE ^= STRING_LITERAL_TOKEN then do;
		call PP_ERROR (ERR_PP_ILLEGAL_IDENT);
		goto SKIP_PP_DIRECTIVE;
	end;
	TP = HANDLE_IDENT_DIRECTIVE (TP);
	if TP ^= END_PP_DIRECTIVE_TOKEN then do;
		call PP_ERROR_I (ERR_PP_EXTRA_TEXT_DIRECTIVE, 'ident');
		call TFREET (TP);
		call IGNORE_PP_DIRECTIVE ();
	end;
	goto DONE_PP_DIRECTIVE;

	/* -------------------------------------------------------------
	 * PP_KW_IF_TOKEN
	 *
	 * #if constant_expression
	 * ----------------------------------------------------------- */

	PP_DIRECTIVE (PP_KW_IF_TOKEN):

	GROUP_LEVEL = GROUP_LEVEL + 1;
	if PP_EXPRESSION () = 0 then do;
		K = SKIP_GROUP (PP_KW_IF_TOKEN);
		EXCLUDED_GROUP = TRUE;
		goto PP_DIRECTIVE (K);	/* #endif, #else, or #elif */
	end;
	else do;
		EXCLUDED_GROUP = FALSE;
		goto DONE_PP_DIRECTIVE;
	end;

	/* -------------------------------------------------------------
	 * PP_KW_IFDEF_TOKEN
	 *
	 * #ifdef identifier
	 * ----------------------------------------------------------- */

	PP_DIRECTIVE (PP_KW_IFDEF_TOKEN):

	TP = GET_NEXT_LEXICAL_TOKEN ();
	if TP = END_PP_DIRECTIVE_TOKEN then do;
		call PP_ERROR_I (ERR_PP_EMPTY_DIRECTIVE, 'ifdef');
		goto DONE_PP_DIRECTIVE;
	end;
	if TP->TOKEN_POD.TYPE ^= IDENTIFIER_TOKEN then do;
		call TFREET (TP);
		call PP_ERROR_I (ERR_PP_NO_DIRECTIVE_IDENTIFIER, 'ifdef');
		goto SKIP_PP_DIRECTIVE;
	end;

	C = SCAN_NEXT_CHAR ();
	if C ^= END_PP_DIRECTIVE_CHAR then do;
		if C = EOF_IN_DIRECTIVE_CHAR then do;
			call HANDLE_END_OF_FILE (C);
			goto DONE_PP_DIRECTIVE;
		end;
		call PP_ERROR_I (ERR_PP_EXTRA_TEXT_DIRECTIVE, 'ifdef');
		call IGNORE_PP_DIRECTIVE ();
	end;

	GROUP_LEVEL = GROUP_LEVEL + 1;
	P = LOOKUP_MACRO_BY_TOKEN (TP);
	call TFREE (TP);
	if P = null () then do;
		K = SKIP_GROUP (PP_KW_IF_TOKEN);
		EXCLUDED_GROUP = TRUE;
		goto PP_DIRECTIVE (K);	/* #endif, #else, or #elif */
	end;
	else do;
		EXCLUDED_GROUP = FALSE;
		goto DONE_PP_DIRECTIVE;
	end;

	/* -------------------------------------------------------------
	 * PP_KW_IFNDEF_TOKEN
	 *
	 * #ifndef identifier
	 * ----------------------------------------------------------- */

	PP_DIRECTIVE (PP_KW_IFNDEF_TOKEN):

	TP = GET_NEXT_LEXICAL_TOKEN ();
	if TP = END_PP_DIRECTIVE_TOKEN then do;
		call PP_ERROR_I (ERR_PP_EMPTY_DIRECTIVE, 'ifndef');
		goto DONE_PP_DIRECTIVE;
	end;
	if TP->TOKEN_POD.TYPE ^= IDENTIFIER_TOKEN then do;
		call PP_ERROR_I (ERR_PP_NO_DIRECTIVE_IDENTIFIER, 'ifndef');
		goto SKIP_PP_DIRECTIVE;
	end;

	C = SCAN_NEXT_CHAR ();
	if C ^= END_PP_DIRECTIVE_CHAR then do;
		if C = EOF_IN_DIRECTIVE_CHAR then do;
			call HANDLE_END_OF_FILE (C);
			goto DONE_PP_DIRECTIVE;
		end;
		call PP_ERROR_I (ERR_PP_EXTRA_TEXT_DIRECTIVE, 'ifndef');
		call IGNORE_PP_DIRECTIVE ();
	end;

	GROUP_LEVEL = GROUP_LEVEL + 1;

	if CURRENT_SOURCE.LINE_OF_FIRST_CHAR =
	   CURRENT_SOURCE.PHYSICAL_LINE then do;
		CURRENT_SOURCE.ENCLOSING_MACRO = TP->TOKEN_POD.SPELLING_NODE;
		CURRENT_SOURCE.ENCLOSING_MACRO_LEVEL = GROUP_LEVEL;
	end;

	P = LOOKUP_MACRO_BY_TOKEN (TP);
	call TFREE (TP);
	if P ^= null () then do;
		K = SKIP_GROUP (PP_KW_IF_TOKEN);
		EXCLUDED_GROUP = TRUE;
		goto PP_DIRECTIVE (K);	/* #endif, #else, or #elif */
	end;
	else do;
		EXCLUDED_GROUP = FALSE;
		goto DONE_PP_DIRECTIVE;
	end;

	/* -------------------------------------------------------------
	 * PP_KW_INCLUDE_TOKEN
	 *
	 * #include "q_header_name"
	 * #include <h_header_name>
	 * #include {h_header_name} -- LPI extension
	 * #include preprocessing_tokens
	 * ----------------------------------------------------------- */

	PP_DIRECTIVE (PP_KW_INCLUDE_TOKEN):

	GET_NEXT_INCLUDE_TOKEN = GET_NEXT_UNEXPANDED_TOKEN;

	PROCESS_INCLUDE_DIRECTIVE:

	TP = GET_NEXT_INCLUDE_TOKEN ();

	/* -------------------------
	 * Empty #include directive.
	 * ------------------------ */

	if TP = END_PP_DIRECTIVE_TOKEN then do;
		call PP_ERROR_I (ERR_PP_EMPTY_DIRECTIVE, 'include');
		goto DONE_PP_DIRECTIVE;
	end;

	/* --------------------------------------------------------------
	 * [Excerpt] ANSI-C (X3J11/88-090) 3.8.2, Constraints:
	 * --------------------------------------------------------------
	 * The method by which a sequence of preprocessing tokens between
	 * a < and a > prprocessing token pair or a pair of " characters
	 * is combined into a single header name preprocessing token is
	 * implementation-defined.
	 * ------------------------------------------------------------ */

	/* -------------------------
	 * #include "q_header_name"
	 * ------------------------*/

	T = TP->TOKEN_POD.TYPE;
	if T = STRING_LITERAL_TOKEN then do;
		C = SCAN_NEXT_CHAR ();
		if C ^= END_PP_DIRECTIVE_CHAR then do;
			if C = EOF_IN_DIRECTIVE_CHAR then do;
				call HANDLE_END_OF_FILE (C);
				goto DONE_PP_DIRECTIVE;
			end;
			call PP_ERROR_I (ERR_PP_EXTRA_TEXT_DIRECTIVE,
					 'include');
			call IGNORE_PP_DIRECTIVE ();
		end;
		P = TP->TOKEN_POD.SPELLING_PTR;
		TP->TOKEN_POD.LINE = CURRENT_SOURCE.PHYSICAL_LINE;
		call OPEN_QUOTE_INCLUDE_FILE (P->TOKEN_SPELLING_POD.SPELLING);
		call TFREET (TP);
		goto DONE_PP_DIRECTIVE;
	end;

	/* -------------------------
	 * #include <h_header_name>
	 * #include {h_header_name}
	 * ------------------------*/

	else if (T = LESS_THAN_TOKEN) | (T = LCURLY_TOKEN) then do;

		if T = LESS_THAN_TOKEN then
			CURLY = FALSE;
		else	CURLY = TRUE;

		call TFREE (TP);
		F_NAME.LENGTH = 0;

		NEXT_HEADER_TOKEN:

		TP = GET_NEXT_INCLUDE_TOKEN ();

		if TP = END_PP_DIRECTIVE_TOKEN then
			goto HAVE_HEADER_TOKEN;
		if TP->TOKEN_POD.TYPE = GREATER_THAN_TOKEN then do;
			if ^CURLY then
				goto HAVE_HEADER_TOKEN;
		end;
		else if TP->TOKEN_POD.TYPE = RCURLY_TOKEN then do;
			if CURLY then
				goto HAVE_HEADER_TOKEN;
		end;

		if TP->TOKEN_POD.LINE < 0 then do;
			if F_NAME.LENGTH >= MAX_FILE_NAME_LENGTH then do;
				call SCAN_ERROR_I
				     (ERR_PP_LONG_INCLUDE_NAME,
				      substr (F_NAME.TEXT, 1, 16) || '...');
				call TFREET (TP);
				goto SKIP_PP_DIRECTIVE;
			end;
			F_NAME.LENGTH = F_NAME.LENGTH + 1;
			substr (F_NAME.TEXT, F_NAME.LENGTH, 1) =
				byte (SPACE_CHAR);
		end;

		S = TOKEN_SPELLING (TP);
		call TFREET (TP);
		do I = 1 to length (S);
			if F_NAME.LENGTH >= MAX_FILE_NAME_LENGTH then do;
				call SCAN_ERROR_I
				     (ERR_PP_LONG_INCLUDE_NAME,
				      substr (F_NAME.TEXT, 1, 14) || '...');
				goto SKIP_PP_DIRECTIVE;
			end;
			F_NAME.LENGTH = F_NAME.LENGTH + 1;
			substr (F_NAME.TEXT, F_NAME.LENGTH, 1) =
				substr (S, I, 1);
		end;

		goto NEXT_HEADER_TOKEN;

		HAVE_HEADER_TOKEN:

		if TP ^= END_PP_DIRECTIVE_TOKEN then do;
			call TFREET (TP);
			C = SCAN_NEXT_CHAR ();
			if C ^= END_PP_DIRECTIVE_CHAR then do;
				if C = EOF_IN_DIRECTIVE_CHAR then do;
					call HANDLE_END_OF_FILE (C);
					goto DONE_PP_DIRECTIVE;
				end;
				call PP_ERROR_I (ERR_PP_EXTRA_TEXT_DIRECTIVE,
						 'include');
				call IGNORE_PP_DIRECTIVE ();
			end;
		end;
		else	call PP_ERROR (ERR_PP_NEWLINE_IN_FILE_NAME);

		if CURLY then
			call OPEN_CURLY_INCLUDE_FILE (F_NAME.STRING);
		else	call OPEN_ANGLE_INCLUDE_FILE (F_NAME.STRING);

		goto DONE_PP_DIRECTIVE;
	end;

	/* ------------------
	 * #include pp-tokens
	 * ---------------- */

	else if GET_NEXT_INCLUDE_TOKEN = GET_NEXT_UNEXPANDED_TOKEN then do;
		call PUSH_BACK_TOKEN (TP);
		GET_NEXT_INCLUDE_TOKEN = GET_NEXT_EXPANDED_TOKEN;
		goto PROCESS_INCLUDE_DIRECTIVE;
	end;

	/* ----------------
	 * #include garbage
	 * -------------- */

	else do;
		call PP_ERROR_I (ERR_PP_ILLEGAL_INCLUDE, TOKEN_SPELLING (TP));
		goto SKIP_PP_DIRECTIVE;
	end;
	
	goto DONE_PP_DIRECTIVE;

	/* -------------------------------------------------------------
	 * PP_KW_FILE_TOKEN
	 *
	 * #file "source_file_name"
	 * ----------------------------------------------------------- */

	PP_DIRECTIVE (PP_KW_FILE_TOKEN):

	if ^SW_ALLOW_FILE_DIRECTIVE then
		call PP_ERROR (ERR_PP_FILE);

	TP = GET_NEXT_EXPANDED_TOKEN ();

	if TP = END_PP_DIRECTIVE_TOKEN then do;
		call PP_ERROR_I (ERR_PP_EMPTY_DIRECTIVE, 'file');
		goto DONE_PP_DIRECTIVE;
	end;
	else if TP->TOKEN_POD.TYPE ^= STRING_LITERAL_TOKEN then do;
		call PP_ERROR (ERR_PP_ILLEGAL_FILE);
		goto SKIP_PP_DIRECTIVE;
	end;
	TP->TOKEN_POD.TYPE = LINE_FILE_TOKEN;
	TP->TOKEN_POD.LINE = 0;
	CURRENT_SOURCE.ASSUMED_NAME =
		addr (TP->TOKEN_POD.SPELLING_PTR->TOKEN_SPELLING_POD.SPELLING);
	call TFREE (P);
	TP = GET_NEXT_EXPANDED_TOKEN ();
	if TP ^= END_PP_DIRECTIVE_TOKEN then do;
		call PP_ERROR_I (ERR_PP_EXTRA_TEXT_DIRECTIVE, 'file');
		call TFREET (TP);
		call IGNORE_PP_DIRECTIVE ();
	end;
	goto DONE_TOKEN_PP_DIRECTIVE;

	/* -------------------------------------------------------------
	 * PP_KW_LINE_TOKEN
	 *
	 * #line digit_sequence
	 * #line digit_sequence "source_file_name"
	 * #line preprocessing_tokens
	 * ----------------------------------------------------------- */

	PP_DIRECTIVE (PP_KW_LINE_TOKEN):

	/*
	 * Send out a LINE_FILE_TOKEN token-pod with the LINE field set to
	 * the line adjustment rather than the assumed #line specified; the
	 * SPELLING_PTR field will contain a pointer to a string representing
	 * the assumed file name if specified, otherwise null.
	 */

	TP = GET_NEXT_EXPANDED_TOKEN ();

	if TP = END_PP_DIRECTIVE_TOKEN then do;
		call PP_ERROR_I (ERR_PP_EMPTY_DIRECTIVE, 'line');
		goto DONE_PP_DIRECTIVE;
	end;
	else if TP->TOKEN_POD.TYPE ^= DECIMAL_CONSTANT_TOKEN then do;
		call PP_ERROR (ERR_PP_ILLEGAL_LINE);
		goto SKIP_PP_DIRECTIVE;
	end;
	HANDLE_LINE_DIRECTIVE:
	TP->TOKEN_POD.TYPE = LINE_FILE_TOKEN;
	TP->TOKEN_POD.LINE =
		binary (TP->TOKEN_POD.SPELLING_PTR->
			TOKEN_SPELLING_POD.SPELLING);
	if TP->TOKEN_POD.LINE <= 0 then do;
		call PP_ERROR (ERR_PP_ILLEGAL_LINE);
		goto SKIP_PP_DIRECTIVE;
	end;
	TP->TOKEN_POD.LINE =
		binary (TP->TOKEN_POD.SPELLING_PTR->
			TOKEN_SPELLING_POD.SPELLING) -
		(CURRENT_SOURCE.PHYSICAL_LINE + 1);
	CURRENT_SOURCE.LINE_ADJUSTMENT = TP->TOKEN_POD.LINE;
	call SFREE (TP->TOKEN_POD.SPELLING_PTR);
	P = GET_NEXT_EXPANDED_TOKEN ();
	if P ^= END_PP_DIRECTIVE_TOKEN then do;
		if P->TOKEN_POD.TYPE = STRING_LITERAL_TOKEN then do;
			TP->TOKEN_POD.SPELLING_PTR = P->TOKEN_POD.SPELLING_PTR;
			CURRENT_SOURCE.ASSUMED_NAME =
				addr (TP->TOKEN_POD.SPELLING_PTR->
				      TOKEN_SPELLING_POD.SPELLING);
			call TFREE (P);
			P = GET_NEXT_EXPANDED_TOKEN ();
		end;
		else	TP->TOKEN_POD.SPELLING_PTR = null ();
	end;
	else	TP->TOKEN_POD.SPELLING_PTR = null ();
	if P ^= END_PP_DIRECTIVE_TOKEN then do;
		call PP_ERROR_I (ERR_PP_EXTRA_TEXT_DIRECTIVE, 'line');
		call TFREET (P);
		call IGNORE_PP_DIRECTIVE ();
	end;
	goto DONE_TOKEN_PP_DIRECTIVE;

	/* -------------------------------------------------------------
	 * PP_KW_ONCE_TOKEN
	 *
	 * #once
	 * ----------------------------------------------------------- */

	PP_DIRECTIVE (PP_KW_ONCE_TOKEN):

	if ^SW_ALLOW_ONCE_DIRECTIVE then
		call PP_ERROR (ERR_PP_ONCE);
	HANDLE_ONCE_DIRECTIVE:
	if CURRENT_SOURCE.INCLUDE_LEVEL > 0 then
		call RECORD_SKIPABLE_FILE (TRUE);
	goto SKIP_PP_DIRECTIVE;

	/* -------------------------------------------------------------
	 * PP_KW_PRAGMA_TOKEN
	 *
	 * #pragma preprocessing_tokens
	 * ----------------------------------------------------------- */

	PP_DIRECTIVE (PP_KW_PRAGMA_TOKEN):

	TP = GET_NEXT_EXPANDED_TOKEN ();
	if TP = END_PP_DIRECTIVE_TOKEN then
		goto UNKNOWN_PRAGMA;
	else if TP->TOKEN_POD.TYPE ^= IDENTIFIER_TOKEN then do;
		call TFREET (TP);
		goto UNKNOWN_PRAGMA;
	end;
	S = TOKEN_SPELLING (TP);
	call TFREE (TP);

	/* #pragma comment (id, "string_literal") */

	if S = 'comment' then do;
		TP = GET_NEXT_EXPANDED_TOKEN ();
		if TP = END_PP_DIRECTIVE_TOKEN then
			goto MALFORMED_PRAGMA;
		else if TP->TOKEN_POD.TYPE ^= LPAREN_TOKEN then
			goto MALFORMED_PRAGMA;
		call TFREE (TP);
		TP = GET_NEXT_EXPANDED_TOKEN ();
		if TP = END_PP_DIRECTIVE_TOKEN then
			goto MALFORMED_PRAGMA;
		else if TP->TOKEN_POD.TYPE ^= IDENTIFIER_TOKEN then
			goto MALFORMED_PRAGMA;
		call TFREE (TP);
		TP = GET_NEXT_EXPANDED_TOKEN ();
		if TP = END_PP_DIRECTIVE_TOKEN then
			goto MALFORMED_PRAGMA;
		else if TP->TOKEN_POD.TYPE ^= COMMA_TOKEN then
			goto MALFORMED_PRAGMA;
		call TFREE (TP);
		TP = GET_NEXT_EXPANDED_TOKEN ();
		if TP = END_PP_DIRECTIVE_TOKEN then
			goto MALFORMED_PRAGMA;
		else if TP->TOKEN_POD.TYPE ^= STRING_LITERAL_TOKEN then
			goto MALFORMED_PRAGMA;
		TP = HANDLE_IDENT_DIRECTIVE (TP);
		if TP = END_PP_DIRECTIVE_TOKEN then
			goto MALFORMED_PRAGMA;
		else if TP->TOKEN_POD.TYPE ^= RPAREN_TOKEN then
			goto MALFORMED_PRAGMA;
		call TFREE (TP);
		TP = GET_NEXT_EXPANDED_TOKEN ();
		if TP ^= END_PP_DIRECTIVE_TOKEN then do;
			call PP_ERROR_I
			     (ERR_PP_EXTRA_TEXT_DIRECTIVE, 'pragma comment');
			call TFREET (TP);
			call IGNORE_PP_DIRECTIVE ();
		end;
		goto DONE_PP_DIRECTIVE;
	end;

	/* #pragma pack ( [ 1 | 2 | 4 ] ) */

	else if S = 'pack' then do;
		TP = GET_NEXT_EXPANDED_TOKEN ();
		if TP = END_PP_DIRECTIVE_TOKEN then
			goto MALFORMED_PRAGMA;
		else if TP->TOKEN_POD.TYPE ^= LPAREN_TOKEN then
			goto MALFORMED_PRAGMA;
		call TFREE (TP);
		TP = GET_NEXT_EXPANDED_TOKEN ();
		if TP = END_PP_DIRECTIVE_TOKEN then
			goto MALFORMED_PRAGMA;
		else if TP->TOKEN_POD.TYPE = RPAREN_TOKEN then do;
			/*
			/* #pragma pack ()
			/**/
			K = 0;
			call TFREE (TP);
		end;
		else if TP->TOKEN_POD.TYPE = DECIMAL_CONSTANT_TOKEN then do;
			/*
			/* #pragma pack ( 1 | 2 | 4 )
			/**/
			S = TOKEN_SPELLING (TP);
			if S = '1' then
				K = 1;
			else if S = '2' then
				K = 2;
			else if S = '4' then
				K = 4;
			else	goto MALFORMED_PRAGMA;
			call TFREET (TP);
			TP = GET_NEXT_EXPANDED_TOKEN ();
			if TP = END_PP_DIRECTIVE_TOKEN then
				goto MALFORMED_PRAGMA;
			else if TP->TOKEN_POD.TYPE ^= RPAREN_TOKEN then
				goto MALFORMED_PRAGMA;
			call TFREE (TP);
		end;
		else	goto MALFORMED_PRAGMA;
		TP = GET_NEXT_EXPANDED_TOKEN ();
		if TP ^= END_PP_DIRECTIVE_TOKEN then do;
			call PP_ERROR_I
			     (ERR_PP_EXTRA_TEXT_DIRECTIVE, 'pragma pack');
			call TFREET (TP);
			call IGNORE_PP_DIRECTIVE ();
		end;
		call PUT_PRAGMA_TOKEN (PRAGMA_PACK_PK, K);
		goto DONE_PP_DIRECTIVE;
	end;

	/* #pragma int_to_unsigned identifier */

	else if S = 'int_to_unsigned' then do;
		/*
		/* TODO: #pragma int_to_unsigned identifier
		/**/
		TP = GET_NEXT_EXPANDED_TOKEN ();
		if TP = END_PP_DIRECTIVE_TOKEN then
			goto MALFORMED_PRAGMA;
		else if TP->TOKEN_POD.TYPE ^= IDENTIFIER_TOKEN then
			goto MALFORMED_PRAGMA;
		call TFREE (TP);
		TP = GET_NEXT_EXPANDED_TOKEN ();
		if TP ^= END_PP_DIRECTIVE_TOKEN then
			goto MALFORMED_PRAGMA;
		goto DONE_PP_DIRECTIVE;
	end;

	/* #pragma weak identifier               */
	/* #pragma weak identifier = identifier1 */

	else if S = 'weak' then do;
		TP = GET_NEXT_EXPANDED_TOKEN ();
		if TP = END_PP_DIRECTIVE_TOKEN then
			goto MALFORMED_PRAGMA;
		else if TP->TOKEN_POD.TYPE ^= IDENTIFIER_TOKEN then
			goto MALFORMED_PRAGMA;
		ID1 = TP->TOKEN_POD.SPELLING;
		call TFREE (TP);
		TP = GET_NEXT_EXPANDED_TOKEN ();
		if TP = END_PP_DIRECTIVE_TOKEN then do;
			/*
			/* #pragma weak identifier
			/**/
			call PUT_PRAGMA_WEAK_TOKEN (ID1, NULL_ID);
			goto DONE_PP_DIRECTIVE;
		end;
		else if TP->TOKEN_POD.TYPE ^= EQUAL_TOKEN then
			goto MALFORMED_PRAGMA;
		call TFREE (TP);
		TP = GET_NEXT_EXPANDED_TOKEN ();
		if TP = END_PP_DIRECTIVE_TOKEN then
			goto MALFORMED_PRAGMA;
		else if TP->TOKEN_POD.TYPE ^= IDENTIFIER_TOKEN then
			goto MALFORMED_PRAGMA;
		ID2 = TP->TOKEN_POD.SPELLING;
		call TFREE (TP);
		TP = GET_NEXT_EXPANDED_TOKEN ();
		if TP ^= END_PP_DIRECTIVE_TOKEN then
			goto MALFORMED_PRAGMA;
		/*
		/* #pragma weak identifier = identifer2
		/**/
		call PUT_PRAGMA_WEAK_TOKEN (ID1, ID2);
		goto DONE_PP_DIRECTIVE;
	end;

	/* #pragma ident string_literal ... */

	else if S = 'ident' then do;
		TP = GET_NEXT_EXPANDED_TOKEN ();
		if TP = END_PP_DIRECTIVE_TOKEN then
			goto MALFORMED_PRAGMA;
		else if TP->TOKEN_POD.TYPE ^= STRING_LITERAL_TOKEN then
			goto MALFORMED_PRAGMA;
		TP = HANDLE_IDENT_DIRECTIVE (TP);
		if TP ^= END_PP_DIRECTIVE_TOKEN then
			goto MALFORMED_PRAGMA;
		goto DONE_PP_DIRECTIVE;
	end;

	if (S ^= 'LPI') | (S = 'lpi') then
		goto UNKNOWN_PRAGMA;

	/* #pragma LPI ... */

	TP = GET_NEXT_EXPANDED_TOKEN ();
	if TP = END_PP_DIRECTIVE_TOKEN then
		goto UNKNOWN_PRAGMA;
	else if TP->TOKEN_POD.TYPE ^= IDENTIFIER_TOKEN then do;
		call TFREET (TP);
		goto UNKNOWN_PRAGMA;
	end;
	S = TOKEN_SPELLING (TP);
	call TFREE (TP);

	/* #pragma LPI once */

	if S = 'once' then do;
		TP = GET_NEXT_EXPANDED_TOKEN ();
		if TP ^= END_PP_DIRECTIVE_TOKEN then
			goto MALFORMED_PRAGMA;
		goto HANDLE_ONCE_DIRECTIVE;
	end;

	/* #pragma LPI wrapper_redeclarations ( on | off ) */

	else if (S = 'wrapper_redeclarations') |
		(S = 'wrapper_declarations') then do;
		TP = GET_NEXT_EXPANDED_TOKEN ();
		if TP = END_PP_DIRECTIVE_TOKEN then
			goto MALFORMED_PRAGMA;
		else if TP->TOKEN_POD.TYPE ^= LPAREN_TOKEN then
			goto MALFORMED_PRAGMA;
		call TFREE (TP);
		TP = GET_NEXT_EXPANDED_TOKEN ();
		if TP = END_PP_DIRECTIVE_TOKEN then
			goto MALFORMED_PRAGMA;
		else if TP->TOKEN_POD.TYPE ^= IDENTIFIER_TOKEN then
			goto MALFORMED_PRAGMA;
		S = TOKEN_SPELLING (TP);
		call TFREE (TP);
		TP = GET_NEXT_EXPANDED_TOKEN ();
		if TP = END_PP_DIRECTIVE_TOKEN then
			goto MALFORMED_PRAGMA;
		else if TP->TOKEN_POD.TYPE ^= RPAREN_TOKEN then
			goto MALFORMED_PRAGMA;
		call TFREE (TP);
		TP = GET_NEXT_EXPANDED_TOKEN ();
		if TP ^= END_PP_DIRECTIVE_TOKEN then
			goto MALFORMED_PRAGMA;
		call PUT_TOGGLE_PRAGMA_TOKEN
		     (PRAGMA_WRAPPER_REDECLARATIONS_PK, S);
		goto DONE_PP_DIRECTIVE;
	end;

	/* #pragma LPI allow_asm ( on | off ) */

	else if S = 'allow_asm' then do;
		TP = GET_NEXT_EXPANDED_TOKEN ();
		if TP = END_PP_DIRECTIVE_TOKEN then
			goto MALFORMED_PRAGMA;
		else if TP->TOKEN_POD.TYPE ^= LPAREN_TOKEN then
			goto MALFORMED_PRAGMA;
		call TFREE (TP);
		TP = GET_NEXT_EXPANDED_TOKEN ();
		if TP = END_PP_DIRECTIVE_TOKEN then
			goto MALFORMED_PRAGMA;
		else if TP->TOKEN_POD.TYPE ^= IDENTIFIER_TOKEN then
			goto MALFORMED_PRAGMA;
		S = TOKEN_SPELLING (TP);
		call TFREE (TP);
		TP = GET_NEXT_EXPANDED_TOKEN ();
		if TP = END_PP_DIRECTIVE_TOKEN then
			goto MALFORMED_PRAGMA;
		else if TP->TOKEN_POD.TYPE ^= RPAREN_TOKEN then
			goto MALFORMED_PRAGMA;
		call TFREE (TP);
		TP = GET_NEXT_EXPANDED_TOKEN ();
		if TP ^= END_PP_DIRECTIVE_TOKEN then
			goto MALFORMED_PRAGMA;
		call PUT_TOGGLE_PRAGMA_TOKEN (PRAGMA_ALLOW_ASM_PK, S);
		goto DONE_PP_DIRECTIVE;
	end;

	/* #pragma LPI ident string_literal ... */

	else if (S = 'ident') then do;
		TP = GET_NEXT_EXPANDED_TOKEN ();
		if TP = END_PP_DIRECTIVE_TOKEN then
			goto MALFORMED_PRAGMA;
		else if TP->TOKEN_POD.TYPE ^= STRING_LITERAL_TOKEN then
			goto MALFORMED_PRAGMA;
		TP = HANDLE_IDENT_DIRECTIVE (TP);
		if TP ^= END_PP_DIRECTIVE_TOKEN then
			goto MALFORMED_PRAGMA;
		goto DONE_PP_DIRECTIVE;
	end;

	/* #pragma LPI data_section (name[,attribute[,alignment[,address]]]) */

	else if (S = 'data_section') then do;
		declare SECTION_NAME	type (NID_T);
		declare ATTRIBUTES	type (LONG_T);
		declare ALIGNMENT	type (LONG_T);
		declare ADDRESS		type (LONG_T);
		SECTION_NAME = 0; ATTRIBUTES = 0; ALIGNMENT = 0; ADDRESS = 0;
		TP = GET_NEXT_EXPANDED_TOKEN ();
		if TP = END_PP_DIRECTIVE_TOKEN then
			goto MALFORMED_PRAGMA;
		else if TP->TOKEN_POD.TYPE ^= LPAREN_TOKEN then
			goto MALFORMED_PRAGMA;
		call TFREE (TP);
		TP = GET_NEXT_EXPANDED_TOKEN ();
		if TP->TOKEN_POD.TYPE = STRING_LITERAL_TOKEN then do;
			SECTION_NAME = STORE_TOKEN
				  (IDENTIFIER_TOKEN,
				   TP->TOKEN_POD.SPELLING_PTR->
				       TOKEN_SPELLING_POD.SPELLING);
		end;
		else if TP->TOKEN_POD.TYPE = IDENTIFIER_TOKEN then
			SECTION_NAME = TP->TOKEN_POD.SPELLING;
		else if ((TP->TOKEN_POD.TYPE >= LB_PP_KW_TOKEN) &
			 (TP->TOKEN_POD.TYPE <= HB_PP_KW_TOKEN)) |
			((TP->TOKEN_POD.TYPE >= LB_KW_TOKEN) &
			 (TP->TOKEN_POD.TYPE <= HB_KW_TOKEN)) then do;
			SECTION_NAME = STORE_TOKEN
				  (IDENTIFIER_TOKEN, TOKEN_SPELLING (TP));
		end;
		else if TP->TOKEN_POD.TYPE = RPAREN_TOKEN then
			goto DONE_PRAGMA_DATA_SECTION;
		else	goto MALFORMED_PRAGMA;
		call TFREET (TP);
		TP = GET_NEXT_EXPANDED_TOKEN ();
		if TP = END_PP_DIRECTIVE_TOKEN then
			goto MALFORMED_PRAGMA;
		else if TP->TOKEN_POD.TYPE = RPAREN_TOKEN then do;
			/*
			/* data_section (name)
			/**/
			goto DONE_PRAGMA_DATA_SECTION;
		end;
		else if TP->TOKEN_POD.TYPE ^= COMMA_TOKEN then
			goto MALFORMED_PRAGMA;
		call TFREE (TP);
		/*
		/* data_section (name, attributes ...)
		/**/
		if ^PP_EVALUATE_EXPRESSION (ATTRIBUTES, TP) then
			goto MALFORMED_PRAGMA;
		else if TP = END_PP_DIRECTIVE_TOKEN then
			goto MALFORMED_PRAGMA;
		else if TP->TOKEN_POD.TYPE = RPAREN_TOKEN then do;
			/*
			/* data_section (name, attributes)
			/**/
			goto DONE_PRAGMA_DATA_SECTION;
		end;
		else if TP->TOKEN_POD.TYPE ^= COMMA_TOKEN then
			goto MALFORMED_PRAGMA;
		call TFREE (TP);
		/*
		/* data_section (name, attributes, alignment ...)
		/**/
		if ^PP_EVALUATE_EXPRESSION (ALIGNMENT, TP) then
			goto MALFORMED_PRAGMA;
		else if TP = END_PP_DIRECTIVE_TOKEN then
			goto MALFORMED_PRAGMA;
		else if TP->TOKEN_POD.TYPE = RPAREN_TOKEN then do;
			/*
			/* data_section (name, attributes, alignment)
			/**/
			goto DONE_PRAGMA_DATA_SECTION;
		end;
		else if TP->TOKEN_POD.TYPE ^= COMMA_TOKEN then
			goto MALFORMED_PRAGMA;
		call TFREE (TP);
		/*
		/* data_section (name, attributes, alignment, address ...) 
		/**/
		if ^PP_EVALUATE_EXPRESSION (ADDRESS, TP) then
			goto MALFORMED_PRAGMA;
		else if TP = END_PP_DIRECTIVE_TOKEN then
			goto MALFORMED_PRAGMA;
		else if TP->TOKEN_POD.TYPE = RPAREN_TOKEN then do;
			/*
			/* data_section (name, attributes, alignment, address)
			/**/
			goto DONE_PRAGMA_DATA_SECTION;
		end;
		else	goto MALFORMED_PRAGMA;

		DONE_PRAGMA_DATA_SECTION:

		if TP ^= END_PP_DIRECTIVE_TOKEN then do;
			call TFREET (TP);
			TP = GET_NEXT_EXPANDED_TOKEN ();
			if TP ^= END_PP_DIRECTIVE_TOKEN then
				goto MALFORMED_PRAGMA;
		end;
		/*
		/* Process SECTION, ATTRIBUTES, ALIGNMENT, ADDRESS.
		/**/
		call PUT_PRAGMA_DATA_SECTION_TOKEN
		     (SECTION_NAME, ATTRIBUTES, ALIGNMENT, ADDRESS);
		goto DONE_PP_DIRECTIVE;
	end;

	/* #pragma LPI varargs_used */

	else if (S = 'varargs_used') then do;
		TP = GET_NEXT_EXPANDED_TOKEN ();
		if TP ^= END_PP_DIRECTIVE_TOKEN then
			goto MALFORMED_PRAGMA;
		else	goto DONE_PP_DIRECTIVE;
	end;

	/* #pragma LPI C-header [ ( on | off ) ] */

	if S ^= 'C' then
		goto UNKNOWN_PRAGMA;
	TP = GET_NEXT_EXPANDED_TOKEN ();
	if TP = END_PP_DIRECTIVE_TOKEN then
		goto UNKNOWN_PRAGMA;
	else if TP->TOKEN_POD.TYPE ^= MINUS_TOKEN then do;
		call TFREET (TP);
		goto UNKNOWN_PRAGMA;
	end;
	call TFREE (TP);
	TP = GET_NEXT_EXPANDED_TOKEN ();
	if TP = END_PP_DIRECTIVE_TOKEN then
		goto UNKNOWN_PRAGMA;
	else if TP->TOKEN_POD.TYPE ^= IDENTIFIER_TOKEN then do;
		call TFREET (TP);
		goto UNKNOWN_PRAGMA;
	end;
	S = TOKEN_SPELLING (TP);
	call TFREE (TP);
	if S ^= 'header' then
		goto UNKNOWN_PRAGMA;
	TP = GET_NEXT_EXPANDED_TOKEN ();
	if TP ^= END_PP_DIRECTIVE_TOKEN then do;
		/*
		/* #pragma LPI C-header ( on | off )
		/**/
		if TP->TOKEN_POD.TYPE ^= LPAREN_TOKEN then
			goto MALFORMED_PRAGMA;
		call TFREE (TP);
		TP = GET_NEXT_EXPANDED_TOKEN ();
		if TP = END_PP_DIRECTIVE_TOKEN then
			goto MALFORMED_PRAGMA;
		else if TP->TOKEN_POD.TYPE ^= IDENTIFIER_TOKEN then
			goto MALFORMED_PRAGMA;
		S = TOKEN_SPELLING (TP);
		call TFREE (TP);
		TP = GET_NEXT_EXPANDED_TOKEN ();
		if TP = END_PP_DIRECTIVE_TOKEN then
			goto MALFORMED_PRAGMA;
		if TP->TOKEN_POD.TYPE ^= RPAREN_TOKEN then
			goto MALFORMED_PRAGMA;
		if S = 'on' then
			call BEGIN_C_HEADER_MODE ();
		else if S = 'off' then
			call END_C_HEADER_MODE ();
		else	goto MALFORMED_PRAGMA;
		goto DONE_PP_DIRECTIVE;
	end;
	/*
	/* #pragma LPI C-header
	/**/
	if ^SW_NO_IMPLICIT_C_HEADER_MODE then
		call BEGIN_C_HEADER_MODE ();
	goto DONE_PP_DIRECTIVE;

	UNKNOWN_PRAGMA:
	if SW_PRAGMA_WARN then
		call PP_ERROR (ERR_PP_UNKNOWN_PRAGMA);
	goto SKIP_PP_DIRECTIVE;

	MALFORMED_PRAGMA:
	if TP ^= END_PP_DIRECTIVE_TOKEN then
		call TFREET (TP);
	call PP_ERROR (ERR_PP_MALFORMED_PRAGMA);
	goto SKIP_PP_DIRECTIVE;

	/* -------------------------------------------------------------
	 * PP_KW_UNDEF_TOKEN
	 *
	 * #undef identifier
	 * ----------------------------------------------------------- */

	PP_DIRECTIVE (PP_KW_UNDEF_TOKEN):

	TP = GET_NEXT_LEXICAL_TOKEN ();
	if TP = END_PP_DIRECTIVE_TOKEN then do;
		call PP_ERROR_I (ERR_PP_EMPTY_DIRECTIVE, 'undef');
		goto DONE_PP_DIRECTIVE;
	end;
	if TP->TOKEN_POD.TYPE ^= IDENTIFIER_TOKEN then do;
		call PP_ERROR_I (ERR_PP_NO_DIRECTIVE_IDENTIFIER, 'undef');
		goto SKIP_PP_DIRECTIVE;
	end;

	/* Make sure we're not trying to undefine a predefined macro name */

	if IS_RESERVED_PP_KEYWORD (TP->TOKEN_POD.SPELLING) then do;
		call PP_ERROR_I (ERR_PP_ILLEGAL_UNDEF_IDENTIFIER,
				 TOKEN_SPELLING (TP));
		goto SKIP_PP_DIRECTIVE;
	end;

	/* Undefine the macro */

	call UNDEF_MACRO (TP->TOKEN_POD.SPELLING);

	C = SCAN_NEXT_CHAR ();
	if C ^= END_PP_DIRECTIVE_CHAR then do;
		if C = EOF_IN_DIRECTIVE_CHAR then do;
			call HANDLE_END_OF_FILE (C);
			goto DONE_PP_DIRECTIVE;
		end;
		call PP_ERROR_I (ERR_PP_EXTRA_TEXT_DIRECTIVE, 'undef');
		call IGNORE_PP_DIRECTIVE ();
	end;

	goto DONE_PP_DIRECTIVE;

	/* ----------------------------------------------
	 * Skip the rest of this preprocessing directive.
	 * -------------------------------------------- */

	SKIP_PP_DIRECTIVE:

	call IGNORE_PP_DIRECTIVE ();

	/* ----------------------------------
	 * Done with preprocessing directive.
	 * -------------------------------- */

	DONE_PP_DIRECTIVE:

	TP = END_PP_DIRECTIVE_TOKEN;

	/* --------------------------------------------------------
	 * Done with preprocessing directive, "TP" is return token.
	 * ------------------------------------------------------ */

	DONE_TOKEN_PP_DIRECTIVE:

	/* Restore the lexical context */

	SCAN_NEXT_CHAR	= SAVE_SCAN_NEXT_CHAR;

	return (TP);

	/* --------------------------------
	/* Unknown preprocessing directive.
	/* ------------------------------ */

	UNKNOWN_PP_DIRECTIVE:
	call PP_ERROR_I (ERR_PP_UNKNOWN_DIRECTIVE, TOKEN_SPELLING (TP));
	call TFREET (TP);
	goto SKIP_PP_DIRECTIVE;

/* =====================================================================
/* SKIP_GROUP
/*
/* Skips past (i.e. ignores) a group of source text.
/*
/* If KIND is PP_KW_IF_TOKEN, then an #if type group will be skipped.
/* In this case, the source file be will scanned for the next
/* unmatched #elif, #else, or #endif, and will return PP_KW_ELIF_TOKEN,
/* PP_KW_ELSE_TOKEN, or PP_KW_ENDIF_TOKEN respectively.
/*
/* If KIND is PP_KW_ELSE_TOKEN, then an #else type group will be
/* skipped.  In this case, the source file be will scanned for the
/* next unmatched #endif and will return PP_KW_ENDIF_TOKEN.
/*
/* If the end of an include file is encountered while skipping the group,
/* just pop the include stack and continue (not an error).  If the end
/* of the main file is encountered while skipping the group, then emit
/* an appropriate error message and non-local-goto END_OF_MAIN_FILE.
/* =================================================================== */

SKIP_GROUP: procedure (KIND)  returns (type (SHORT_T));

	declare
		KIND		type (SHORT_T);
	declare
		(C, K)		type (SHORT_T),
		LEVEL		type (SHORT_T),
		(P, TP)		type (POINTER_T);

	EXCLUDE_FROM_LINE = CURRENT_SOURCE.PHYSICAL_LINE;
	EXCLUDE_FROM_FILE = CURRENT_SOURCE.PHYSICAL_NAME;

	LEVEL = 1;

	NEXT_SKIP_GROUP_TOKEN:

	/* Scan to the next preprocessor directive */

	/*
	 * If end-of-file is encountered within a skipped group, this does not
	 * have to be an error if it was within an include file and the source
	 * we pop back to contains the #endif (or whatever) that we're looking
	 * for.  In any case, an appropriate end-of-file token-pod must be sent.
	 */

	C = SSCANX ();
	if C = EOF_IN_SKIP_GROUP_CHAR then do;
		call HANDLE_END_OF_FILE (C);
		goto NEXT_SKIP_GROUP_TOKEN;
	end;

	/* Determine the type of preprocessor directive */

	P = GET_NEXT_LEXICAL_TOKEN ();
	if P = END_PP_DIRECTIVE_TOKEN then
		goto NEXT_SKIP_GROUP_TOKEN;
	if P->TOKEN_POD.TYPE ^= IDENTIFIER_TOKEN then do;
		call TFREE (P);
		goto NEXT_SKIP_GROUP_TOKEN;
	end;
	K = LOOKUP_PP_KEYWORD (P->TOKEN_POD.SPELLING);
	call TFREET (P);

	/* Skipping an #else-type group (stop at #endif) */

	if KIND = PP_KW_ELSE_TOKEN then do;
		if K = PP_KW_ENDIF_TOKEN then do;
			if LEVEL = 1 then
				return (K);
			else	LEVEL = LEVEL - 1;
		end;
		else if (K = PP_KW_IF_TOKEN) |
			(K = PP_KW_IFDEF_TOKEN) | (K = PP_KW_IFNDEF_TOKEN) then
			LEVEL = LEVEL + 1;
	end;

	/* Skipping an #if-type group (stop at #endif, #else, or #elif) */

	else do;
		if K = PP_KW_ENDIF_TOKEN then do;
			if LEVEL = 1 then
				return (K);
			else	LEVEL = LEVEL - 1;
		end;
		else if (K = PP_KW_ELIF_TOKEN) |
			(K = PP_KW_ELSEIF_TOKEN) |
			(K = PP_KW_ELSE_TOKEN) then do;
			if LEVEL = 1 then
				return (K);
		end;
		else if (K = PP_KW_IF_TOKEN) |
			(K = PP_KW_IFDEF_TOKEN) | (K = PP_KW_IFNDEF_TOKEN) then
			LEVEL = LEVEL + 1;
	end;

	goto NEXT_SKIP_GROUP_TOKEN;

end; /* SKIP_GROUP */

/* =====================================================================
/* OPEN_QUOTE_INCLUDE_FILE -- #include "file.h"
/* OPEN_ANGLE_INCLUDE_FILE -- #include <file.h>
/* OPEN_CURLY_INCLUDE_FILE -- #include {file.h}
/* =================================================================== */

OPEN_QUOTE_INCLUDE_FILE:	procedure (FILE_NAME);

	declare
		FILE_NAME			character (*) varying;
	declare
		STRONGLY_FAVOR_LPI_HEADER_DIR	type (BOOL_T),
		IS_C_HEADER			type (BOOL_T),
		PREV_WAS_DIR_DELIM_CHAR		type (BOOL_T),
		BASE_FILE_NAME_POS		type (SHORT_T),
		HEADER_KIND			type (SHORT_T),
		INCLUDE_KIND			type (SHORT_T),
		(TP, P)				type (POINTER_T),
		(I, J)				type (INT_T),
		NAME				character
						(MAX_FILE_NAME_LENGTH)
						varying;
	/* Include file kinds */

	%replace ANGLE_IK	by 0;
	%replace QUOTE_IK	by 1;
	%replace CURLY_IK	by 2;

	if SW_TREAT_QUOTE_INCLUDE_AS_ANGLE then
		INCLUDE_KIND = ANGLE_IK;
	else	INCLUDE_KIND = QUOTE_IK;
	goto COMMON_OPEN_INCLUDE_FILE;

OPEN_CURLY_INCLUDE_FILE:	entry (FILE_NAME);

	INCLUDE_KIND = CURLY_IK;
	goto COMMON_OPEN_INCLUDE_FILE;

OPEN_ANGLE_INCLUDE_FILE:	entry (FILE_NAME);

	INCLUDE_KIND = ANGLE_IK;

	/* goto COMMON_OPEN_INCLUDE_FILE; -- FALL THRU */

COMMON_OPEN_INCLUDE_FILE:

	/* Translate (target to host) directory delimiters if necessary */

	if HOST_DIR_DELIM ^= TARGET_DIR_DELIM then do;
		FILE_NAME = translate (FILE_NAME,
				       HOST_DIR_DELIM,
				       TARGET_DIR_DELIM);
	end;

	/*
	/* Compress multiple consecutive occurrences of the
	/* directory delimiter character ("/" on UNIX) into one;
	/* e.g. //usr/include/stdio.h --> /usr/include/stdio.h.
	/* Also, note the position of the first character after the
	/* last directory delimiter character (i.e. the position of
	/* the base file name); this is so we can quickly prepend
	/* the wrapper header file prefix later.
	/**/

	J = 0; PREV_WAS_DIR_DELIM_CHAR = FALSE; BASE_FILE_NAME_POS = 0;

	do I = 1 to length (FILE_NAME);
		if substr (FILE_NAME, I, 1) ^= HOST_DIR_DELIM then do;
			if J > 0 then do;
				substr (FILE_NAME, I - J, 1)
					= substr (FILE_NAME, I, 1);
			end;
			if PREV_WAS_DIR_DELIM_CHAR then do;
				BASE_FILE_NAME_POS = I - J;
				PREV_WAS_DIR_DELIM_CHAR = FALSE;
			end;
		end;
		else if ^PREV_WAS_DIR_DELIM_CHAR then do;
			if J > 0 then do;
				substr (FILE_NAME, I - J, 1)
					= substr (FILE_NAME, I, 1);
			end;
			PREV_WAS_DIR_DELIM_CHAR = TRUE;
		end;
		else	J = J + 1;
	end;

	if J > 0 then
		FILE_NAME = substr (FILE_NAME, 1, I - J - 1);

	/*
	/* If a fully qualified path is given then look
	/* for the given file-name *only*, regardless
	/* of what kind of #include this is.
	/**/

	if substr (FILE_NAME, 1, 1) = HOST_DIR_DELIM then do;
		HEADER_KIND = VANILLA_SK;
		if length (FILE_NAME) >
		   length (STANDARD_ANSI_C_HEADER_DIR) + 1 then do;
			if substr (FILE_NAME, 1,
				   length (STANDARD_ANSI_C_HEADER_DIR))
			   = STANDARD_ANSI_C_HEADER_DIR then do;
				if substr (FILE_NAME, 1,
					   length (STANDARD_CXX_HEADER_DIR))
				   ^= STANDARD_CXX_HEADER_DIR then
					HEADER_KIND = C_HEADER_SK;
			end;
		end;
		if length (FILE_NAME) >
		   length (STANDARD_SYSTEM_HEADER_DIR) + 1 then do;
			if substr (FILE_NAME, 1,
				   length (STANDARD_SYSTEM_HEADER_DIR)) =
			   STANDARD_SYSTEM_HEADER_DIR then
				HEADER_KIND = SYSTEM_HEADER_SK;
		end;
		if OPEN_SOURCE (FILE_NAME, HEADER_KIND) then
			return;
		goto CANNOT_OPEN_INCLUDE_FILE;
	end;

	/*
	/* See if want to look *only* in the standard system directory
	/* this is "CURLY" case, i.e #include {file.h}, which is an
	/* LPI-C++ extension added to help us deal with LPI-C++ system
	/* header file wrappers.
	/**/

	if INCLUDE_KIND = CURLY_IK then do;
		/*
		/* Look in the standard system header directory *only*.
		/**/
		NAME = STANDARD_SYSTEM_HEADER_DIR ||
		       HOST_DIR_DELIM || FILE_NAME;
		if OPEN_SOURCE (NAME, SYSTEM_HEADER_SK) then
			return;
		else	goto CANNOT_OPEN_INCLUDE_FILE;
	end;

	else if INCLUDE_KIND = QUOTE_IK then do;
		/*
		/* Look in directory containing the
		/* current (including) source file.
		/**/
		P = CURRENT_SOURCE.PHYSICAL_NAME;
		do I = length (P->STR) to 1 by -1
		while (substr (P->STR ,I ,1) ^= HOST_DIR_DELIM);
			;
		end;
		NAME = substr (P->STR, 1, I) || FILE_NAME;

		if OPEN_SOURCE (NAME, VANILLA_SK) then
			return;
		/*
		/* If not found, then try as if #include <file.h>
		/**/
	end;

	/*
	/* Look in the directory(s) named in search path; directory names
	/* are separated by colons (:).  Directory names which begin with
	/* "C-" are special; in this case, the directory is regarded as a
	/* C-header directory and any file #included via that directory path
	/* will be treated as if it were preprended with #pragma LPI C-header;
	/* the "C-" will be discarded.  This "C-" prefix is automatically
	/* added on to each path in a list specified by the "-ipathc" option.
	/**/

	if length (INCLUDE_SEARCH_PATH) > 0 then do;
		NAME = '';
		IS_C_HEADER = FALSE;
		do I = 1 to length (INCLUDE_SEARCH_PATH);
			if substr (INCLUDE_SEARCH_PATH, I, 1) ^=
			    byte (COLON_CHAR) then do;
				NAME = NAME ||
				       substr (INCLUDE_SEARCH_PATH, I, 1);
			end;
			else if length (NAME) > 0 then do;
				if (substr (NAME, 1, 2) = 'C-') &
				   (length (NAME) > 2) then do;
					NAME = substr (NAME, 3);
					IS_C_HEADER = TRUE;
				end;
				NAME = NAME || HOST_DIR_DELIM || FILE_NAME;
				if IS_C_HEADER then
					HEADER_KIND = C_HEADER_SK;
				else	HEADER_KIND = VANILLA_SK;
				if OPEN_SOURCE (NAME, HEADER_KIND) then
					return;
				else	IS_C_HEADER = FALSE;
				NAME = '';
			end;
		end;
		if length (NAME) > 0 then do;
			if (substr (NAME, 1, 2) = 'C-') &
			   (length (NAME) > 2) then do;
				NAME = substr (NAME, 3);
				IS_C_HEADER = TRUE;
			end;
			NAME = NAME || HOST_DIR_DELIM || FILE_NAME;
			if IS_C_HEADER then
				HEADER_KIND = C_HEADER_SK;
			else	HEADER_KIND = VANILLA_SK;
			if OPEN_SOURCE (NAME, HEADER_KIND) then
				return;
		end;
	end;

	/*
	/* For <stdarg.h> and <varargs.h>, we'll use our own version,
	/* even if "-sys" is specified; this is because this "varargs"
	/* functionality is very closely tied to the compiler
	/* implementation (especially on RISC architectures).
	/**/

	if (FILE_NAME = 'stdarg.h') |
	   (FILE_NAME = 'varargs.h') |
	   (FILE_NAME = 'sys/varargs.h') |
	   (FILE_NAME = 'prof.h') then do;
		STRONGLY_FAVOR_LPI_HEADER_DIR = TRUE;
		VA_START_NAME = STORE_TOKEN (IDENTIFIER_TOKEN, 'va_start');
	end;
	else	STRONGLY_FAVOR_LPI_HEADER_DIR = FALSE;

	/* Search the standard places */

	if  SW_FAVOR_SYSTEM_HEADER_DIR &
	   ^STRONGLY_FAVOR_LPI_HEADER_DIR then do;
		if ^SW_CLASSIC_C_MODE & ^SW_NO_WRAPPERS then do;
			/*
			/* Look in the standard system
			/* header wrapper directory.
			/**/
			if BASE_FILE_NAME_POS > 0 then do;
				NAME = STANDARD_SYSTEM_HEADER_WRAP_DIR ||
				       HOST_DIR_DELIM ||
				       substr (FILE_NAME, 1,
					       BASE_FILE_NAME_POS - 1) ||
				       WRAP_HEADER_FILE_PREFIX ||
				       substr (FILE_NAME, BASE_FILE_NAME_POS);
			end;
			else do;
				NAME = STANDARD_SYSTEM_HEADER_WRAP_DIR ||
				       HOST_DIR_DELIM ||
				       WRAP_HEADER_FILE_PREFIX || FILE_NAME;
			end;
			if OPEN_SOURCE (NAME, SYSTEM_HEADER_SK) then
				return;
		end;
		/*
		/* Look in the standard system header directory.
		/**/
		NAME = STANDARD_SYSTEM_HEADER_DIR ||
		       HOST_DIR_DELIM || FILE_NAME;
		if OPEN_SOURCE (NAME, SYSTEM_HEADER_SK) then
			return;
	end;

	if SW_C_PLUS_PLUS then do;
		/*
		/* Look in the standard LPI-C++ header directory.
		/**/
		NAME = STANDARD_CXX_HEADER_DIR ||
		       HOST_DIR_DELIM || FILE_NAME;
		if OPEN_SOURCE (NAME, VANILLA_SK) then
			return;
	end;

	if SW_C_PLUS_PLUS |
	   SW_ANSI_C_MODE |
	   STRONGLY_FAVOR_LPI_HEADER_DIR then do;
		/*
		/* Look in the standard LPI-C (ANSI) header directory.
		/**/
		NAME = STANDARD_ANSI_C_HEADER_DIR ||
		       HOST_DIR_DELIM || FILE_NAME;
		if OPEN_SOURCE (NAME, C_HEADER_SK) then
			return;
	end;

	if SW_CLASSIC_C_MODE then do;
		if (FILE_NAME = 'sysdef.h') |
		   (FILE_NAME = 'common.h') |
		   (FILE_NAME = 'machine.h') then do;
			/*
			/* Look in the standard LPI-C (ANSI) header directory.
			/**/
			NAME = STANDARD_ANSI_C_HEADER_DIR ||
			       HOST_DIR_DELIM || FILE_NAME;
			if OPEN_SOURCE (NAME, C_HEADER_SK) then
				return;
		end;
	end;

	if ^SW_FAVOR_SYSTEM_HEADER_DIR |
	    STRONGLY_FAVOR_LPI_HEADER_DIR then do;
		if ^SW_CLASSIC_C_MODE & ^SW_NO_WRAPPERS then do;
			/*
			/* Look in the standard system
			/* header wrapper directory.
			/**/
			if BASE_FILE_NAME_POS > 0 then do;
				NAME = STANDARD_SYSTEM_HEADER_WRAP_DIR ||
				       HOST_DIR_DELIM ||
				       substr (FILE_NAME, 1,
					       BASE_FILE_NAME_POS - 1) ||
				       WRAP_HEADER_FILE_PREFIX ||
				       substr (FILE_NAME, BASE_FILE_NAME_POS);
			end;
			else do;
				NAME = STANDARD_SYSTEM_HEADER_WRAP_DIR ||
				       HOST_DIR_DELIM ||
				       WRAP_HEADER_FILE_PREFIX || FILE_NAME;
			end;
			if OPEN_SOURCE (NAME, SYSTEM_HEADER_SK) then
				return;
		end;
		/*
		/* Look in the standard system header directory.
		/**/
		NAME = STANDARD_SYSTEM_HEADER_DIR ||
		       HOST_DIR_DELIM || FILE_NAME;
		if OPEN_SOURCE (NAME, SYSTEM_HEADER_SK) then
			return;
	end;

	CANNOT_OPEN_INCLUDE_FILE:
	call PP_ERROR_I (ERR_PP_OPEN_INCLUDE, FILE_NAME);
	return;

end; /* OPEN_QUOTE_INCLUDE_FILE */

/* =====================================================================
/* READ_MACRO_DEFINITION
/*
/* Read/process this macro definition preprocessing directive (i.e. a
/* #define line).  The argument is a pointer to the token-pod which is
/* assumed to be an IDENTIFIER_TOKEN representing the identifier name
/* for this macro definition.  It is assumed that only the #define
/* directive keyword and the macro identifer have been read.
/*
/* If an error was encountered, then an appropriate error message will
/* be emitted and the remainder of the preprocessing directive will be
/* skipped.
/*
/* It is an error to try to define a predefined macro identifier.
/*
/* It is not an error to define an already defined macro identifier so
/* long as the definition is equivalent; if it is not equivalent, then
/* a warning will be given, and the macro will be redefined.
/*
/* The replacement list of a defined macro is kept in a linked list of
/* token-pods which hangs off of the REPLACEMENT
/* field of the macro-node (i.e. MACRO_NODE).  If the a sequence of
/* white-space preceded any token in the replacement list, then the
/* LINE field of the corresponding token will be set negative.
/*
/* If the macro is an object-like macro then the VALUE field of the
/* macro-node will be the negative constant OBJECT_LIKE_MACRO.
/*
/* If the macro is a function-like macro, then the VALUE field of the
/* macro-node represents the number of arguments (possibly zero).  In
/* this case, the parameter list is kept as a simple array of LPI symbol
/* table token-node id's which refer to the spelling of each parameter
/* in the parameter list; this list is pointed to by the PARAMETER field
/* of the MACRO_NODE and can be easily referenced through the use of
/* the array MACRO_PARAMETER_LIST and the accompanying size variable
/* MACRO_PARAMETER_COUNT.
/*
/* If a token in the replacement list is a parameter identifier, then
/* the TYPE field of the TOKEN_POD for that token will be set to
/* PP_MACRO_ARGUMENT_TOKEN, and the VALUE field will be set to the
/* (one indexed) position of the corresponding parameter in the
/* parameter list declaration.
/*
/* ---------------------------------------------------------------------
/* [See] ANSI-C (X3J11/88-159) Sec. 3.8.3, Constraints
/* =================================================================== */

READ_MACRO_DEFINITION: procedure (MACRO_TOKEN);

	declare
		MACRO_TOKEN			type (POINTER_T);
	declare
		REPLACEMENT_LIST		type (POINTER_T),
		END_REPLACEMENT_LIST		type (POINTER_T),
		PARAMETER_LIST			type (POINTER_T);
	declare
		I				type (SHORT_T),
		(P, MP)				type (POINTER_T),
		PRECEDING_SPACE			type (BOOL_T),
		PERNICIOUS_MACRO_REDEFINITION	type (BOOL_T),
		S				character (2048) varying;
	declare
		SAVE_SCAN_NEXT_CHAR		entry
						returns (type (SHORT_T))
						variable;

	/* Make sure we're not trying to define a predefined macro name */

	if IS_RESERVED_PP_KEYWORD (MACRO_TOKEN->TOKEN_POD.SPELLING) then do;
		if MACRO_TOKEN->TOKEN_POD.SPELLING = STDC_PP_KW_NAME then do;
			if LOOKUP_MACRO (STDC_PP_KW_NAME) = null () then
				goto BEGIN_READ_MACRO_DEFINITION;
		end;
		call PP_ERROR_I (ERR_PP_ILLEGAL_DEFINE_IDENTIFIER,
				 TOKEN_SPELLING (MACRO_TOKEN));
		call IGNORE_PP_DIRECTIVE ();
		return;
	end;

	BEGIN_READ_MACRO_DEFINITION:

	/* Save and change the lexical context */

	SAVE_SCAN_NEXT_CHAR	= SCAN_NEXT_CHAR;
	SCAN_NEXT_CHAR		= SCAND_NEXT_CHAR;

	/* Initialize data */

	PRECEDING_SPACE = FALSE;

	REPLACEMENT_LIST = null ();
	END_REPLACEMENT_LIST = null ();

	MACRO_PARAMETER_COUNT = -1;
	PARAMETER_LIST = null ();

	/* -----------------------------------------------------
	 * Get the replacement list (and parameter list if any).
	 * --------------------------------------------------- */

	NEXT_MACRO_DEFINITION_TOKEN:

	P = GET_NEXT_LEXICAL_TOKEN ();

	if P = END_PP_DIRECTIVE_TOKEN then
		goto END_OF_MACRO_DEFINITION;

	if P = WHITE_SPACE_TOKEN then do;
		PRECEDING_SPACE = TRUE;
		goto NEXT_MACRO_DEFINITION_TOKEN;
	end;

	if REPLACEMENT_LIST = null () then do;
		if PRECEDING_SPACE then
			PRECEDING_SPACE = FALSE;
		else if (P->TOKEN_POD.TYPE = LPAREN_TOKEN) &
			(MACRO_PARAMETER_COUNT < 0) then do;
			call TFREE (P);
			call READ_MACRO_PARAMETER_LIST ();
			if MACRO_PARAMETER_COUNT < 0 then return;
			goto NEXT_MACRO_DEFINITION_TOKEN;
		end;
		REPLACEMENT_LIST = P;
	end;

	else do;
		END_REPLACEMENT_LIST->TOKEN_POD.NEXT = P;
		P->TOKEN_POD.NEXT = null ();
	end;

	/* See if this identifer corresponds to a formal parameter */

	if (P->TOKEN_POD.TYPE = IDENTIFIER_TOKEN) &
	   (MACRO_PARAMETER_COUNT > 0) then do;
		do I = 1 to MACRO_PARAMETER_COUNT;
			if PARAMETER_LIST->MACRO_PARAMETER_LIST(I) =
			   P->TOKEN_POD.SPELLING then do;
				P->TOKEN_POD.TYPE = PP_MACRO_PARAMETER_TOKEN;
				P->TOKEN_POD.VALUE = I;
			end;
		end;
	end;

	/* See if this token is preceded by a space */

	if PRECEDING_SPACE & (REPLACEMENT_LIST ^= null ()) then do;
		P->TOKEN_POD.LINE = -(P->TOKEN_POD.LINE);
		PRECEDING_SPACE = FALSE;
	end;

	END_REPLACEMENT_LIST = P;

	goto NEXT_MACRO_DEFINITION_TOKEN;

	/* --------------------------------------------------
	 * Here, we've finished reading the macro definition.
	 * ------------------------------------------------ */

	END_OF_MACRO_DEFINITION:

	/* Sanity check any token-paste operators */

	call CHECK_TOKEN_PASTE ();

	/* Sanity check any stringize operators */

	if MACRO_PARAMETER_COUNT >= 0 then
		call CHECK_STRINGIZE ();

	/* See if this macro name has been previously defined */

	MP = LOOKUP_MACRO_BY_TOKEN (MACRO_TOKEN);

	if MP ^= null () then do;

	/*
	 * Here, this macro has been previously defined.  If this definition
	 * is exactly identical to the previous (as defined by the Standard),
	 * then do nothing (keep the old definition), otherwise emit a
	 * warning and *ignore* the current definition, unless a switch was
	 * given indicating that pernicious (destructive) redefinitions of
	 * macros should be accepted, in which case we'll emit a warning and
	 * *redefine* it.  If this macro is *functionally* identical to the
	 * previous definitinon (i.e. if the only differ in the spellings
	 * of any macro parameter names), then just emit a light warning,
	 * unless a switch is given indicating that no such warning should
	 * be emitted.  See section 3.8.3 of the Standard.
	 */
		S = '"' || TOKEN_SPELLING (MACRO_TOKEN) || '" ';
		if MP->MACRO_NODE.LINE ^= 0 then do;
			S = S || 'was previously defined on line ' ||
			trim (char (MP->MACRO_NODE.LINE));
			if MP->MACRO_NODE.FILE->STR ^=
			   CURRENT_SOURCE.PHYSICAL_NAME->STR then
				S = S || ', "' ||
				    MP->MACRO_NODE.FILE->STR || '"';
		end;
		else	S = S || 'was predefined on the command line';
    
		PERNICIOUS_MACRO_REDEFINITION = FALSE;
		if (MACRO_PARAMETER_COUNT ^= MP->MACRO_NODE.NPARAMETERS) then
			PERNICIOUS_MACRO_REDEFINITION = TRUE;
		else if ^SAME_MACRO_REPLACEMENT_LIST
			 (REPLACEMENT_LIST, MP->MACRO_NODE.REPLACEMENT) then
			PERNICIOUS_MACRO_REDEFINITION = TRUE;
		else if MACRO_PARAMETER_COUNT > 0 then do;
			if ^SAME_MACRO_PARAMETER_LIST
			    (PARAMETER_LIST, MP->MACRO_NODE.PARAMETER,
			     MACRO_PARAMETER_COUNT) then do;
				if ^SW_X_INNOCUOUS_MACRO_REDEF then
				    call PP_ERROR_I
					 (ERR_PP_HARMLESS_DUP_DEFINE, S);

			end;
		end;
		if PERNICIOUS_MACRO_REDEFINITION then do;
			if SW_X_PERNICIOUS_MACRO_REDEF then do;
				call PP_ERROR_I (ERR_PP_DUP_DEFINE_OK, S);
				call UNDEF_MACRO (MP->MACRO_NODE.NAME);
				goto DEFINE_THE_MACRO;
			end;
			else	call PP_ERROR_I (ERR_PP_DUP_DEFINE, S);
		end;
		if ^SW_X_PERNICIOUS_MACRO_REDEF then do;
			call TFREEL (REPLACEMENT_LIST);
			if MACRO_PARAMETER_COUNT > 0 then
				free PARAMETER_LIST->MACRO_PARAMETER_LIST;
		end;
	end;

	else do;

	/*
	 * Here, this macro has not yet been defined; define it!
	 */
		DEFINE_THE_MACRO:
		MP = DEFINE_MACRO (MACRO_TOKEN->TOKEN_POD.SPELLING);
		MP->MACRO_NODE.REPLACEMENT = REPLACEMENT_LIST;
		MP->MACRO_NODE.PARAMETER   = PARAMETER_LIST;
		MP->MACRO_NODE.NPARAMETERS = MACRO_PARAMETER_COUNT;
		MP->MACRO_NODE.FILE	   = CURRENT_SOURCE.PHYSICAL_NAME;
		MP->MACRO_NODE.LINE	   = CURRENT_SOURCE.PHYSICAL_LINE;
	end;

	/*
	 * Check for PCC-style macro parameter substitution
	 * within string literals or character constants.
	 */

	if SW_X_STRINGIZE      | SW_X_CHARIZE |
	   SW_X_STRINGIZE_WARN | SW_X_CHARIZE_WARN then
		call PCC_STYLE_STRINGIZE_CHARIZE (MP);

	/* Restore the lexical context */

	SCAN_NEXT_CHAR	= SAVE_SCAN_NEXT_CHAR;

	return;

/* =====================================================================
/* READ_MACRO_PARAMETER_LIST
/*
/* Read/parse a function-like macro parameter list.  Set PARAMETER_LIST
/* to the saved list of LPI symbol table token node ID's which refer
/* to the spelling of each parameter in the parameter list.  Set
/* MACRO_PARAMETER_COUNT to the number (possibly zero) of parameters in
/* the parameter list; if the number of parameters happens to be zero
/* then a PARAMETER_LIST is set to a null pointer.
/*
/* If an error was encountered, then an appropriate error message will
/* be emitted, the remainder of the preprocessing directive will be
/* skipped, and MACRO_PARAMETER_COUNT will be set to -1.
/* =================================================================== */

READ_MACRO_PARAMETER_LIST: procedure;

	declare
		LIST			(MAX_MACRO_PARAMETERS)
					type (NID_T),
		STATE			type (SHORT_T),
		ERROR			type (SHORT_T),
		(I, J)			type (SHORT_T),
		P			type (POINTER_T),
		SAVE_SCAN_NEXT_CHAR	entry returns (type (SHORT_T))
					variable;

	/* Save and change the lexical context */

	SAVE_SCAN_NEXT_CHAR	= SCAN_NEXT_CHAR;
	SCAN_NEXT_CHAR		= SCANP_NEXT_CHAR;

	/* Initialize local data */

	MACRO_PARAMETER_COUNT = 0;
	STATE = LPAREN_TOKEN;
	ERROR = ERR_PP_ILLEGAL_PARAMETERS;

	do P = GET_NEXT_LEXICAL_TOKEN ()
	repeat GET_NEXT_LEXICAL_TOKEN () while (P ^= END_PP_DIRECTIVE_TOKEN);
		if P->TOKEN_POD.TYPE = RPAREN_TOKEN then do;
			call TFREE (P);
			if (STATE ^= IDENTIFIER_TOKEN) & (STATE ^= LPAREN_TOKEN)
			then do;
				call IGNORE_PP_DIRECTIVE ();
				goto ERROR_MACRO_PARAMETER_LIST;
			end;
			else	goto GOT_MACRO_PARAMETER_LIST;
		end;
		else if P->TOKEN_POD.TYPE = IDENTIFIER_TOKEN then do;
			if (STATE ^= LPAREN_TOKEN) & (STATE ^= COMMA_TOKEN)
			then do;
				call TFREE (P);
				call IGNORE_PP_DIRECTIVE ();
				goto ERROR_MACRO_PARAMETER_LIST;
			end;
			if MACRO_PARAMETER_COUNT >= MAX_MACRO_PARAMETERS
			then do;
				call TFREE (P);
				call IGNORE_PP_DIRECTIVE ();
				ERROR = ERR_PP_TOO_MANY_PARAMETERS;
				goto ERROR_MACRO_PARAMETER_LIST;
			end;
			MACRO_PARAMETER_COUNT = MACRO_PARAMETER_COUNT + 1;
			LIST (MACRO_PARAMETER_COUNT) = P->TOKEN_POD.SPELLING;
			STATE = IDENTIFIER_TOKEN;
			call TFREE (P);
		end;
		else if P->TOKEN_POD.TYPE = COMMA_TOKEN then do;
			call TFREE (P);
			if STATE ^= IDENTIFIER_TOKEN then do;
				call IGNORE_PP_DIRECTIVE ();
				goto ERROR_MACRO_PARAMETER_LIST;
			end;
			STATE = COMMA_TOKEN;
		end;
		else do;
			call TFREE (P);
			call IGNORE_PP_DIRECTIVE ();
			goto ERROR_MACRO_PARAMETER_LIST;
		end;
	end;

	ERROR_MACRO_PARAMETER_LIST:

	call PP_ERROR_I (ERROR, TOKEN_SPELLING (MACRO_TOKEN));
	MACRO_PARAMETER_COUNT = -1;
	goto DONE_MACRO_PARAMETER_LIST;

	GOT_MACRO_PARAMETER_LIST:

	if MACRO_PARAMETER_COUNT = 0 then goto DONE_MACRO_PARAMETER_LIST;

	/* ---------------------------------------------------
	 * [Excerpt] ANSI-C (X3J11/88-090), 3.8.3, Constraints
	 * ---------------------------------------------------
	 * A parameter identifier in a function-like macro
	 * shall be uniquely declared within its scope.
	 * ------------------------------------------------- */

	do I = 1 to MACRO_PARAMETER_COUNT - 1;
		do J = I + 1 to MACRO_PARAMETER_COUNT;
			if LIST (I) = LIST (J) then do;
				call IGNORE_PP_DIRECTIVE ();
				ERROR = ERR_PP_DUP_PARAMETERS;
				goto ERROR_MACRO_PARAMETER_LIST;
			end;
		end;
	end;

	/* Allocate and set up a parameter list */

	allocate MACRO_PARAMETER_LIST set (PARAMETER_LIST);
	do I = 1 to MACRO_PARAMETER_COUNT;
		PARAMETER_LIST->MACRO_PARAMETER_LIST (I) = LIST (I);
	end;

	DONE_MACRO_PARAMETER_LIST:

	/* Restore the lexical context */

	SCAN_NEXT_CHAR	= SAVE_SCAN_NEXT_CHAR;

end; /* READ_MACRO_PARAMETER_LIST */

/* =====================================================================
/* CHECK_STRINGIZE
/*
/* Check the validity of any stringize operators in the (null terminated)
/* linked list of token-pods representing the replacement list of a
/* function-like macro definition.  The first and last token-pods in
/* the list are pointed to by REPLACEMENT_LIST and END_REPLACEMENT_LIST
/* respectively.  If an error is found, then an appropriate message will
/* be emitted; the stringize operator will NOT be deleted from the list.
/* ---------------------------------------------------------------------
/* [Excerpt] ANSI-C (X3J11/88-090), 3.8.3.2, Constraints:
/* ---------------------------------------------------------------------
/* A "#" preprocessing in the replacement list for a function like macro
/* shall be follewed by a parameter as the next preprocessing token in
/* the replacement list.
/* =================================================================== */

CHECK_STRINGIZE: procedure;

	declare P	type (POINTER_T);

	do P = REPLACEMENT_LIST
	repeat (P->TOKEN_POD.NEXT) while (P ^= null ());
		if P->TOKEN_POD.TYPE = PP_STRINGIZE_TOKEN then do;
			if P->TOKEN_POD.NEXT = null () then
				goto ILLEGAL_STRINGIZE;
			if P->TOKEN_POD.NEXT->TOKEN_POD.TYPE ^=
			   PP_MACRO_PARAMETER_TOKEN then
				goto ILLEGAL_STRINGIZE;
		end;
	end;
	return;

	ILLEGAL_STRINGIZE:

	call PP_ERROR_I (ERR_PP_ILLEGAL_STRINGIZE,
			 TOKEN_SPELLING (MACRO_TOKEN));
	return;

end; /* CHECK_STRINGIZE */

/* =====================================================================
/* CHECK_TOKEN_PASTE
/*
/* Check the validity of any token-paste operators in the (null terminated)
/* linked list of token-pods (pointed to by REPLACEMENT_LIST) representing
/* the replacement list of a function-like or object-like macro definition.
/* The first and last token-pods in the list are pointed to respcectively
/* by REPLACEMENT_LIST and END_REPLACEMENT_LIST respectively.  If an error
/* is found, then an appropriate message will be emitted; the the operator
/*  will NOT be deleted from the list.
/* ---------------------------------------------------------------------
/* [Excerpt] ANSI-C (X3J11/88-090), 3.8.3.3, Constraints:
/* ---------------------------------------------------------------------
/* A "##" preprocessing token shall not occur at the beginning or at the
/* end of a replacement list for either form of macro definition.
/* =================================================================== */

CHECK_TOKEN_PASTE: procedure;

	if REPLACEMENT_LIST ^= null () then do;
		if REPLACEMENT_LIST->TOKEN_POD.TYPE =
		   PP_TOKEN_PASTE_TOKEN then
			goto ILLEGAL_TOKEN_PASTE;
	end;
	if END_REPLACEMENT_LIST ^= null () then do;
		if END_REPLACEMENT_LIST->TOKEN_POD.TYPE =
		   PP_TOKEN_PASTE_TOKEN then
			goto ILLEGAL_TOKEN_PASTE;
	end;
	return;

	ILLEGAL_TOKEN_PASTE:

	call PP_ERROR_I (ERR_PP_ILLEGAL_TOKEN_PASTE,
			 TOKEN_SPELLING (MACRO_TOKEN));
	return;

end; /* CHECK_TOKEN_PASTE */

/* =====================================================================
/* PCC_STYLE_STRINGIZE_CHARIZE
/*
/* Check for PCC-style function-like macro definition, wherein macro
/* parameter substitution is intended to take place within string
/* literals or character constants.  If SW_X_STRINGIZE/SW_X_CHARIZE is
/* on then actually change the macro definition such that it will act
/* like a PCC-style macro function.
/* If SW_X_STRINGIZE_WARN/SW_X_CHARIZE_WARN is on, then emit a warning.
/* =================================================================== */

PCC_STYLE_STRINGIZE_CHARIZE: procedure (MP);
	
	declare
		MP		type (POINTER_T);
	declare
		(RP, PREV_RP)	type (POINTER_T),
		(NEW, LAST_NEW)	type (POINTER_T),
		(TP, P, Q)	type (POINTER_T),
		(BOS, EOS)	type (SHORT_T),
		PARAM_INDEX	type (SHORT_T),
		DO_STRINGIZE	type (BOOL_T),
		DO_CHARIZE	type (BOOL_T),
		WARN_STRINGIZE	type (BOOL_T),
		WARN_CHARIZE	type (BOOL_T),
		BUFFER		character
				(MAX_TOKEN_SPELLING_LENGTH+1) varying,
		BUFFER_INDEX	type (SHORT_T),
		BUFFER_SIZ	type (SHORT_T);
	declare
		SAVE_GET_NEXT_CHAR	entry returns (type (SHORT_T))
					variable,
		SAVE_PUSH_BACK_CHAR	entry (type (SHORT_T))
					variable,
		SAVE_SCAN_NEXT_CHAR	entry returns (type (SHORT_T))
					variable;

	if MP = null () then
		return;
	if (MP->MACRO_NODE.NPARAMETERS <= 0) |
	   (MP->MACRO_NODE.REPLACEMENT = null ()) then
		return;

	/* Save & switch the lexical context to lex the string */

	SAVE_SCAN_NEXT_CHAR	= SCAN_NEXT_CHAR;
	SAVE_PUSH_BACK_CHAR	= PUSH_BACK_CHAR;
	SAVE_GET_NEXT_CHAR	= GET_NEXT_CHAR;

	SCAN_NEXT_CHAR		= NEXTC_FROM_BUFFER;
	PUSH_BACK_CHAR		= BACKC_FROM_BUFFER;
	GET_NEXT_CHAR		= NEXTC_FROM_BUFFER;

	/*
	 * Go thru the function-like macro replacement list looking
	 * for strings or character constants as appropriate.
	 */

	RP = MP->MACRO_NODE.REPLACEMENT; PREV_RP = null ();

	do while (RP ^= null ());

		NEW = null (); LAST_NEW = null ();

		DO_STRINGIZE = FALSE; WARN_STRINGIZE = FALSE;
		DO_CHARIZE   = FALSE; WARN_CHARIZE   = FALSE;

		if RP->TOKEN_POD.TYPE = STRING_LITERAL_TOKEN then do;
			if SW_X_STRINGIZE      then DO_STRINGIZE   = TRUE;
			if SW_X_STRINGIZE_WARN then WARN_STRINGIZE = TRUE;
		end;
		else if RP->TOKEN_POD.TYPE = CHAR_CONSTANT_TOKEN then do;
			if SW_X_CHARIZE	       then DO_CHARIZE     = TRUE;
			if SW_X_CHARIZE_WARN   then WARN_CHARIZE   = TRUE;
		end;
		else	goto LOOP_NEXT_REPLACEMENT_TOKEN;

		BUFFER = RP->TOKEN_POD.SPELLING_PTR->
			 TOKEN_SPELLING_POD.SPELLING || byte (NEWLINE_CHAR);
		BUFFER_SIZ = length (BUFFER);
		if BUFFER_SIZ <= 0 then goto LOOP_NEXT_REPLACEMENT_TOKEN;
		BUFFER_INDEX = 1;

		/* Lex the non-empty string or character constant */

		BOS = 1; EOS = 1;

		do TP = GET_NEXT_LEXICAL_TOKEN ()
		repeat  GET_NEXT_LEXICAL_TOKEN ()
		while (TP ^= END_BUFFER_TOKEN);

			if TP->TOKEN_POD.TYPE ^= IDENTIFIER_TOKEN then do;
				call TFREET (TP);
				goto LOOP_NEXT_STRING_CHAR_TOKEN;
			end;
			PARAM_INDEX = MACRO_PARAMETER_INDEX (TP, MP);
			if PARAM_INDEX <= 0 then do;
				call TFREET (TP);
				goto LOOP_NEXT_STRING_CHAR_TOKEN;
			end;

			/*
			 * Here, we've found a parameter identifier within
			 * a string literal or character constant.  Give
			 * warning and/or change definition as appropriate.
			 */

			if WARN_STRINGIZE then do;
				if DO_STRINGIZE then
					call PP_ERROR_I (ERR_PCC_DO_STRINGIZE,
							 MACRO_NAME(MP));
				else	call PP_ERROR_I (ERR_PCC_WARN_STRINGIZE,
							 MACRO_NAME(MP));
				WARN_STRINGIZE = FALSE;  /* once */
			end;
			else if WARN_CHARIZE then do;
				if DO_CHARIZE then
					call PP_ERROR_I (ERR_PCC_DO_CHARIZE,
							 MACRO_NAME(MP));
				else	call PP_ERROR_I (ERR_PCC_WARN_CHARIZE,
							 MACRO_NAME(MP));
				WARN_CHARIZE = FALSE;    /* once */
			end;

			if ^DO_STRINGIZE & ^DO_CHARIZE then
				goto DONE_PCC_STYLE_STRINGIZE_CHARIZE;

			/*
			 * Here, we actually want to change the definition.
			 * Create a new stringize/charize token, change the
			 * identifier token to be PP_MACRO_PARAMETER_TOKEN,
			 * and create a new string-literal/character-constant
			 * token for the initial part which was skipped.
			 */

			P = TALLOC ();
			if DO_STRINGIZE then
				P->TOKEN_POD.TYPE = PP_STRINGIZE_TOKEN;
			else	P->TOKEN_POD.TYPE = PP_CHARIZE_TOKEN;
			P->TOKEN_POD.NEXT = TP;

			TP->TOKEN_POD.TYPE  = PP_MACRO_PARAMETER_TOKEN;
			TP->TOKEN_POD.VALUE = PARAM_INDEX;
			LAST_NEW = TP;

			if (EOS - BOS) > 0 then do;
				Q = TALLOC ();
				Q->TOKEN_POD.TYPE = RP->TOKEN_POD.TYPE;
				Q->TOKEN_POD.SPELLING_PTR =
					SALLOC (EOS - BOS + 1);
				Q->TOKEN_POD.SPELLING_PTR->
				TOKEN_SPELLING_POD.SPELLING =
					substr (RP->TOKEN_POD.SPELLING_PTR->
					        TOKEN_SPELLING_POD.SPELLING,
					        BOS, EOS - BOS);
				Q->TOKEN_POD.LINE = RP->TOKEN_POD.LINE;
				Q->TOKEN_POD.NEXT = P;
				NEW = Q;
			end;
			else	NEW = P;

			BOS = BUFFER_INDEX;

			LOOP_NEXT_STRING_CHAR_TOKEN:

			EOS = BUFFER_INDEX;
		end;

		/*
		 * Create a new string literal or character
		 * constant from any left over.
		 */

		if (EOS - BOS) > 0 then do;
			Q = TALLOC ();
			Q->TOKEN_POD.TYPE = RP->TOKEN_POD.TYPE;
			Q->TOKEN_POD.SPELLING_PTR = SALLOC (EOS-BOS);
			Q->TOKEN_POD.SPELLING_PTR->
			TOKEN_SPELLING_POD.SPELLING =
				substr (RP->TOKEN_POD.SPELLING_PTR->
				        TOKEN_SPELLING_POD.SPELLING,
				        BOS, EOS - BOS);
			Q->TOKEN_POD.LINE = RP->TOKEN_POD.LINE;
			Q->TOKEN_POD.NEXT = null ();
			if LAST_NEW = null () then
				NEW = Q;
			else	LAST_NEW->TOKEN_POD.NEXT = Q;
			LAST_NEW = Q;
		end;

		LOOP_NEXT_REPLACEMENT_TOKEN:

		if NEW ^= null () then do;
			if PREV_RP ^= null () then
				PREV_RP->TOKEN_POD.NEXT = NEW;
			else	MP->MACRO_NODE.REPLACEMENT = NEW;
			LAST_NEW->TOKEN_POD.NEXT = RP->TOKEN_POD.NEXT;
			PREV_RP = LAST_NEW;
			call TFREET (RP);
		end;
		else	PREV_RP = RP;
		RP = PREV_RP->TOKEN_POD.NEXT;
	end;

	DONE_PCC_STYLE_STRINGIZE_CHARIZE:

	SCAN_NEXT_CHAR	= SAVE_SCAN_NEXT_CHAR;
	PUSH_BACK_CHAR	= SAVE_PUSH_BACK_CHAR;
	GET_NEXT_CHAR	= SAVE_GET_NEXT_CHAR;

	return;

	/* =============================================================
	/* MACRO_PARAMETER_INDEX
	/*
	/* If the token pointed to by TP is an identifier token which
	/* corresponds to a formal macro parameter identifier in the
	/* function-like macro pointed to by MP, then return the
	/* (one-indexed) position of the parameter.  Else, return -1.
	/* =========================================================== */

	MACRO_PARAMETER_INDEX: procedure (TP, MP) returns (type (SHORT_T));

		declare (TP, MP)	type (POINTER_T);
		declare I		type (SHORT_T);

		if (TP = null ())  | (MP = null ()) then
			return (FALSE);
		MACRO_PARAMETER_COUNT = MP->MACRO_NODE.NPARAMETERS;
		do I = 1 to MACRO_PARAMETER_COUNT;
			if MP->MACRO_NODE.PARAMETER->MACRO_PARAMETER_LIST(I) =
			   TP->TOKEN_POD.SPELLING_NODE then
				return (I);
		end;
		return (-1);

	end MACRO_PARAMETER_INDEX;

	/* =============================================================
	/* NEXTC_FROM_BUFFER
	/*
	/* Return the next character from our local character buffer.
	/* Return a dummy (token-separation) token instead of a
	/* double-quote or single-quote so that we don't miss out on
	/* detecting identifers because they looked like they were
	/* within a character constant or a string literal.
	/* =========================================================== */

	NEXTC_FROM_BUFFER: procedure returns (type (SHORT_T));

		declare C	type (SHORT_T);

		if BUFFER_INDEX > BUFFER_SIZ then
			return (END_BUFFER_CHAR);
		C = rank (substr (BUFFER, BUFFER_INDEX, 1));
		BUFFER_INDEX = BUFFER_INDEX + 1;
		if (C = SQUOTE_CHAR) | (C = DQUOTE_CHAR) then
			return (NEWLINE_CHAR);
		else	return (C);

	end NEXTC_FROM_BUFFER;

	/* =============================================================
	/* BACKC_FROM_BUFFER
	/*
	/* Push back a character onto our local character buffer.
	/* =========================================================== */

	BACKC_FROM_BUFFER: procedure (C);

		declare C type (SHORT_T);

		if BUFFER_INDEX > 1 then do;
			BUFFER_INDEX = BUFFER_INDEX - 1;
			substr (BUFFER, BUFFER_INDEX, 1) = byte (C);
		end;

	end BACKC_FROM_BUFFER;

end; /* PCC_STYLE_STRINGIZE_CHARIZE */

end; /* READ_MACRO_DEFINITION */

/* =====================================================================
/* HANDLE_IDENT_DIRECTIVE
/* =================================================================== */

HANDLE_IDENT_DIRECTIVE: procedure (IDENT_TOKEN_PTR)
			returns   (type (POINTER_T)) internal;
	declare
		IDENT_TOKEN_PTR	type (POINTER_T);
	declare
		NAME				character (32) varying,
		(TP, P)				type (POINTER_T);
	declare
		DS_NAME				type (NID_T),
		DS_ATTRIBUTES			type (LONG_T),
		DS_ALIGNMENT			type (LONG_T),
		DS_ADDRESS			type (LONG_T);
	declare
		COMMENT_DS_NAME			type (NID_T)
						static internal
						initial (NULL_ID),
		K				type (LONG_T)
						static internal initial (1);

	if ^SW_IGNORE_IDENT then do;
		if SW_IMPLICIT_PRAGMA_DATA_SECTION then do;
			call GET_LAST_PRAGMA_DATA_SECTION
			     (DS_NAME,
			      DS_ATTRIBUTES,
			      DS_ALIGNMENT,
			      DS_ADDRESS);
			if COMMENT_DS_NAME = NULL_ID then do;
				COMMENT_DS_NAME = STORE_TOKEN
						  (IDENTIFIER_TOKEN,
						   '.comment');
			end;
			call PUT_PRAGMA_DATA_SECTION_TOKEN (COMMENT_DS_NAME,
							    0, 0, 0);
		end;
		TP = TALLOC ();
		TP->TOKEN_POD.TYPE = KW_STATIC_TOKEN;
		call TPUT (TP);
		TP = TALLOC ();
		TP->TOKEN_POD.TYPE = KW_CHAR_TOKEN;
		call TPUT (TP);
		TP = TALLOC ();
		TP->TOKEN_POD.TYPE = STAR_TOKEN;
		call TPUT (TP);
		TP = TALLOC ();
		NAME = '____lpi_ident_' || trim (char (K));
		K = K + 1;
		TP->TOKEN_POD.TYPE = IDENTIFIER_TOKEN;
		TP->TOKEN_POD.SPELLING_NODE = STORE_TOKEN
					      (IDENTIFIER_TOKEN, NAME);
		call TPUT (TP);
		TP = TALLOC ();
		TP->TOKEN_POD.TYPE = EQUAL_TOKEN;
		call TPUT (TP);
		IDENT_TOKEN_PTR->TOKEN_POD.LINE = 0;
		call TPUT (IDENT_TOKEN_PTR);
	end;
	do while (TRUE);
		P = GET_NEXT_EXPANDED_TOKEN ();
		if P = END_PP_DIRECTIVE_TOKEN then
			leave;
		else if P->TOKEN_POD.TYPE ^= STRING_LITERAL_TOKEN then
			leave;
		else if ^SW_IGNORE_IDENT then
			call TPUT (P);
	end;

	if ^SW_IGNORE_IDENT then do;
		TP = TALLOC ();
		TP->TOKEN_POD.TYPE = SEMICOLON_TOKEN;
		call TPUT (TP);
		if SW_IMPLICIT_PRAGMA_DATA_SECTION then do;
			call PUT_PRAGMA_DATA_SECTION_TOKEN
			     (DS_NAME, DS_ATTRIBUTES, DS_ALIGNMENT, DS_ADDRESS);
		end;
	end;

	return (P);

end HANDLE_IDENT_DIRECTIVE;

/* =====================================================================
/* IGNORE_PP_DIRECTIVE
/*
/* Skip past the rest of this preprocessing directive line.
/* =================================================================== */

IGNORE_PP_DIRECTIVE: procedure;

	declare C	type (SHORT_T);

	do C = SSCANP () repeat (SSCANP ()) while (TRUE);
		if C = END_PP_DIRECTIVE_CHAR then
			return;
		if C = EOF_IN_DIRECTIVE_CHAR then do;
			call HANDLE_END_OF_FILE (C);
			return;
		end;
	end;

end; /* IGNORE_PP_DIRECTIVE */

/* =====================================================================
/* READ_ASSERT_DEFINITION
/* =================================================================== */

READ_ASSERT_DEFINITION: procedure (ASSERT_TOKEN_PTR) internal;

	declare
		ASSERT_TOKEN_PTR	type (POINTER_T);
	declare
		TP			type (POINTER_T),
		PAREN_LEVEL		type (SHORT_T);

	TP = GET_NEXT_LEXICAL_TOKEN ();
	if TP = END_PP_DIRECTIVE_TOKEN then do;
		call DEFINE_ASSERT
		     (ASSERT_TOKEN_PTR->TOKEN_POD.SPELLING, null ());
		return;
	end;
	else if TP->TOKEN_POD.TYPE ^= LPAREN_TOKEN then do;
		call PP_ERROR_I (ERR_PP_ASSERT_SYNTAX, 'assert');
		call IGNORE_PP_DIRECTIVE ();
		return;
	end;

	TP = COLLECT_ASSERT_TOKENS (GET_NEXT_LEXICAL_TOKEN ());

	if TP = null () then
		call PP_ERROR (ERR_PP_ASSERT_SYNTAX);
	else	call DEFINE_ASSERT
		     (ASSERT_TOKEN_PTR->TOKEN_POD.SPELLING, TP);

end; /* READ_ASSERT_DEFINITION */

/* =====================================================================
/* READ_UNASSERT_DIRECTIVE
/* =================================================================== */

READ_UNASSERT_DIRECTIVE: procedure (UNASSERT_TOKEN_PTR) internal;

	declare
		UNASSERT_TOKEN_PTR	type (POINTER_T);

	TP = GET_NEXT_LEXICAL_TOKEN ();
	if TP = END_PP_DIRECTIVE_TOKEN then do;
		call UNDEF_ASSERT
		     (UNASSERT_TOKEN_PTR->TOKEN_POD.SPELLING, null ());
		return;
	end;
	else if TP->TOKEN_POD.TYPE ^= LPAREN_TOKEN then do;
		call PP_ERROR_I (ERR_PP_ASSERT_SYNTAX, 'unassert');
		call IGNORE_PP_DIRECTIVE ();
		return;
	end;

	TP = COLLECT_ASSERT_TOKENS (GET_NEXT_LEXICAL_TOKEN ());

	if TP = null () then
		call PP_ERROR_I (ERR_PP_ASSERT_SYNTAX, 'unassert');
	else	call UNDEF_ASSERT
		     (UNASSERT_TOKEN_PTR->TOKEN_POD.SPELLING, TP);

end; /* READ_UNASSERT_DIRECTIVE */

end; /* READ_PP_DIRECTIVE */

/* =====================================================================
/* HANDLE_END_OF_FILE
/*
/* Given an end-of-file character (i.e. one of EOF_CHAR, EOF_IN_LINE_CHAR,
/* EOF_IN_COMMENT_CHAR, EOF_IN_DIRECTIVE_CHAR, EOF_IN_ARGUMENT_CHAR,
/* EOF_IN_SKIP_GROUP_CHAR, or ERROR_CHAR), decide what to do.  First emit
/* an appropriate error message if applicable.  If this is the end of an
/* included file, then close (i.e. pop) it, send out end end-of-include
/* token-pod, adjust the TOTAL_LINES count, and return.  Otherwise, if
/* this is the end of the main file, then send out and end-of-file token
/* pod, adjust the TOTAL_LINES count, and terminate preprocessing by
/* doing a non-local-goto to END_OF_MAIN_FILE.
/* =================================================================== */

HANDLE_END_OF_FILE: procedure (C);

	declare
		C	type (SHORT_T);
	declare
		TP	type (POINTER_T),
		S	character (2048) varying;

	/* EOF in funny place ? */

	if C = EOF_IN_LINE_CHAR then do;
		if SW_WARN_EOF_IN_LINE then
			call SCAN_ERROR (ERR_PP_EOF_IN_LINE);
	end;
	else if C = EOF_IN_COMMENT_CHAR then
		call SCAN_ERROR (ERR_PP_EOF_IN_COMMENT);
	else if C = EOF_IN_DIRECTIVE_CHAR then
		call SCAN_ERROR (ERR_PP_EOF_IN_DIRECTIVE);
	else if C = ERROR_CHAR then
		call SCAN_ERROR (ERR_PP_READ);

	/* Get the eof token */

	TP = GET_EOF_TOKEN ();

	/* Update the total number of lines */

	TOTAL_LINES = TOTAL_LINES + TP->TOKEN_POD.LINE;

	/* Is this file skip-able in the future ? */

	if CURRENT_SOURCE.ENCLOSING_MACRO_FLAG <= EOF_CHAR then
		call RECORD_SKIPABLE_FILE (FALSE);

	/* End C-header mode if necesary */

	call CHECK_FOR_END_OF_C_HEADER_MODE ();

	/* End-of-include-file ? */

	if XSCLOSE () > 0 then do;
		TP->TOKEN_POD.TYPE = EOF_INCLUDE_TOKEN;
		call TPUT (TP);
                if PP_MAX_TOKENS = 1 then do;
			/*
			/* One token at a time includes
			/* special end-of-include file tokens.
			/**/
                        goto END_OF_INCLUDE_FILE;  /* non-local! */
		end;
		return;
	end;

	/* Else, end-of-main-file; check for funny places */

	else do;

		/* EOF within function-like macro argument list ? */

		if C = EOF_IN_ARGUMENT_CHAR then do;
			call SCAN_ERROR_I
			     (ERR_PP_EOF_IN_MACRO_CALL,
			      MACRO_NAME (CURRENT_MACRO_FUNCTION));
		end;

		/* EOF within conditionally excluded (skipped) group ? */

		else if C = EOF_IN_SKIP_GROUP_CHAR then do;
			S = 'from line ' || trim (char (EXCLUDE_FROM_LINE)) ||
			    ' in "' || EXCLUDE_FROM_FILE->STR || '"';
			call SCAN_ERROR_I (ERR_PP_EOF_IN_EXCLUDED_GROUP, S);
		end;

		/* EOF within conditionally included group (no #endif) ? */

		else if GROUP_LEVEL > 0 then
			call PP_ERROR (ERR_PP_NO_ENDIF);

		/* If we were looking ahead, send out the current token */

		if TOKEN_AT_LOOK_AHEAD ^= null () then
			call TPUT (TOKEN_AT_LOOK_AHEAD);

		/* Send out the EOF token-pod, and terminate! */

		call TPUT (TP);

		goto END_OF_MAIN_FILE;  /* non-local ! */
	end;

end; /* HANDLE_END_OF_FILE */

/***********************************************************************
/* Macro invocation and expansion stacks, data, and procedures.
/***********************************************************************/

declare

MACRO_TOKEN_STACK		(1 : HB_MACRO_STACK) type (POINTER_T)
				static internal
				initial ((HB_MACRO_STACK)(null ())),

MACRO_NODE_STACK		(1 : HB_MACRO_STACK) type (POINTER_T)
				static internal
				initial ((HB_MACRO_STACK)(null ())),

MACRO_DISPLAY_STACK		(1 : HB_MACRO_STACK) type (SHORT_T)
				static internal
				initial ((HB_MACRO_STACK)(0)),

MACRO_STACK_TOP			type (SHORT_T)
				static internal
				initial (0),

ARGUMENT_STACK			(1 : MAX_MACRO_ARGUMENTS) type (POINTER_T)
				static internal
				initial ((MAX_MACRO_ARGUMENTS)(null ())),

ARGUMENT_STACK_TOP		type (SHORT_T)
				static internal
				initial (0),

NOTIFY_END_MACRO_ARGUMENT_TOKEN	type (BOOL_T)
				static internal
				initial (FALSE);

/* =====================================================================
/* GET_NEXT_MACRO_TOKEN
/*
/* Return a pointer to the next token-pod from the macro invocation stack
/* (or directly from the source if the end of the macro expansion has been
/* reached).  The token-paste and stringize operations are performed here.
/*
/* -> The dummy token pointer END_MACRO_ARGUMENT_TOKEN may be returned
/* to indicate the end of the expansion of a function-like macro argument
/* if the current lexical context is within the expansion of a macro
/* argument list; i.e. when NOTIFY_END_MACRO_ARGUMENT_TOKEN is TRUE.
/*
/* If the end of the macro replacement list has been encountered (i.e.
/* the macro expansion is done, i.e. the macro stack is empty, indicated
/* by a null () return value from GET_MACRO_TOKEN), then we reset
/* GET_NEXT_PP_TOKEN to GET_NEXT_LEXICAL_TOKEN and return a call
/* to GET_NEXT_LEXICAL_TOKEN.
/*
/* -> The dummy token pointer END_PP_DIRECTIVE_TOKEN may be returned
/* to indicate that the end of preprocessing directive line has been
/* encountered if the current lexical context is within a preprocessing
/* directive; but only if GET_NEXT_PP_TOKEN is GET_NEXT_LEXICAL_TOKEN.
/*
/* -> The dummy token pointer WHITE_SPACE_TOKEN may be returned to
/* indicate that white-space has been encountered if the current
/* lexical context is within a macro definition preprocessing
/* directive or within the expansion of a macro argument;
/* but only if GET_NEXT_PP_TOKEN is GET_NEXT_LEXICAL_TOKEN.
/*
/* N.B. This routine can be a bit tricky; careful when making changes!
/* =================================================================== */

GET_NEXT_MACRO_TOKEN: procedure returns (type (POINTER_T));

	declare
		length		builtin;
	declare
		(TP, NEW)	type (POINTER_T),
		(P, Q)		type (POINTER_T),
		T		type (SHORT_T),
		PRECEDING_SPACE	type (BOOL_T);

	/* ---------------------------------------------------------
	 * Get the next macro token from the macro invocation stack.
	 * ------------------------------------------------------- */

	BEGIN_NEXT_MACRO_TOKEN:

	TP = GET_MACRO_TOKEN ();

	/* ----------------------------------------------------------
	 * See if this is the end of the (original) macro invocation.
	 * -------------------------------------------------------- */

	if TP = null () then do;
		GET_NEXT_PP_TOKEN = GET_NEXT_LEXICAL_TOKEN;
		return (GET_NEXT_LEXICAL_TOKEN ());
	end;

	/* --------------------------------------------------------------
	 * Look ahead to see if we have a token-paste operator following
	 * this token.  If so, and this token is END_MACRO_ARGUMENT_TOKEN,
	 * then a null macro argument was given as the first argument of
	 * a token-paste (undefined behavior, but we'll handle it).
	 * ------------------------------------------------------------ */

	if TP = END_MACRO_ARGUMENT_TOKEN then
		goto PEEK_TOKEN_PASTE_OPERATOR;
	if TP->TOKEN_POD.TYPE ^= PP_MACRO_PARAMETER_TOKEN then do;
		PEEK_TOKEN_PASTE_OPERATOR:
		P = GET_TOKEN_PASTE_OPERAND ();
		if P ^= null () then do;
			NEW = PASTE_TOKENS (TP, P);
			if NEW ^= null () then
				call PUSH_BACK_TOKEN (NEW);
			goto BEGIN_NEXT_MACRO_TOKEN;
		end;
	end;

	/* --------------------------------------------------------
	 * See if this is the end of a macro argument expansion.
	 * Only if the the caller is collecting/expanding arguments
	 * do we want to send out a notification of this.
	 * ------------------------------------------------------ */

	if TP = END_MACRO_ARGUMENT_TOKEN then do;
		if NOTIFY_END_MACRO_ARGUMENT_TOKEN then
			return (TP);
		else	goto BEGIN_NEXT_MACRO_TOKEN;
	end;

	/* -----------------------------------------------
	 * Here, we have a legitimate token; get its type.
	 * -------------------------------------------- */

	T = TP->TOKEN_POD.TYPE;

	/* ---------------------------------------
	 * See if this is a macro parameter token.
	 * -------------------------------------- */

	if T = PP_MACRO_PARAMETER_TOKEN then
		goto HAVE_NEXT_MACRO_TOKEN;

	/* ------------------------------------------------
	 * See if we have a stringize or charize operator.
	 * ---------------------------------------------- */

	if (T = PP_STRINGIZE_TOKEN) | (T = PP_CHARIZE_TOKEN) then do;
		P = GET_STRINGIZE_CHARIZE_OPERAND ();
		if P ^= null () then do;
			call PUSH_BACK_TOKEN (STRINGIZE_CHARIZE_TOKENS (P, T));
			goto BEGIN_NEXT_MACRO_TOKEN;
		end;
	end;

	/* ---------------------------------------------------------------
	 * Here, we have a token TP of type T; allocate and return a copy.
	 * ------------------------------------------------------------- */

	HAVE_NEXT_MACRO_TOKEN:

	NEW = TALLOC ();
	NEW->TOKEN_POD.TYPE = T;
	if (T < LB_SPELLING_TOKEN) | (T > HB_SPELLING_TOKEN) then
		NEW->TOKEN_POD.VALUE = TP->TOKEN_POD.VALUE;
	else if T = IDENTIFIER_TOKEN then
		NEW->TOKEN_POD.SPELLING = TP->TOKEN_POD.SPELLING;
	else do;
		NEW->TOKEN_POD.SPELLING_PTR =
		    SALLOC (length
			    (TP->TOKEN_POD.SPELLING_PTR->
			     TOKEN_SPELLING_POD.SPELLING) + 1);
		NEW->TOKEN_POD.SPELLING_PTR->TOKEN_SPELLING_POD.SPELLING =
		    TP->TOKEN_POD.SPELLING_PTR->TOKEN_SPELLING_POD.SPELLING;
	end;
	if TP->TOKEN_POD.LINE < 0 then
		NEW->TOKEN_POD.LINE = -CURRENT_SOURCE.PHYSICAL_LINE;
	else	NEW->TOKEN_POD.LINE =  CURRENT_SOURCE.PHYSICAL_LINE;

	DONE_NEXT_MACRO_TOKEN:

	return (NEW);

/* =====================================================================
/* GET_MACRO_TOKEN
/*
/* Remove and return a pointer to the next token on the macro invocation
/* stack.  If we are at the end of a macro argument invocation (expansion),
/* then return END_MACRO_ARGUMENT_TOKEN.  If there are no more tokens
/* on the macro expansion stack then return null.  If we have completely
/* finished expanding a macro function, then any arguments will be
/* popped and freed from the macro argument stack.
/* =================================================================== */

GET_MACRO_TOKEN: procedure returns (type (POINTER_T));

	declare (P, MP)	type (POINTER_T);

	do while (MACRO_STACK_TOP >= 1);

		/* ----------------------------------------------------
		 * See if there is still at least one token left in the
		 * token list on the top of the macro invocation stack.
		 * This list represents either a macro replacement list
		 * or function-like macro argument list.  If there is a
		 * token, then simply return a pointer to it.
		 * -------------------------------------------------- */

		if MACRO_TOKEN_STACK (MACRO_STACK_TOP) ^= null () then do;
			P = MACRO_TOKEN_STACK (MACRO_STACK_TOP);
			MACRO_TOKEN_STACK (MACRO_STACK_TOP) =
				P->TOKEN_POD.NEXT;
			return (P);
		end;

		/* ---------------------------------------------------------
		 * Here, we've either reached the end of a macro replacement
		 * list or the end of a function-ike macro argument list.
		 * ------------------------------------------------------- */

		MP = MACRO_NODE_STACK (MACRO_STACK_TOP);

		/* -------------------------------------------------------
		 * If we reached the end of a function-like macro argument
		 * list, then return END_MACRO_ARGUMENT_TOKEN.  This is to
		 * help satisfy the requirement that each function-like
		 * macro argument is to be completely macro replaced AS IF
		 * it formed the rest of the source file.
		 * -------------------------------------------------------
		 * [See] ANSI-C (X3J11/88-090), Section 3.8.3.1.
		 * ----------------------------------------------------- */

		if MP = null () then do;
			MACRO_STACK_TOP = MACRO_STACK_TOP - 1;
			return (END_MACRO_ARGUMENT_TOKEN);
		end;

		/* ------------------------------------------------------
		 * If we reached the end of a macro replacement list and
		 * it was a function-like macro, then free any associated
		 * macro argument list (i.e. on the ARGUMENT_STACK).
		 * ---------------------------------------------------- */

		else if MP->MACRO_NODE.NPARAMETERS > 0 then
			call FREE_MACRO_ARGUMENT_LIST (MACRO_STACK_TOP);

		/* ---------------------------------------------------------
		 * Pop this macro invocation off the macro invocation stack.
		 * ------------------------------------------------------- */

		MACRO_STACK_TOP = MACRO_STACK_TOP - 1;

		MP->MACRO_NODE.INVOCATION_COUNT
			= MP->MACRO_NODE.INVOCATION_COUNT - 1;
	end;

	/* ------------------------------------------------
	 * Here, there are no more macro tokens to process.
	 * ---------------------------------------------- */

	return (null ());

/* =====================================================================
/* FREE_MACRO_ARGUMENT_LIST
/*
/* Free all of the arguments on the macro argument stack associated
/* with the given macro.
/* =================================================================== */

FREE_MACRO_ARGUMENT_LIST: procedure (MACRO_INDEX);

	declare
		MACRO_INDEX	type (SHORT_T);
	declare
		MP		type (POINTER_T),
		LOW_INDEX	type (SHORT_T),
		HIGH_INDEX	type (SHORT_T),
		(I, T)		type (SHORT_T),
		(P, Q)		type (POINTER_T);

	if MACRO_NODE_STACK(MACRO_INDEX) = null () then
		return;
	if MACRO_NODE_STACK(MACRO_INDEX)->MACRO_NODE.NPARAMETERS <= 0 then
		return;
	if MACRO_DISPLAY_STACK(MACRO_INDEX) <= 0 then
		return;

	LOW_INDEX = MACRO_DISPLAY_STACK(MACRO_INDEX);
	HIGH_INDEX = LOW_INDEX +
		     MACRO_NODE_STACK(MACRO_INDEX)->MACRO_NODE.NPARAMETERS - 1;

	do I = LOW_INDEX to HIGH_INDEX;
		do P = ARGUMENT_STACK(I) while (P ^= null ());
			Q = P; P = P->TOKEN_POD.NEXT;
			T = Q->TOKEN_POD.TYPE;
			call TFREET (Q);
			ARGUMENT_STACK(I) = null ();
		end;
	end;

	if ARGUMENT_STACK_TOP <= HIGH_INDEX then
		ARGUMENT_STACK_TOP = LOW_INDEX - 1;

end; /* FREE_MACRO_ARGUMENT_LIST */

end; /* GET_MACRO_TOKEN */

/* =====================================================================
/* GET_TOKEN_PASTE_OPERAND
/*
/* Peek ahead on the macro token stack to see if a token-paste operation
/* is coming up; i.e. see if the next token is a token-paste token (##)
/* and the token after that is a valid candidate as the second operand
/* of a token-paste operation (the first operand was presumably read by
/* the caller).  If so, skip past the token-paste token and the second
/* operand, and return (a pointer to) the second operand (substituting
/* the appropriate argument list if the second operand is a parameter).
/* =================================================================== */

GET_TOKEN_PASTE_OPERAND: procedure returns (type (POINTER_T));

	declare
		(TP, P)	type (POINTER_T),
		I	type (SHORT_T);

	do I = MACRO_STACK_TOP to 1 by -1;
		TP = MACRO_TOKEN_STACK(I);
		if TP ^= null () then do;
			if (TP->TOKEN_POD.TYPE = PP_TOKEN_PASTE_TOKEN) &
			   (TP->TOKEN_POD.NEXT ^= null ()) &
			   (MACRO_NODE_STACK(I) ^= null ()) then do;
				P = TP->TOKEN_POD.NEXT;
				MACRO_TOKEN_STACK(I) = P->TOKEN_POD.NEXT;
				MACRO_STACK_TOP = I;
				if (P->TOKEN_POD.TYPE =
				    PP_MACRO_PARAMETER_TOKEN) then do;
					call PUSH_MACRO_ARGUMENT_INVOCATION (P);
					P = GET_MACRO_TOKEN ();
				end;
				return (P);
			end;
			else	return (null ());
		end;
	end;
	return (null ());

end; /* GET_TOKEN_PASTE_OPERAND */

/* =====================================================================
/* GET_STRINGIZE_CHARIZE_OPERAND
/*
/* Return a pointer to the next token on the macro invocation stack
/* WITHIN the current macro invocation (or macro argument invocation).
/* If there are no more then return null.
/* =================================================================== */

GET_STRINGIZE_CHARIZE_OPERAND: procedure returns (type (POINTER_T));

	declare P	type (POINTER_T);

	P = MACRO_TOKEN_STACK(MACRO_STACK_TOP);
	if P ^= null () then do;
		if P->TOKEN_POD.TYPE = PP_MACRO_PARAMETER_TOKEN then do;
			MACRO_TOKEN_STACK(MACRO_STACK_TOP) =
				P->TOKEN_POD.NEXT;
			return (P);
		end;
	end;
	return (null ());

end; /* GET_STRINGIZE_CHARIZE_OPERAND */

/* =====================================================================
/* PASTE_TOKENS
/*
/* Given pointers to two (TOKEN_POD) preprocessing token-pods, create
/* and return a pointer to one token-pod which represents the tokenized
/* concatenation of the two tokens.  If an error is encountered then an
/* appropriate message will be emitted and a null pointer returned; if
/* an empty token is generated, a null pointer will also be returned.
/* ---------------------------------------------------------------------
/* [Excerpt] ANSI-C (X3J11/88-159), 3.8.3.3, Token-pasting Semantics:
/* ---------------------------------------------------------------------
/* If the result [of a token-pasting (##) operation] is not a valid
/* preprocessing token, the behavior is undefined.  The resulting token
/* is available for further macro replacement. The order of evaluation
/* of ## operators is unspecified.
/* =================================================================== */

PASTE_TOKENS: procedure (FIRST, SECOND) returns (type (POINTER_T));

	declare
		(FIRST, SECOND)	type (POINTER_T);
	declare
		BUFFER		character (MAX_TOKEN_SPELLING_LENGTH*2) varying,
		BUFFER_INDEX	type (SHORT_T),
		BUFFER_SIZ	type (SHORT_T);
	declare
		I		type (SHORT_T),
		P		type (POINTER_T);
	declare
		length		builtin;
	declare
		SAVE_GET_NEXT_CHAR	entry returns (type (SHORT_T))
					variable,
		SAVE_PUSH_BACK_CHAR	entry (type (SHORT_T))
					variable,
		SAVE_SCAN_NEXT_CHAR	entry returns (type (SHORT_T))
					variable;

	/* Get the spelling of the first token into a local buffer */

	if (FIRST ^= END_MACRO_ARGUMENT_TOKEN) & (FIRST ^= null ()) then
		BUFFER = TOKEN_SPELLING (FIRST);
	else	BUFFER = '';

	/* Concatenate the second token onto the end of the first */

	if (SECOND ^= END_MACRO_ARGUMENT_TOKEN) & (SECOND ^= null ()) then do;
		BUFFER = BUFFER || TOKEN_SPELLING (SECOND);
		if length (BUFFER) > MAX_TOKEN_SPELLING_LENGTH then do;
			call PP_ERROR_I (ERR_PP_LONG_TOKEN_PASTE,
					 substr (BUFFER, 1, 14) || '...');
			BUFFER = substr (BUFFER, 1, MAX_TOKEN_SPELLING_LENGTH);
		end;
	end;

	BUFFER = BUFFER || byte (NEWLINE_CHAR);
	BUFFER_SIZ = length (BUFFER);
	if BUFFER_SIZ <= 1 then return (null ());  /* null token */
	BUFFER_INDEX = 1;

	/* Save & switch the lexical context & tokenize (lex) the new string */

	SAVE_SCAN_NEXT_CHAR	= SCAN_NEXT_CHAR;
	SAVE_PUSH_BACK_CHAR	= PUSH_BACK_CHAR;
	SAVE_GET_NEXT_CHAR	= GET_NEXT_CHAR;

	SCAN_NEXT_CHAR		= NEXTC_FROM_BUFFER;
	PUSH_BACK_CHAR		= BACKC_FROM_BUFFER;
	GET_NEXT_CHAR		= NEXTC_FROM_BUFFER;

	P = GET_NEXT_LEXICAL_TOKEN ();

	/* Check that only one preprocessing token is produced */

	if BUFFER_INDEX < BUFFER_SIZ then do;
		BUFFER = TOKEN_SPELLING (FIRST);
		BUFFER = BUFFER || TOKEN_SPELLING (SECOND);
		call PP_ERROR_I (ERR_PP_TOKEN_PASTE_RESULT, BUFFER);
		P = null ();
	end;
	
	/* Restore the lexical context and return the resultant token */

	GET_NEXT_CHAR		= SAVE_GET_NEXT_CHAR;
	PUSH_BACK_CHAR		= SAVE_PUSH_BACK_CHAR;
	SCAN_NEXT_CHAR		= SAVE_SCAN_NEXT_CHAR;

	return (P);

	/* =============================================================
	** NEXTC_FROM_BUFFER
	**
	** Return the next character from our local character buffer.
	** =========================================================== */

	NEXTC_FROM_BUFFER: procedure returns (type (SHORT_T));

		declare C type (SHORT_T);

		if BUFFER_INDEX > BUFFER_SIZ then
			return (END_BUFFER_CHAR);
		C = rank (substr (BUFFER, BUFFER_INDEX, 1));
		BUFFER_INDEX = BUFFER_INDEX + 1;
		return (C);

	end NEXTC_FROM_BUFFER;

	/* =============================================================
	** BACKC_FROM_BUFFER
	**
	** Push back a character onto our local character buffer.
	** =========================================================== */

	BACKC_FROM_BUFFER: procedure (C);

		declare C type (SHORT_T);

		if BUFFER_INDEX > 1 then do;
			BUFFER_INDEX = BUFFER_INDEX - 1;
			substr (BUFFER, BUFFER_INDEX, 1) = byte (C);
		end;

	end BACKC_FROM_BUFFER;

end; /* PASTE_TOKENS */

/* =====================================================================
/* STRINGIZE_CHARIZE_TOKENS
/*
/* Given a pointer to a (TOKEN_POD) token-pod which is either a macro
/* parameter token (i.e.  of type PP_MACRO_PARAMETER_TOKEN) which points
/* to a (null terminated) linked list of token-pods representing the
/* actual argument of a function-like macro invocation, or is simply
/* the first token-pod on a (null terminated) linked list of token-pods,
/* create and return a pointer to a new token-pod for a string literal
/* (if WHICH is PP_STRINGIZE_TOKEN) or for a character constant (if
/* WHICH is PP_CHARIZE_TOKEN) representing the "stringization" or
/* "charization" of the list of tokens.  The latter (charization)
/* is not an ANSI C feature, but our extension (see PCC_STYLE_...).
/*
/* If the token-pod list is a null list (i.e. a null pointer is specified),
/* then the the string literal or character constant created will simply
/* represent an empty string literal ("") or character constant ('').
/*
/* If an error is encountered (the only error that can happen is that
/* the string literal or character constant is too long) then an
/* appropriate message will be emitted and a pointer to some incompletely
/* or incorrectly expanded string literal token is returned.
/* ---------------------------------------------------------------------
/* [See] ANSI-C (X3J11/88-159), 3.8.3.2, Stringizing Semantics:
/* =================================================================== */

STRINGIZE_CHARIZE_TOKENS: procedure (TP, WHICH) returns (type (POINTER_T));

	declare
		TP	type (POINTER_T),
		WHICH	type (SHORT_T);
	declare
		LIST	type (POINTER_T),
		T	type (SHORT_T),
		I	type (SHORT_T),
		C	character (1),
		P	type (POINTER_T),
		S	character (MAX_TOKEN_SPELLING_LENGTH) varying,
		INDEX	type (SHORT_T),
		BUFFER	character (MAX_TOKEN_SPELLING_LENGTH);

	if TP = null () then
		LIST = TP;
	else if TP->TOKEN_POD.TYPE = PP_MACRO_PARAMETER_TOKEN then
		LIST = ARGUMENT_STACK (MACRO_DISPLAY_STACK (MACRO_STACK_TOP)
				       + TP->TOKEN_POD.VALUE - 1);
	else	LIST = TP;

	INDEX = 1;
	do P = LIST repeat (P->TOKEN_POD.NEXT) while (P ^= null ());
		if P->TOKEN_POD.LINE < 0 then do;
			if INDEX > MAX_TOKEN_SPELLING_LENGTH then
				goto ERROR_STRINGIZE_CHARIZE_TOKENS;
			substr (BUFFER, INDEX, 1) = byte (SPACE_CHAR);
			INDEX = INDEX + 1;
		end;
		S = TOKEN_SPELLING (P);
		T = P->TOKEN_POD.TYPE;
		do I = 1 to length (S);
			C = substr (S, I, 1);
			if ((((WHICH = PP_STRINGIZE_TOKEN) &
			      (C = byte (DQUOTE_CHAR))) |
			     ((WHICH = PP_CHARIZE_TOKEN) &
			      (C = byte (SQUOTE_CHAR)))) |
			    (C = byte (BACKSLASH_CHAR))) &
			   ((T = STRING_LITERAL_TOKEN) |
			    (T = CHAR_CONSTANT_TOKEN) |
			    (T = WSTRING_LITERAL_TOKEN) |
			    (T = WCHAR_CONSTANT_TOKEN)) then do;
				if INDEX > MAX_TOKEN_SPELLING_LENGTH then
					goto ERROR_STRINGIZE_CHARIZE_TOKENS;
				substr (BUFFER, INDEX, 1) =
					byte (BACKSLASH_CHAR);
				INDEX = INDEX + 1;
			end;
			if INDEX > MAX_TOKEN_SPELLING_LENGTH then
				goto ERROR_STRINGIZE_CHARIZE_TOKENS;
			substr (BUFFER, INDEX, 1) = C;
			INDEX = INDEX + 1;
		end;
	end;

	DONE_STRINGIZE_CHARIZE_TOKENS:

	INDEX = INDEX - 1;

	P = TALLOC ();
	if WHICH = PP_STRINGIZE_TOKEN then
		P->TOKEN_POD.TYPE = STRING_LITERAL_TOKEN;
	else	P->TOKEN_POD.TYPE = CHAR_CONSTANT_TOKEN;
	P->TOKEN_POD.SPELLING_PTR = SALLOC (INDEX);
	P->TOKEN_POD.SPELLING_PTR->TOKEN_SPELLING_POD.SPELLING
		= substr (BUFFER, 1, INDEX);
	if LIST = null () then
		P->TOKEN_POD.LINE = CURRENT_SOURCE.PHYSICAL_LINE;
	else	P->TOKEN_POD.LINE = LIST->TOKEN_POD.LINE;
	return (P);

	ERROR_STRINGIZE_CHARIZE_TOKENS:

	call PP_ERROR_I (ERR_PP_LONG_STRINGIZE_TOKEN,
			 substr (BUFFER, 1, 14) || '...');
	goto DONE_STRINGIZE_CHARIZE_TOKENS;

end; /* STRINGIZE_CHARIZE_TOKENS */

end; /* GET_NEXT_MACRO_TOKEN */

/* =====================================================================
/* GET_NEXT_UNEXPANDED_TOKEN
/* =================================================================== */

I_GET_NEXT_UNEXPANDED_TOKEN: procedure returns (type (POINTER_T));

	declare TP type (POINTER_T);

	DO_NOT_EXPAND_MACROS = TRUE;
	TP = GET_NEXT_EXPANDED_TOKEN ();
	DO_NOT_EXPAND_MACROS = FALSE;
	return (TP);

end; /* I_GET_NEXT_UNEXPANDED_TOKEN */

/* =====================================================================
/* GET_NEXT_EXPANDED_TOKEN
/*
/* Create and return a (pointer to) token-pod representing the next
/* macro expanded token from the input.
/*
/* -> If the token was preceded by white-space, then the LINE field
/* of the token-pod will be set negative.
/*
/* -> The dummy token pointer END_MACRO_ARGUMENT_TOKEN may be returned
/* to indicate the end of the expansion of a function-like macro argument
/* if the current lexical context is within the expansion of a macro
/* argument list; i.e. when NOTIFY_END_MACRO_ARGUMENT_TOKEN is TRUE.
/*
/* Note that this routine is called when a fully (macro) expanded token
/* is desired.  I.e. when the current lexical context is either within
/* (1) vanilla C source, (2) an #if/#elif preprocessing directive,
/* (3) an #include preprocessing directive, (4) a #line directive,
/* or (4) a function-like macro argument.
/* =================================================================== */

I_GET_NEXT_EXPANDED_TOKEN: procedure returns (type (POINTER_T));

	declare
		K		type (SHORT_T),
		T		type (SHORT_T);
	declare
		TOKEN_PTR	type (POINTER_T),
		MACRO_PTR	type (POINTER_T);

	/* -------------------------------------------------------
	 * Get the next token to expand and subsequently expand it
	 * if possible.  Note that GET_NEXT_PP_TOKEN is either
	 * GET_NEXT_LEXICAL_TOKEN or GET_NEXT_MACRO_TOKEN.
	 * ----------------------------------------------------- */

	BEGIN_NEXT_EXPANDED_TOKEN:

	TOKEN_PTR = GET_NEXT_PP_TOKEN ();

	/* ---------------------------------------------
	 * Check for the end of a macro invocation.
	 * Note that this special token is returned from
	 * GET_NEXT_MACRO_TOKEN (aka GET_NEXT_PP_TOKEN)
	 * iff NOTIFY_END_MACRO_ARGUMENT_TOKEN is TRUE.
	 * ------------------------------------------- */

	if TOKEN_PTR = END_MACRO_ARGUMENT_TOKEN then
		return (TOKEN_PTR);

	T = TOKEN_PTR->TOKEN_POD.TYPE;

	/* ---------------------------------------
	 * See if this is a macro parameter token.
	 * ------------------------------------- */

	if T = PP_MACRO_PARAMETER_TOKEN then do;
		call PUSH_MACRO_ARGUMENT_INVOCATION (TOKEN_PTR);
		goto BEGIN_NEXT_EXPANDED_TOKEN;
	end;

	/* ----------------------------------------------------------------
	 * If this is not an identifier then no special handling is needed.
	 * -------------------------------------------------------------- */

	if T ^= IDENTIFIER_TOKEN then
		goto SEND_TOKEN_POD;

	/* ---------------------------------------------------------
	 * If we really don't want to expand macros then we're done.
	 * ------------------------------------------------------- */

	if DO_NOT_EXPAND_MACROS then
		goto SEND_IDENTIFIER_TOKEN_POD;

	/* --------------------------------------------------------
	 * Here, we have an identifier token; see if it is a macro.
	 * ------------------------------------------------------ */

	MACRO_PTR = LOOKUP_MACRO_BY_TOKEN (TOKEN_PTR);

	/* --------------------------------------------------------------
	 * If it's not a macro, then just send out this identifier token.
	 * ------------------------------------------------------------ */

	if MACRO_PTR = null () then
		goto SEND_IDENTIFIER_TOKEN_POD;

	/* -------------------------------------------
	 * See if this is a predefined built-in macro.
	 * ----------------------------------------- */

	if MACRO_PTR->MACRO_NODE.KIND = DYNAMIC_MACRO_MK then do;
		call TFREE (TOKEN_PTR);
		TOKEN_PTR = MACRO_PTR->MACRO_NODE.GET_TOKEN ();
		goto SEND_TOKEN_POD;
	end;

	/* -------------------------------------------------------
	 * This is a user defined macro; expand it if appropriate.
	 * ----------------------------------------------------- */

	if ^SHOULD_EXPAND_MACRO () then
		goto SEND_IDENTIFIER_TOKEN_POD;

	if PUSH_MACRO_INVOCATION () then
		goto BEGIN_NEXT_EXPANDED_TOKEN;

	/* -----------------------------------------------------------
	 * Send out this identifier token-pod pointed to by TOKEN_PTR.
	 * --------------------------------------------------------- */

	SEND_IDENTIFIER_TOKEN_POD:

	/* See if this identifier token is a C/C++ keyword */

	if T = IDENTIFIER_TOKEN then do;
		K = LOOKUP_KEYWORD (TOKEN_PTR->TOKEN_POD.SPELLING);
		if K ^= NULL_TOKEN then TOKEN_PTR->TOKEN_POD.TYPE = K;
	end;

	/* ------------------------------------------------
	 * Send out this token-pod pointed to by TOKEN_PTR.
	 * ---------------------------------------------- */

	SEND_TOKEN_POD:

	return (TOKEN_PTR);

/* =====================================================================
/* SHOULD_EXPAND_MACRO
/* ---------------------------------------------------------------------
/* Return TRUE if the macro associated with the MACRO_PTR macro-node
/* pointer *should* be expanded.  Otherwise return FALSE.  The TOKEN_PTR
/* token-pod pointer should be represent the macro token.  This routine
/* does the dirty work to see if this macro is already being expanded
/* (of course it isn't that simple) and if it's a function-like macro
/* it check to see if the following token is a "(".
/* =================================================================== */

SHOULD_EXPAND_MACRO: procedure returns (type (BOOL_T));

	declare MACRO_STACK_LEVEL type (SHORT_T);

	do MACRO_STACK_LEVEL = MACRO_STACK_TOP to 1 by -1;
		/*
		/* Check out this level of the macro invocation stack.
		/**/
		if MACRO_NODE_STACK (MACRO_STACK_LEVEL) = null () then do;
			/*
			/* Here, we are expanding a function-like macro
			/* argument. If we are checking an object-like
			/* macro then we know now that we should expand it.
			/**/
			if MACRO_PTR->MACRO_NODE.KIND =
			   OBJECT_LIKE_MACRO_MK then
				return (TRUE);
			/*
			/* Here, we are checking a function-like macro; we
			/* should expand it only if the next token is "(";
			/* when peeking for the "(" however, do not cross
			/* over an end-of-macro-argument boundary iff this
			/* macro is itself in the process of being expanded.
			/* This guards against expanding the following:
			/*
			/*     #define T(f) f(x)
			/*     T(T)
			/*
			/* into "x(x)" rather than "T(x)" as it should be.
			/**/
			else if MACRO_PTR->
				MACRO_NODE.INVOCATION_COUNT > 0 then do;
				if PEEK_FOR_LPAREN_TOKEN (TRUE) then
					return (TRUE);
			end;
			else if PEEK_FOR_LPAREN_TOKEN (FALSE) then
				return (TRUE);
			else	return (FALSE);
		end;
		else if MACRO_NODE_STACK (MACRO_STACK_LEVEL) = MACRO_PTR then
			return (FALSE);
	end;

	/*
	/* Here, the macro is *not* already being expanded at all.
	/* If it is an object-like macro, then it should be expanded;
	/* if it is a function-like macro, we should expand it iff
	/* the next token is a "(".
	/**/

	if MACRO_PTR->MACRO_NODE.KIND = OBJECT_LIKE_MACRO_MK then
		return (TRUE);

	else if PEEK_FOR_LPAREN_TOKEN (FALSE) then
		return (TRUE);

	else	return (FALSE);

/* =====================================================================
/* PEEK_FOR_LPAREN_TOKEN
/*
/* Return TRUE if the next *unexpanded* token to be gotten (from the
/* source file if GET_NEXT_PP_TOKEN is GET_NEXT_LEXICAL_TOKEN or the
/* macro expansion stack if GET_NEXT_PP_TOKEN is GET_NEXT_MACRO_TOKEN)
/* is a "(", otherwise return FALSE.  Note screwy use of the TOKEN_PTR
/* token-pod pointer, needed only if end-of-file is encountered while
/* looking for the "(".
/* =================================================================== */

PEEK_FOR_LPAREN_TOKEN: procedure (STOP_AT_END_OF_MACRO_ARGUMENT)
		       returns   (type (BOOL_T));
	declare
		STOP_AT_END_OF_MACRO_ARGUMENT	type (BOOL_T);
	declare
		SAVE_FLAG			type (BOOL_T),
		NEXTP				type (POINTER_T);

	SAVE_FLAG = NOTIFY_END_MACRO_ARGUMENT_TOKEN;

	NOTIFY_END_MACRO_ARGUMENT_TOKEN = STOP_AT_END_OF_MACRO_ARGUMENT;

	TOKEN_AT_LOOK_AHEAD = TOKEN_PTR;	/* In case we hit EOF */

	NEXTP = GET_NEXT_UNEXPANDED_TOKEN ();

	TOKEN_AT_LOOK_AHEAD = null ();

	NOTIFY_END_MACRO_ARGUMENT_TOKEN = SAVE_FLAG;

	if NEXTP = END_MACRO_ARGUMENT_TOKEN then
		return (FALSE);

	if NEXTP->TOKEN_POD.TYPE = LPAREN_TOKEN then
		return (TRUE);

	call PUSH_BACK_TOKEN (NEXTP);
	return (FALSE);

end; /* PEEK_FOR_LPAREN_TOKEN */

end; /* SHOULD_EXPAND_MACRO */

/* =====================================================================
/* PUSH_MACRO_INVOCATION
/*
/* Push an invocation of the macro assocatied with the MACRO_PTR
/* macro-node pointer onto the macro invocation stack.  If the stack
/* is full or an error is encountered, then emit an appropriate
/* diagnostic and return FALSE otherwise return TRUE.
/* =================================================================== */

PUSH_MACRO_INVOCATION: procedure returns (type (BOOL_T));

	declare DISPLAY	type (SHORT_T);

	/* Check for macro invocation stack overflow */

	if MACRO_STACK_TOP >= HB_MACRO_STACK then do;
		call PP_ERROR_I (ERR_PP_MACRO_STACK_OVERFLOW,
				 MACRO_NAME (MACRO_PTR));
		return (FALSE);
	end;

	CURRENT_MACRO_FUNCTION = MACRO_PTR;

	/*
	/* See if this is "va_start", in which case we'll send out
	/* a special #pragma LPI varargs_used token so the front-end
	/* can deal with this function correctly (i.e. don't inline!).
	/**/

	if MACRO_PTR->MACRO_NODE.NAME = VA_START_NAME then
		call PUT_SIMPLE_PRAGMA_TOKEN (PRAGMA_VARARGS_USED_PK);

	/* Object-like macro invocation */

	if MACRO_PTR->MACRO_NODE.KIND = OBJECT_LIKE_MACRO_MK then
		DISPLAY = 0;

	/* Function-like macro invocation */

	else	DISPLAY = COLLECT_MACRO_ARGUMENT_LIST ();

	/* Push this macro invocation onto the macro invocation stack */

	MACRO_PTR->MACRO_NODE.INVOCATION_COUNT
		= MACRO_PTR->MACRO_NODE.INVOCATION_COUNT + 1;

	MACRO_STACK_TOP			      = MACRO_STACK_TOP + 1;
	MACRO_NODE_STACK    (MACRO_STACK_TOP) = MACRO_PTR;
	MACRO_TOKEN_STACK   (MACRO_STACK_TOP) = MACRO_PTR->MACRO_NODE.
						REPLACEMENT;
	MACRO_DISPLAY_STACK (MACRO_STACK_TOP) = DISPLAY;

	/* Set the pp-token reader to get tokens from the macro stack */

	GET_NEXT_PP_TOKEN = GET_NEXT_MACRO_TOKEN;

	return (TRUE);

/* =====================================================================
/* COLLECT_MACRO_ARGUMENT_LIST
/*
/* Collect the arguments of a function-like macro invocation associated
/* with the MACRO_PTR macro-node pointer.  It is assumed that we have
/* just read the macro name and the left parenthesis.
/*
/* A pointer to the null terminated linked list of token-pods for each
/* argument is pushed onto the argument stack ARGUMENT_STACK.
/*
/* For each token (except the first token in the in each argument), if
/* it is preceded by any white-space then its LINE field will be set
/* negative. This must be done ONLY because of the possible presence of
/* the stringize operator in the corresponding macro replacement list.
/*
/* If the argument list was successfully read then the (display) index
/* into the argument stack of this argument list will be returned; this
/* value will be the index of the first argument in the list, each
/* successive argument  can be indexed simply incrementing this value.
/* Otherwise, an appropriate message will be emitted and -1 will be returned.
/*
/* If no arguments are expected, then nothing will be pushed onto the
/* macro argument stack, and zero will be returned.  It is necessary
/* for this routine to be called in this case however just to parse
/* the argument list (i.e. the closing paranthesis).
/*
/* If too few arguments are given then an appropriate message will be
/* emitted, and the missing arguments will be assumed to be null tokens.
/*
/* If too many arguments are given then an appropriate message will be
/* emitted, and the excess arguments will be discarded.
/*
/* If a closing parenthesis is not found (by the time we get to the end
/* of input (either from the file or from a macro invocation stack list)),
/* then an appropriate message will be emitted, and the close parenthesis
/* will be assumed.
/*
/* -------------------------------------------------------------------
/* [Excerpt] ANSI-C (X3J11/88-159), 3.8.3.2, Stringizing Semantics:
/* -------------------------------------------------------------------
/* Each occurrence of white space between the argument's preprocessing
/* tokens becomes a single space character in the character string
/* literal.  White space before the first preprocessing token and after
/* the last preprocessing token comprising the argument is deleted.
/* =================================================================== */

COLLECT_MACRO_ARGUMENT_LIST: procedure returns (type (SHORT_T));

	declare
		ARGS_EXPECTED		type (SHORT_T),
		ARG_COUNT		type (SHORT_T),
		ARG_INDEX		type (SHORT_T),
		ARG_DISPLAY		type (SHORT_T),
		END_ARG_LIST		type (POINTER_T),
		START_ARG_LIST		type (POINTER_T),
		(TP, P, Q)		type (POINTER_T),
		T			type (SHORT_T),
		PAREN_LEVEL		type (SHORT_T),
		PRECEDING_SPACE		type (BOOL_T),
		SAVE_MACRO_STACK_TOP	type (SHORT_T),
		GOT_NULL_ARG		type (BOOL_T),
		GOT_TOO_MANY_ARGS	type (BOOL_T),
		GOT_ARG_STACK_OVERFLOW	type (BOOL_T);
	declare
		GET_NEXT_ARG_TOKEN	entry returns (type (POINTER_T))
					variable,
		SAVE_SCAN_NEXT_CHAR	entry returns (type (SHORT_T))
					variable;

	/* -------------------------------------------
	 * Determine the number of arguments expected.
	 * ----------------------------------------- */

	ARGS_EXPECTED = MACRO_PTR->MACRO_NODE.NPARAMETERS;

	/* --------------------------------------------------------------
	 * Allocate space on the stack for the exact number of arguments.
	 * ------------------------------------------------------------ */

	if (ARGUMENT_STACK_TOP + ARGS_EXPECTED) > MAX_MACRO_ARGUMENTS then do;
		call PP_ERROR_I (ERR_PP_MACRO_ARG_STACK_OVERFLOW,
				 MACRO_NAME (MACRO_PTR));
		return (0);
	end;
	else if ARGS_EXPECTED > 0 then do;
		ARG_DISPLAY = ARGUMENT_STACK_TOP + 1;
		ARGUMENT_STACK_TOP = ARGUMENT_STACK_TOP + ARGS_EXPECTED;
	end;
	else	ARG_DISPLAY = 0;

	/* --------------------
	 * Set up the defaults.
	 * ------------------ */

	ARG_COUNT		= 0;
	ARG_INDEX		= ARG_DISPLAY - 1;

	START_ARG_LIST		= null ();
	END_ARG_LIST		= null ();

        PAREN_LEVEL		= 1;
	PRECEDING_SPACE		= FALSE;

	GOT_ARG_STACK_OVERFLOW	= FALSE;
	GOT_NULL_ARG		= FALSE;
	GOT_TOO_MANY_ARGS	= FALSE;

	GET_NEXT_ARG_TOKEN	= GET_NEXT_PP_TOKEN;

	/* --------------------------------------------------
	 * Save (mark) the current macro expansion stack top.
	 * ------------------------------------------------ */

	SAVE_MACRO_STACK_TOP	= MACRO_STACK_TOP;

	/* ------------------------------------
	 * Save and change the lexical context.
	 * ---------------------------------- */

	SAVE_SCAN_NEXT_CHAR		= SCAN_NEXT_CHAR;
	SCAN_NEXT_CHAR			= SSCANA;
	NOTIFY_END_MACRO_ARGUMENT_TOKEN	= TRUE;

	/* ---------------------------------------------------
	 * Start parsing the macro argument list. Note that
	 * GET_NEXT_ARG_TOKEN is either GET_NEXT_EXPANDED_TOKEN
	 * or GET_NEXT_PP_TOKEN (which in turn is either
	 * GET_NEXT_MACRO_TOKEN or GET_NEXT_LEXICAL_TOKEN).
	 * ------------------------------------------------- */

	NEXT_ARGUMENT_TOKEN:

	TP = GET_NEXT_ARG_TOKEN ();

	/* ----------------------------------------------------------------
	 * Check for white-space; relevant within argument list (argghhh).
	 * Can only happen if GET_NEXT_ARG_TOKEN is GET_NEXT_LEXICAL_TOKEN.
	 * -------------------------------------------------------------- */

	if TP = WHITE_SPACE_TOKEN then do;
		PRECEDING_SPACE = TRUE;
		goto NEXT_ARGUMENT_TOKEN;
	end;

	/* --------------------------------------------------
	 * See if this is the end of the macro argument list.
	 * ------------------------------------------------ */

	else if TP = END_MACRO_ARGUMENT_TOKEN then do;
		if MACRO_STACK_TOP > SAVE_MACRO_STACK_TOP then
			goto NEXT_ARGUMENT_TOKEN;
		if MACRO_STACK_TOP = SAVE_MACRO_STACK_TOP then do;
			GET_NEXT_ARG_TOKEN = GET_NEXT_PP_TOKEN;
			goto NEXT_ARGUMENT_TOKEN;
		end;
		call PP_ERROR_I (ERR_PP_PARTIAL_MACRO_CALL,
				 MACRO_NAME (MACRO_PTR));
		T = RPAREN_TOKEN;
		goto HAVE_ARGUMENT_TOKEN;
	end;

	else	T = TP->TOKEN_POD.TYPE;

	/* ---------------------------------------------------------
	 * See if this is a macro parameter token; if so, expand it.
	 * ------------------------------------------------------- */

	if T = PP_MACRO_PARAMETER_TOKEN then do;
		call PUSH_MACRO_ARGUMENT_INVOCATION (TP);
		GET_NEXT_ARG_TOKEN = GET_NEXT_EXPANDED_TOKEN;
		goto NEXT_ARGUMENT_TOKEN;
	end;

	/* --------------------------------------------------------------
	 * See if we've either ended one argument and are about to start
	 * the next (i.e. we've encountered an un-parenthesised comma),
	 * or if we've found the end of the macro argument list.
	 * ------------------------------------------------------------ */

	if (MACRO_STACK_TOP <= SAVE_MACRO_STACK_TOP) &
	   ((T = COMMA_TOKEN) | (T = RPAREN_TOKEN))  &
	   (PAREN_LEVEL = 1) then do;

		call TFREE (TP);

		/*
		 * Check for excess arguments.  If there are excess
		 * arguments, then an appropriate error message will
		 * emitted and the execess arguments will be discarded.
		 */

		HAVE_ARGUMENT_TOKEN:

		if (ARG_COUNT >= ARGS_EXPECTED) &
		   ((ARGS_EXPECTED > 0) |
		    (START_ARG_LIST ^= null ()) | (T = COMMA_TOKEN)) then do;
			if ^GOT_TOO_MANY_ARGS then do;
				call PP_ERROR_I (ERR_PP_TOO_MANY_MACRO_ARGS,
						 MACRO_NAME (MACRO_PTR));
				GOT_TOO_MANY_ARGS = TRUE;
			end;
			if T = RPAREN_TOKEN then
				goto DONE_COLLECT_ARGUMENT_LIST;
			else	goto NEXT_ARGUMENT_TOKEN;
		end;

		else if ARGS_EXPECTED > 0 then do;

			/* Give a warning for a null macro argument */

			if START_ARG_LIST = null () then do;
				if ^GOT_NULL_ARG then do;
					if ^SW_X_EMPTY_MACRO_ARGUMENT &
					   (MACRO_PTR->MACRO_NODE.NAME ^=
					    VA_START_NAME) &
					   (ARG_COUNT + 1 = ARGS_EXPECTED) then
						call PP_ERROR_I
						     (ERR_PP_NULL_MACRO_ARG,
						      MACRO_NAME (MACRO_PTR));
					GOT_NULL_ARG = TRUE;
				end;
			end;

			/* Push this argument on the macro argument stack */

			ARG_COUNT = ARG_COUNT + 1;
			ARG_INDEX = ARG_INDEX + 1;
			ARGUMENT_STACK (ARG_INDEX) = START_ARG_LIST;
		end;

		/* See if this is the end of the macro argument list */

		if T = RPAREN_TOKEN then
			goto DONE_COLLECT_ARGUMENT_LIST;

		/* Otherwise, go look for another macro argument */

		START_ARG_LIST = null ();
		END_ARG_LIST = null ();

		goto NEXT_ARGUMENT_TOKEN;
	end;

	/* -------------------------------------------------
	 * Adjust the nested parenthesis level if necessary.
	 * ----------------------------------------------- */

	if T = LPAREN_TOKEN then
		PAREN_LEVEL = PAREN_LEVEL + 1;
	else if (T = RPAREN_TOKEN) & (PAREN_LEVEL > 1) then
		PAREN_LEVEL = PAREN_LEVEL - 1;

	/* ----------------------------------------------------------------
	 * We're within the macro argument list and have an argument token.
	 * -------------------------------------------------------------- */

	if START_ARG_LIST ^= null () then do;
		if PRECEDING_SPACE then
			TP->TOKEN_POD.LINE = -(TP->TOKEN_POD.LINE);
		END_ARG_LIST->TOKEN_POD.NEXT = TP;
	end;
	else	START_ARG_LIST = TP;
	if PRECEDING_SPACE then
		PRECEDING_SPACE = FALSE;
	END_ARG_LIST = TP;
	END_ARG_LIST->TOKEN_POD.NEXT = null ();
	goto NEXT_ARGUMENT_TOKEN;

	/* -------------------------------
	 * End of the macro argument list.
	 * ----------------------------- */

	DONE_COLLECT_ARGUMENT_LIST:

	if ARG_COUNT < ARGS_EXPECTED then do;

		/* ---------------------------------------------
		 * Too few arguments to macro function.  The
		 * missing arguments will be set to null tokens.
		 * ------------------------------------------- */

		/*
		 * As an extension, do *not* give a diagnostic if we
		 * are missing just the last (second) argument to the
		 * "va_start" macro (and <stdarg.h> has been included).
		 */

		if (MACRO_PTR->MACRO_NODE.NAME ^= VA_START_NAME) &
		   (ARG_COUNT + 1 = ARGS_EXPECTED) then
			call PP_ERROR_I (ERR_PP_TOO_FEW_MACRO_ARGS,
					 MACRO_NAME (MACRO_PTR));
		do while ((ARG_COUNT < ARGS_EXPECTED) &
			  (ARG_INDEX < MAX_MACRO_PARAMETERS));
			ARG_INDEX = ARG_INDEX + 1;
			ARG_COUNT = ARG_COUNT + 1;
			ARGUMENT_STACK (ARG_INDEX) = null ();
		end;
	end;

	/* ----------------------------
	 * Restore the lexical context.
	 * -------------------------- */

	NOTIFY_END_MACRO_ARGUMENT_TOKEN	= FALSE;
	SCAN_NEXT_CHAR			= SAVE_SCAN_NEXT_CHAR;

	/* ---------------------------------------------------------------
	 * Return the index into the argument stack of this argument list.
	 * ------------------------------------------------------------- */

	return (ARG_DISPLAY);

end; /* COLLECT_MACRO_ARGUMENT_LIST */

end; /* PUSH_MACRO_INVOCATION */

end; /* I_GET_NEXT_EXPANDED_TOKEN */

/* =====================================================================
/* PUSH_MACRO_ARGUMENT_INVOCATION
/*
/* Push a pointer to the (null terminated) linked list of token-pods
/* representing the ARG_POSITION'th actual argument associated with
/* the most recently invoked macro, onto the MACRO_TOKEN stack.
/* A null pointer will be pushed onto the MACRO_NODE stack, and zero
/* onto the MACRO_DISPLAY stack.
/* =================================================================== */

PUSH_MACRO_ARGUMENT_INVOCATION: procedure (TP);

	declare
		TP		type (POINTER_T);
	declare
		ARG_POSITION	type (SHORT_T),
		ARG_INDEX	type (SHORT_T),
		(P, Q)		type (POINTER_T);

	/* Determine the position of the macro argument */

	ARG_POSITION = TP->TOKEN_POD.VALUE;

	/* Determine index into the macro argument stack */

	ARG_INDEX = MACRO_DISPLAY_STACK(MACRO_STACK_TOP) + ARG_POSITION - 1;

	/* Check for macro invocation stack overflow */

	if MACRO_STACK_TOP >= HB_MACRO_STACK then do;
		call PP_ERROR_I
		     (ERR_PP_MACRO_STACK_OVERFLOW,
		      MACRO_NAME (MACRO_NODE_STACK (MACRO_STACK_TOP)));
		return;
	end;

	/*
	 * Push the pointer to the (null terminated) linked list of token
	 * pods representing the ARG_POSITION'th actual argument of the
	 * macro currently being expanded onto the macro token stack.
	 * If the macro argument was not put on the macro argument stack
	 * (because it overflowed), then push a null pointer.
	 */

	MACRO_STACK_TOP = MACRO_STACK_TOP + 1;
	if (ARG_INDEX >= 1) & (ARG_INDEX <= ARGUMENT_STACK_TOP) then do;
		P = ARGUMENT_STACK (ARG_INDEX);
		if P ^= null () then do;
			if ((TP->TOKEN_POD.LINE < 0) &
			    (P->TOKEN_POD.LINE > 0)) |
			   ((P->TOKEN_POD.LINE < 0) &
			    (TP->TOKEN_POD.LINE > 0)) then do;
				/*
				/* Here, either this macro *parameter* is
				/* preceeded by a space, in which case we
				/* must pass this on to the macro argument
				/* for this invocation (unless it's already
				/* preceeded by a space), OR this macro
				/* *argument* is preceeded by a space, in
				/* which case we must *not* pass this on
				/* to the macro argument (unless the macro
				/* argument is preceeded by a space).
				/*
				/* TODO: free Q somewhere!
				/**/
				Q = TALLOC ();
				Q->TOKEN_POD = P->TOKEN_POD;
				Q->TOKEN_POD.LINE = -Q->TOKEN_POD.LINE;
				P = Q;
			end;
			/* ------
			if TP->TOKEN_POD.LINE < 0 then
				P->TOKEN_POD.LINE = -abs(P->TOKEN_POD.LINE);
			else	P->TOKEN_POD.LINE =  abs(P->TOKEN_POD.LINE);
			------ */
		end;
		MACRO_TOKEN_STACK (MACRO_STACK_TOP) = P;
	end;
	else	MACRO_TOKEN_STACK (MACRO_STACK_TOP) = null ();

	/* Push a dummy on the macro node and macro display stack */

	MACRO_NODE_STACK (MACRO_STACK_TOP) = null ();
	MACRO_DISPLAY_STACK (MACRO_STACK_TOP) = 0;

end; /* PUSH_MACRO_ARGUMENT_INVOCATION */

/* =====================================================================
/* PUSH_BACK_TOKEN
/*
/* Push back the token-pod pointed to by the given token back onto the
/* macro invocation stack.  If the macro invocation stack is empty, then
/* GET_NEXT_PP_TOKEN will be set accordingly to GET_NEXT_MACRO_TOKEN.
/* =================================================================== */

PUSH_BACK_TOKEN: procedure (TP);

	declare TP	type (POINTER_T);

	if TP = null () then return;
	if MACRO_STACK_TOP <= 0 then do;
		MACRO_STACK_TOP = 1;
		MACRO_DISPLAY_STACK (MACRO_STACK_TOP) = 0;
		MACRO_NODE_STACK (MACRO_STACK_TOP) = null ();
		GET_NEXT_PP_TOKEN = GET_NEXT_MACRO_TOKEN;
	end;
	TP->TOKEN_POD.NEXT = MACRO_TOKEN_STACK (MACRO_STACK_TOP);
	MACRO_TOKEN_STACK (MACRO_STACK_TOP) = TP;

end; /* PUSH_BACK_TOKEN */

/***********************************************************************
/* Debugging routines
/***********************************************************************/

/* =====================================================================
/* MDUMP
/*
/* Dump the current macro expansion stack to the standard output.
/* =================================================================== */

/* -debug- ...

MDUMP: procedure;

	declare
		I	type (SHORT_T),
		P	type (POINTER_T);
	declare
		WRITTT	entry   (character (*) varying)
			external,
		WRITNC	entry   (character (*) varying)
			external,
		WRITFW	entry   (character (*) varying, type (SHORT_T))
			external,
		WRITNO	entry   (type (POINTER_T), type (SHORT_T),
			         type (SHORT_T), type (SHORT_T))
			external;

	do I = MACRO_STACK_TOP to 1 by -1;
		call WRITNC ('MAC ');
		call WRITNO (addr (I), 2, 10, -2); call WRITNC (': ');
		if MACRO_NODE_STACK(I) = null () then	
			call WRITNC ('-NULL-');
		else	call WRITNC (MACRO_NAME (MACRO_NODE_STACK (I)));
		call WRITNC (' [');
		call WRITNC (trim (char (MACRO_DISPLAY_STACK (I))));
		call WRITNC (']:');
		do P = MACRO_TOKEN_STACK(I)
		repeat (P->TOKEN_POD.NEXT) while (P ^= null ());
			call WRITNC (' {');
			call WRITNC (TOKEN_SPELLING (P));
			call WRITNC ('}');
		end;
		call WRITTT ('');
	end;
	do I = ARGUMENT_STACK_TOP to 1 by -1;
		call WRITNC ('ARG ');
		call WRITNO (addr (I), 2, 10, -2); call WRITNC (':');
		do P = ARGUMENT_STACK(I)
		repeat (P->TOKEN_POD.NEXT) while (P ^= null ());
			call WRITNC ('{');
			call WRITNC (TOKEN_SPELLING (P));
			call WRITNC ('}');
		end;
		call WRITTT ('');
	end;

end; /* MDUMP */

end; /* CPP */


